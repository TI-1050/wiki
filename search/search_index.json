{"config":{"indexing":"full","lang":["ja"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HZNU TI1050(2018) Contents Status Members Team Reference Document Problem Set \u6218\u672f\u7814\u7a76 \u8bad\u7ec3\u7ec6\u8282 Onsite Online Trainings ICPC Regional Traning CCPC Regional Traning 2018 HDU Multi-University Training 2018 Nowcoder Multi-University Training 2018 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad 2019 Wannafly Winter Camp 2019 HDU Multi-University Training 2019 Nowcoder Multi-University Training Gym Opentrains Random Training Status Retired. Members Name ID Grade Profession Extra Hongtao Xue Hsueh- 2017 Computer Science Blog Lyuzhi Pan Dup4 2017 Software Engineering Blog:CSDN , Blog:cnblogs Tiansong Luo ltslts 2017 Computer Science Team Reference Document GitHub Link PDF Download Problem Set TI1050 \u51fa\u8fc7\u7684\u9898\u76ee\u4eec\u3002 Name Date Practice Link Statement Announcement Editorial The Hangzhou Normal U Qualification Trials for ZJPSC 2020 2020.9.16 Codeforces Statement Announcement Editorial \u6218\u672f\u7814\u7a76 \u6c9f\u901a\u7684\u4f18\u5148\u7ea7\u9ad8\u4e8e\u4e00\u5207\u3002 \u5361\u9898\u7684\u65f6\u5019\uff0c\u4e0d\u8981\u4e09\u4eba\u641e\u4e00\u9898\uff0c\u8bfb\u65b0\u9898\u7684\u4f18\u5148\u7ea7\u9ad8\u4e8e\u4e00\u5207\u3002 \u5982\u679c\u6709\u5199\u7684\u4e0d\u719f\u7ec3\u7684\u9898\u76ee\uff0c\u653e\u5230\u540e\u9762\u5199\u3002 \u7ec6\u8282\u3001\u516c\u5f0f\u7b49\u5728\u4e0a\u673a\u524d\u4e00\u5b9a\u8981\u5728\u8349\u7a3f\u7eb8\u4e0a\u51c6\u5907\u597d\uff0c\u4ee5\u514d\u4e0a\u673a\u540e\u8d8a\u5199\u8d8a\u4e71\u3002 \u961f\u53cb\u4e0a\u673a\u65f6\uff0c\u4e00\u5b9a\u8981\u6c89\u7740\u627e\u81ea\u5df1\u4ee3\u7801 bug\uff0c\u6216\u8005\u60f3\u65b0\u9898\uff0c\u4e0d\u8981\u6d6e\u8e81\uff0c\u4e0d\u8981\u627e\u51fa\u4e00\u70b9 bug \u5c31\u6025\u7740\u4e0a\u673a\u3002 \u5728\u505a\u4e00\u9053\u9898\u6ca1\u6709\u601d\u8def\u7684\u65f6\u5019\uff0c\u4f46\u662f\u6709\u4eba A \u4e86\uff0c\u5148\u4e0d\u8981\u7740\u6025\uff0c\u5148\u770b\u5176\u4ed6\u9898\uff08\u770b\u65b0\u9898\u7684\u4f18\u5148\u7ea7\u5927\u4e8e\u505a\u6ca1\u6709\u601d\u8def\u7684\u9898\uff09\u3002 \u8bf7\u5148\u8ba1\u7b97\u590d\u6742\u5ea6\uff0c\u5982\u679c\u590d\u6742\u5ea6\u4e0d\u600e\u4e48\u5bf9\uff0c\u4e0d\u8981\u6025\u7740\u5199\uff0c\u4f46\u662f\u5982\u679c\u8fc7\u4e86\u4e00\u7247\uff0c\u5e94\u51b2\u4e00\u53d1\u66b4\u529b\u3002 \u5982\u679c\u4e00\u9053\u9898\uff0c\u534a\u5c0f\u65f6\u6ca1\u6709\u601d\u8def\uff0c\u6216\u8005\u601d\u8def\u4e0d\u5bf9\uff0c\u8bf7\u8003\u8651\u5f03\u9898\u3002 \u8981\u786e\u5b9a\u9898\u76ee\u771f\u6b63\u5173\u5fc3\u7684\u662f\u4ec0\u4e48\uff0c\u6709\u65f6\u5019\u53ef\u4ee5\u4e0d\u7528\u8003\u8651\u4e00\u4e9b\u9898\u76ee\u4e0d\u5173\u5fc3\u7684\u56e0\u7d20\u800c\u5f97\u51fa\u7b54\u6848\uff0c\u5efa\u8bae\u4ece\u5168\u5c40\u8003\u8651\uff0c\u7279\u522b\u662f\u8003\u8651\u8d2a\u5fc3\u7684\u65f6\u5019\u8981\u8bd5\u7740\u4e3e\u51fa\u53cd\u4f8b\u3002 \u4e3a\u4e86 AC \u6709\u65f6\u5019\u5e76\u4e0d\u662f\u60f3\u7684\u8d8a\u591a\u8d8a\u597d\u3002 \u6709\u65f6\u5019\u8003\u8651\u95ee\u9898\u53ef\u4ee5\u4ece\u591a\u4e2a\u89d2\u5ea6\u601d\u8003\uff0c\u6765\u60f3\u4e00\u4e0b\u54ea\u4e00\u4e9b\u65b9\u6cd5\u5b9e\u73b0\u8d77\u6765\u66f4\u7b80\u5355\uff0c\u4e0d\u8981\u4e00\u5473\u7684\u60f3\u7740\u6572\u3002 \u4e0d\u8981\u5077\u61d2 \u4e0d\u8981\u590d\u5236\u7c98\u8d34 \u5fc5\u8981\u7684\u65f6\u5019\u6362\u4e00\u4e2a\u4eba\u91cd\u5199\u4ee3\u7801\u3002 \u4ea4\u9898\u524d\u53ef\u4ee5\u5bf9\u7740\u4ee3\u7801\u8ddf\u961f\u53cb\u590d\u8ff0\u4e00\u904d\u81ea\u5df1\u7684\u601d\u8def\uff0c\u770b\u770b\u6709\u6ca1\u6709\u4ec0\u4e48\u9057\u6f0f\u3002 \u5bf9\u4e8e\u9898\u610f\u4e0d\u660e\u786e\u7684\u9898\u76ee\uff0c\u4e00\u5b9a\u8981\u6709\u81f3\u5c11\u4e24\u4eba\u786e\u8ba4\u9898\u610f\u3002\u7279\u522b\u662f\u6bd4\u8d5b\u540e\u671f\uff0c\u65f6\u95f4\u7d27\u5f20\uff0c\u8bfb\u9519\u9898\u610f\u975e\u5e38\u803d\u8bef\u65f6\u95f4\uff0c\u672c\u6765\u53ef\u80fd\u80fd\u505a\u7684\uff0c\u5c31\u8fd9\u4e48\u9519\u5931\u3002 \u6bd4\u8d5b\u7684\u65f6\u5019\u4e0d\u8981\u6709\u538b\u529b\uff0c\u7279\u522b\u662f\u6700\u540e\u4e00\u4e2a\u5c0f\u65f6\uff0c\u5982\u679c\u5f00\u65b0\u9898\uff0c\u4e00\u5b9a\u8981\u51b7\u9759\uff0c\u4e00\u5b9a\u8981\u628a\u601d\u8def\u60f3\u60f3\u6e05\u695a\uff0c\u4e0d\u8981\u53bb\u770b\u65f6\u95f4\u3002 \u8bad\u7ec3\u7ec6\u8282 \u7cfb\u7edf\u4f7f\u7528 Ubuntu16.04\uff0c\u7f16\u8f91\u5668\u4f7f\u7528 Vim\uff0c\u53ea\u4f7f\u7528\u4e00\u53f0\u7535\u8111\uff0c\u4e00\u4e2a\u5c4f\u5e55\uff0c\u7528\u666e\u901a\u952e\u76d8\u3002 \u8bd5\u9898\u6253\u5370\uff0c\u4ee3\u7801\u6253\u5370\u3002 \u8981\u4fdd\u6301\u826f\u597d\u7684\u7cbe\u795e\u72b6\u6001\uff0c\u8981\u575a\u6301\u3002 Onsite Name Date Award Rank Solved A B C D E F G H I J K L M 2018 ZJPSC 2018.04.29 Bronze 86 6/13 O O . . . . . . . O O O O 2018 CCPC Jilin Onsite 2018.09.22 Bronze 95 5/12 O O O O O . . . . . . . 2018 ICPC Shenyang Onsite 2018.10.21 Bronze 74 2/13 . . O . . . . . . O . . . 2018 ICPC Tsingdao Onsite 2018.11.04 Honorable 241 3/13 . . O . . . . . . O . . O 2018 CCPC Final 2018.11.25 Bronze 43 5/12 O O . . . . O . O . . O 2019 ZJPSC 2019.04.27 Gold 7 9/13 . O O . O O O O O O O . . 2019 ICPC China Nanchang Invitational Programming Contest 2019.06.01 Silver 64 5/12 . . . . . O O . . O O O 2019 CCPC Qinghuangdao Onsite 2019.09.22 Bronze 80 4/12 O . . O . O . . O . . . 2019 CCPC Xiamen Onsite 2019.10.20 Silver 36 5/12 O . . O . . O O . O . . 2019 ICPC Nanjing Onsite 2019.10.27 Silver 40 5/11 O . O . . O . O . . O 2019 ICPC Nanchang Onsite 2019.11.10 Gold 28 5/13 . . O . O . O . . . O O . 2019 CCPC Final 2019.11.17 Honorable 91 3/12 O . . . . . . . . . O O 2019 ICPC EC Final 2019.12.15 Silver 87 4/13 O . . . O . . O . . . . O 2020 ZJPSC 2020.10.17 Gold 12 7/12 O O O . O . O ! O . O . 2021 ZJPSC 2021.04.18 Silver 38 7/13 O . O ! . O O . ! O . O O Comment: O for passing during the contest \u00d8 for passing after the contest ! for attempted but failed \u00b7 for having not attempted yet Online Name Date Rank Solved 2018 \u4e2d\u56fd\u5927\u5b66\u751f\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b 2018.08.25 213 5/10 ACM-ICPC 2018 \u5357\u4eac\u8d5b\u533a\u7f51\u7edc\u9884\u8d5b 2018.09.01 308 5/12 ACM-ICPC 2018 \u6c88\u9633\u8d5b\u533a\u7f51\u7edc\u9884\u8d5b 2018.09.08 159 6/11 ACM-ICPC 2018 \u5f90\u5dde\u8d5b\u533a\u7f51\u7edc\u9884\u8d5b 2018.09.09 366 5/11 ACM-ICPC 2018 \u7126\u4f5c\u8d5b\u533a\u7f51\u7edc\u9884\u8d5b 2018.09.15 461 6/12 The 2018 ACM-ICPC Asia Qingdao Regional Contest, Online 2018.09.16 331 5/11 The Preliminary Contest for ICPC China Nanchang National Invitational 2019\u4e2d\u56fd\u5927\u5b66\u751f\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\uff08CCPC\uff09 - \u7f51\u7edc\u9009\u62d4\u8d5b The Preliminary Contest for ICPC Asia Nanjing 2019 The Preliminary Contest for ICPC Asia Xuzhou 2019 The 2019 Asia Nanchang First Round Online Programming Contest The Preliminary Contest for ICPC Asia Shenyang 2019 The Preliminary Contest for ICPC Asia Shanghai 2019 Trainings ICPC Regional Traning Name Date Rank Solved 2017 ACM/ICPC Guangxi Invitational 2018.08.09 174 4/12 2017 ACM/ICPC Asia Regional Qingdao Online 2018.08.10 5/11 ACM-ICPC 2017 Asia Shenyang 2018.08.17 6/13 2017-2018 ACM-ICPC Asia East Continent League Final (ECL-Final 2017) 2018.08.21 144/329 5/13 2015 ICPC Asia Shenyang Regional Contest 2018.10.13 4/172 6/13 2016 ICPC Asia Shenyang Regional Contest 2018.10.14 24/195 6/13 2016-2017 ACM-ICPC CHINA-Final 2018.11.17 163 5/12 The 2018 ICPC Asia Beijing Regional Contest The 2018 ICPC Asia Nanjing Regional Contest The 2019 ICPC Asia Yinchuan Regional Contest The 2019 ICPC Asia Xuzhou Regional Contest CCPC Regional Traning Name Date Rank Solved The 2017 China Collegiate Programming Contest, Hangzhou Site 2018.08.16 42/191 6/12 2017\u4e2d\u56fd\u5927\u5b66\u751f\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b-\u54c8\u5c14\u6ee8\u7ad9 2018.08.23 39/188 4/13 CCPC2018-\u6e56\u5357\u5168\u56fd\u9080\u8bf7\u8d5b 2018.09.05 7/107 7/11 CCPC 2017-2018, Finals 2018.09.12 54/117 5/11 2016 CCPC \u957f\u6625 2018.09.14 37/181 6/11 \u300c\u5b57\u8282\u8df3\u52a8\u676f\u300d2018 \u4e2d\u56fd\u5927\u5b66\u751f\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b-\u5973\u751f\u4e13\u573a 2018.10.25 27/188 5/11 CCPC 2016-2017, Finals 2018.11.10 18/130 8/12 The 2019 China Collegiate Programming Contest Harbin Site 2019\u4e2d\u56fd\u5927\u5b66\u751f\u6210\u7ee9\u8bbe\u8ba1\u7ade\u8d5b-\u5973\u751f\u4e13\u573a 2019CCPC-\u6c5f\u897f\u7701\u8d5b 2018 HDU Multi-University Training Name Date Rank Solved 2018 Multi-University Training Contest 1 2018.08.29 47/770 6/11 2018 Multi-University Training Contest 2 2018.08.31 90/818 3/10 2018 Multi-University Training Contest 3 2018.09.04 40/817 6/13 2018 Multi-University Training Contest 4 2018.09.06 70/582 6/12 2018 Multi-University Training Contest 5 2018.10.28 281 2/12 2018 Multi-University Training Contest 6 2018.10.07 108/797 3/12 2018 Multi-University Training Contest 7 2018.10.10 95/766 4/11 2018 Multi-University Training Contest 8 2018.10.26 48/859 5/12 2018 Multi-University Training Contest 9 2018.10.12 80/750 3/11 2018 Multi-University Training Contest 10 2018.10.17 198/767 5/12 2018 Nowcoder Multi-University Training Name 2018 Nowcoder Multi-University Training Contest 1 2018 Nowcoder Multi-University Training Contest 2 2018 Nowcoder Multi-University Training Contest 5 2018 Nowcoder Multi-University Training Contest 10 2018 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad Name Date Rank Solved 2018 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day1 2018.10.01 248 3/12 2018 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day2 2018.10.02 352 1/11 2018 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day3 2018.10.03 105 3/11 2018 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day4 2018.10.04 105 5/10 2018 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day5 2018.10.05 79 2/12 2018 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day6 2018.10.06 24 6/11 2018 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day7\uff082016 ICPC Tsingdao Regional\uff09 2018.10.07 51 4/13 2019 Wannafly Winter Camp Name Date Solved CCPC-Wannafly Winter Camp Day1 (Div2, onsite) 2019-01-20 4/11 CCPC-Wannafly Winter Camp Day2 (Div2, onsite) 2019-01-21 4/12 CCPC-Wannafly Winter Camp Day3 (Div2, onsite) 2019-01-22 5/10 CCPC-Wannafly Winter Camp Day4 (Div2, onsite) 2019-01-23 6/11 CCPC-Wannafly Winter Camp Day5 (Div2, onsite) 2019-01-24 5/10 CCPC-Wannafly Winter Camp Day7 (Div2, onsite) 2019-01-26 6/10 CCPC-Wannafly Winter Camp Day8 (Div2, onsite) 2019-01-27 4/10 2019 HDU Multi-University Training Name 2019 Multi-University Training Contest 1 2019 Multi-University Training Contest 2 2019 Multi-University Training Contest 3 2019 Multi-University Training Contest 4 2019 Multi-University Training Contest 5 2019 Multi-University Training Contest 6 2019 Multi-University Training Contest 7 2019 Multi-University Training Contest 8 2019 Multi-University Training Contest 9 2019 Multi-University Training Contest 10 2019 Nowcoder Multi-University Training Name 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u4e00\u573a) 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u4e8c\u573a) 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u4e09\u573a) 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u56db\u573a) 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u4e94\u573a) 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u516d\u573a) 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u4e03\u573a) 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u516b\u573a) 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u4e5d\u573a) 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u5341\u573a) Gym Name The 13 th Chinese Northeast Collegiate Programming Contest 2018-2019 ACM-ICPC, China Multi-Provincial Collegiate Programming Contest 2018 German Collegiate Programming Contest (GCPC 18) 2018-2019 ACM-ICPC, Asia Jiaozuo Regional Contest 2018 Benelux Algorithm Programming Contest (BAPC 18) 2018-2019 ACM-ICPC, Asia Dhaka Regional Contest 2019-2020 ICPC, NERC, Southern and Volga Russian Regional Contest 2019-2020 ICPC, Asia Jakarta Regional Contest ICPC 2019-2020 North-Western Russia Regional Contest Opentrains Name XVII Open Cup named after E.V. Pankratiev. Grand Prix of Two Capitals XVII Open Cup named after E.V. Pankratiev. Grand Prix of Moscow Workshops XVII Open Cup named after E.V. Pankratiev. XXI Ural Championship XVIII Open Cup named after E.V. Pankratiev. Grand Prix of Saratov XVIII Open Cup named after E.V. Pankratiev. Grand Prix of SPb XVIII Open Cup named after E.V. Pankratiev. Ukrainian Grand Prix XVIII Open Cup named after E.V. Pankratiev. Grand Prix of Siberia XIV Open Cup named after E.V. Pankratiev. GP of SPb XIX Open Cup named after E.V. Pankratiev. Grand Prix of SPb XIX Open Cup named after E.V. Pankratiev. Grand Prix of Eurasia XIX Open Cup named after E.V. Pankratiev. Grand Prix of Korea XIX Open Cup named after E.V. Pankratiev. Grand Prix of Peterhof XIX Open Cup named after E.V. Pankratiev. Grand Prix of America XIII Open Grodno SU Championship 2011-2012 Summer Petrozavodsk Camp, Warsaw U Contest Petrozavodsk Summer-2013. Gennady Korotkevich Contest 1 Petrozavodsk Winter-2014. Warsaw U Contest Petrozavodsk Winter-2015. Michael Tikhomirov Contest 1 Petrozavodsk Summer-2016. Moscow IPT Contest Petrozavodsk Summer-2017. Warsaw U Contest, XVII OpenCup Petrozavodsk Winter-2017. Jagiellonian U Contest Petrozavodsk Winter-2018. Jagiellonian U Contest Petrozavodsk Winter-2018. Carnegie Mellon U Contest Petrozavodsk Winter-2019. Fukuoka-2018 NWERC 2018 Asia-Jakarata 2018 Lesnoe Ozero 2017. BSUIR Open 2017 Random Training Name Date Rank Solved ACM ICPC, JUST Collegiate Programming Contest (2018) 2018.08.11 - 9/11 2017-2018 ACM-ICPC, Asia Daejeon Regional Contest 2018.08.12 30/88 6/12 BUCT20180814\u9080\u8bf7\u8d5b 2018.08.14 37/172 3/6 ACM ICPC, Amman Collegiate Programming Contest (2018) 2018.08.15 2/95 10/13 2017-2018 ACM-ICPC Southeastern European Regional Programming Contest (SEERC 2017) 2018.08.18 41/93 4/12 ACM ICPC, Damascus University Collegiate Programming Contest(2018) 2018.08.20 2/33 8/12 2017-2018 ACM-ICPC East Central North America Regional Contest (ECNA 2017) 2018.08.22 13/139 7/10 2017 Benelux Algorithm Programming Contest (BAPC 17) 2018.08.24 5/55 8/13 2017-2018 ACM-ICPC Pacific Northwest Regional Contest (Div. 1) 2018.08.28 10/69 5/13 2017-2018 ACM-ICPC Nordic Collegiate Programming Contest (NCPC 2017) 2018.08.30 17/253 7/11 2017-2018 ACM-ICPC Latin American Regional Programming Contest 2018.09.02 24/438 7/13 ZOJ Monthly, March 2018 2018.10.24 117/642 4/10 ZOJ Monthly, January 2018 2018.10.27 10/180 5/10 ZOJ Monthly, June 2018 2018.10.31 12/260 4/10 2018-2019 \u0412\u0441\u0435\u0440\u043e\u0441\u0441\u0438\u0439\u0441\u043a\u0430\u044f \u043a\u043e\u043c\u0430\u043d\u0434\u043d\u0430\u044f \u043e\u043b\u0438\u043c\u043f\u0438\u0430\u0434\u0430 \u0448\u043a\u043e\u043b\u044c\u043d\u0438\u043a\u043e\u0432 \u043f\u043e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044e, \u0438\u043d\u0442\u0435\u0440\u043d\u0435\u0442-\u0442\u0443\u0440 + \u043e\u0442\u0431\u043e\u0440\u044b \u0440\u0435\u0433\u0438\u043e\u043d\u043e\u0432 (\u0412\u041a\u041e\u0428\u041f 18, \u0438\u043d\u0442\u0435\u0440\u043d\u0435\u0442-\u0442\u0443\u0440) 2018.11.11 111 6/12 2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) Solution 2018.11.14 211 7/13 2017-2018 ACM-ICPC German Collegiate Programming Contest (GCPC 2017) 2018.11.21 - 3/11 \u54c8\u5c14\u6ee8\u7406\u5de5\u5927\u5b66\u8f6f\u4ef6\u4e0e\u5fae\u7535\u5b50\u5b66\u9662\u7b2c\u516b\u5c4a\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u540c\u6b65\u8d5b\uff08\u9ad8\u5e74\u7ea7\uff09 2018.12.01 26 9/10 \u5b57\u8282\u8df3\u52a8\u51ac\u4ee4\u8425\u7f51\u7edc\u8d5b 2018.12.01 - 0/10 2018-2019 ACM-ICPC Southeastern European Regional Programming Contest (SEERC 2018) 2018.12.02 62 5/11 2018-2019 ICPC, NEERC, Northern Eurasia Finals (Unrated, Online Mirror, ICPC Rules, Teams Preferred) 2018.12.05 182 5/13 2018-2019 ACM-ICPC Pacific Northwest Regional Contest (Div. 1) 2018.12.07 31 10/13 2018-2019 ACM-ICPC Nordic Collegiate Programming Contest (NCPC 2018) 2018.12.08 90 7/11 2016-2017 ACM-ICPC Pacific Northwest Regional Contest (Div. 1) 2018.12.09 57 8/12 2018\u5e74\u6d59\u6c5f\u4e2d\u533b\u836f\u5927\u5b66\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b 2018.12.22 20 8/13 ZOJ Monthly, January 2019 2019.01.19 16 5/9 2018-2019 Russia Open High School Programming Contest 2019.02.23 94 8/13 2016-2017 CT S03E07: Codeforces Trainings Season 3 Episode 7 2019.02.27 72 6/10 2018-2019 ACM-ICPC, Asia Seoul Regional Contest 2019.03.02 51 4/12 Bubble Cup 11 - Finals [Online Mirror, Div. 1] 2019.03.03 144 2/10 2017-2018 ACM-ICPC, Asia Tsukuba Regional Contest 2019.03.13 37 6/11 \u5e7f\u4e1c\u5de5\u4e1a\u5927\u5b66\u7b2c\u5341\u56db\u5c4a\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b 2019.03.16 8 8/10 \u676d\u5dde\u5e08\u8303\u5927\u5b66\u7b2c\u5341\u4e8c\u5c4a\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b 2019.03.17 - 8/13 \u201c\u7f8e\u767b\u676f\u201d\u4e0a\u6d77\u5e02\u9ad8\u6821\u5927\u5b66\u751f\u7a0b\u5e8f\u8bbe\u8ba1\u9080\u8bf7\u8d5b (\u534e\u4e1c\u7406\u5de5\u5927\u5b66) 2019.05.18 9 6/9 2019CCPC\u6e56\u5357\u5168\u56fd\u9080\u8bf7\u8d5b 2019.05.19 10 5/12 The 10 th Shandong Provincial Collegiate Programming Contest 2019.05.22 4 10/13 2019\u6cb3\u5317\u7701\u5927\u5b66\u751f\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\uff08\u91cd\u73b0\u8d5b\uff09 2019.05.25 1 9/12 The 2019 ACM-ICPC China Shannxi Provincial Programming Contest 2019.05.26 7 6/13 2020, XIII Samara Regional Intercollegiate Programming Contest 2020.4.6 8/168 13/13 2019-2020 ACM-ICPC Pacific Northwest Regional Contest (Div. 1) 2020.4.11 33/153 9/13 2018 ACM-ICPC, Syrian Collegiate Programming Contest 2020.4.12 17/262 10/12 \u201c\u79d1\u5927\u8baf\u98de\u676f\u201d\u7b2c18\u5c4a\u4e0a\u6d77\u5927\u5b66\u7a0b\u5e8f\u8bbe\u8ba1\u8054\u8d5b\u6625\u5b63\u8d5b\u66a8\u9ad8\u6821\u7f51\u7edc\u53cb\u8c0a\u8d5b 2020.4.18 19/3177 9/12 2019-2020 ACM-ICPC Brazil Subregional Programming Contest 2020.4.19 9/362 11/13 2017-2018 ACM-ICPC, NEERC, Southern Subregional Contest 2020.4.25 99/5078 9/13 2016-2017 ACM-ICPC, NEERC, Southern Subregional Contest 2020.5.4 86/4048 9/12 22019-2020 ACM-ICPC Latin American Regional Programming Contest 2020.5.5 85/1179 7/13","title":"HZNU TI1050(2018)"},{"location":"#status","text":"Retired.","title":"Status"},{"location":"#members","text":"Name ID Grade Profession Extra Hongtao Xue Hsueh- 2017 Computer Science Blog Lyuzhi Pan Dup4 2017 Software Engineering Blog:CSDN , Blog:cnblogs Tiansong Luo ltslts 2017 Computer Science","title":"Members"},{"location":"#team-reference-document","text":"GitHub Link PDF Download","title":"Team Reference Document"},{"location":"#problem-set","text":"TI1050 \u51fa\u8fc7\u7684\u9898\u76ee\u4eec\u3002 Name Date Practice Link Statement Announcement Editorial The Hangzhou Normal U Qualification Trials for ZJPSC 2020 2020.9.16 Codeforces Statement Announcement Editorial","title":"Problem Set"},{"location":"#\u6218\u672f\u7814\u7a76","text":"\u6c9f\u901a\u7684\u4f18\u5148\u7ea7\u9ad8\u4e8e\u4e00\u5207\u3002 \u5361\u9898\u7684\u65f6\u5019\uff0c\u4e0d\u8981\u4e09\u4eba\u641e\u4e00\u9898\uff0c\u8bfb\u65b0\u9898\u7684\u4f18\u5148\u7ea7\u9ad8\u4e8e\u4e00\u5207\u3002 \u5982\u679c\u6709\u5199\u7684\u4e0d\u719f\u7ec3\u7684\u9898\u76ee\uff0c\u653e\u5230\u540e\u9762\u5199\u3002 \u7ec6\u8282\u3001\u516c\u5f0f\u7b49\u5728\u4e0a\u673a\u524d\u4e00\u5b9a\u8981\u5728\u8349\u7a3f\u7eb8\u4e0a\u51c6\u5907\u597d\uff0c\u4ee5\u514d\u4e0a\u673a\u540e\u8d8a\u5199\u8d8a\u4e71\u3002 \u961f\u53cb\u4e0a\u673a\u65f6\uff0c\u4e00\u5b9a\u8981\u6c89\u7740\u627e\u81ea\u5df1\u4ee3\u7801 bug\uff0c\u6216\u8005\u60f3\u65b0\u9898\uff0c\u4e0d\u8981\u6d6e\u8e81\uff0c\u4e0d\u8981\u627e\u51fa\u4e00\u70b9 bug \u5c31\u6025\u7740\u4e0a\u673a\u3002 \u5728\u505a\u4e00\u9053\u9898\u6ca1\u6709\u601d\u8def\u7684\u65f6\u5019\uff0c\u4f46\u662f\u6709\u4eba A \u4e86\uff0c\u5148\u4e0d\u8981\u7740\u6025\uff0c\u5148\u770b\u5176\u4ed6\u9898\uff08\u770b\u65b0\u9898\u7684\u4f18\u5148\u7ea7\u5927\u4e8e\u505a\u6ca1\u6709\u601d\u8def\u7684\u9898\uff09\u3002 \u8bf7\u5148\u8ba1\u7b97\u590d\u6742\u5ea6\uff0c\u5982\u679c\u590d\u6742\u5ea6\u4e0d\u600e\u4e48\u5bf9\uff0c\u4e0d\u8981\u6025\u7740\u5199\uff0c\u4f46\u662f\u5982\u679c\u8fc7\u4e86\u4e00\u7247\uff0c\u5e94\u51b2\u4e00\u53d1\u66b4\u529b\u3002 \u5982\u679c\u4e00\u9053\u9898\uff0c\u534a\u5c0f\u65f6\u6ca1\u6709\u601d\u8def\uff0c\u6216\u8005\u601d\u8def\u4e0d\u5bf9\uff0c\u8bf7\u8003\u8651\u5f03\u9898\u3002 \u8981\u786e\u5b9a\u9898\u76ee\u771f\u6b63\u5173\u5fc3\u7684\u662f\u4ec0\u4e48\uff0c\u6709\u65f6\u5019\u53ef\u4ee5\u4e0d\u7528\u8003\u8651\u4e00\u4e9b\u9898\u76ee\u4e0d\u5173\u5fc3\u7684\u56e0\u7d20\u800c\u5f97\u51fa\u7b54\u6848\uff0c\u5efa\u8bae\u4ece\u5168\u5c40\u8003\u8651\uff0c\u7279\u522b\u662f\u8003\u8651\u8d2a\u5fc3\u7684\u65f6\u5019\u8981\u8bd5\u7740\u4e3e\u51fa\u53cd\u4f8b\u3002 \u4e3a\u4e86 AC \u6709\u65f6\u5019\u5e76\u4e0d\u662f\u60f3\u7684\u8d8a\u591a\u8d8a\u597d\u3002 \u6709\u65f6\u5019\u8003\u8651\u95ee\u9898\u53ef\u4ee5\u4ece\u591a\u4e2a\u89d2\u5ea6\u601d\u8003\uff0c\u6765\u60f3\u4e00\u4e0b\u54ea\u4e00\u4e9b\u65b9\u6cd5\u5b9e\u73b0\u8d77\u6765\u66f4\u7b80\u5355\uff0c\u4e0d\u8981\u4e00\u5473\u7684\u60f3\u7740\u6572\u3002 \u4e0d\u8981\u5077\u61d2 \u4e0d\u8981\u590d\u5236\u7c98\u8d34 \u5fc5\u8981\u7684\u65f6\u5019\u6362\u4e00\u4e2a\u4eba\u91cd\u5199\u4ee3\u7801\u3002 \u4ea4\u9898\u524d\u53ef\u4ee5\u5bf9\u7740\u4ee3\u7801\u8ddf\u961f\u53cb\u590d\u8ff0\u4e00\u904d\u81ea\u5df1\u7684\u601d\u8def\uff0c\u770b\u770b\u6709\u6ca1\u6709\u4ec0\u4e48\u9057\u6f0f\u3002 \u5bf9\u4e8e\u9898\u610f\u4e0d\u660e\u786e\u7684\u9898\u76ee\uff0c\u4e00\u5b9a\u8981\u6709\u81f3\u5c11\u4e24\u4eba\u786e\u8ba4\u9898\u610f\u3002\u7279\u522b\u662f\u6bd4\u8d5b\u540e\u671f\uff0c\u65f6\u95f4\u7d27\u5f20\uff0c\u8bfb\u9519\u9898\u610f\u975e\u5e38\u803d\u8bef\u65f6\u95f4\uff0c\u672c\u6765\u53ef\u80fd\u80fd\u505a\u7684\uff0c\u5c31\u8fd9\u4e48\u9519\u5931\u3002 \u6bd4\u8d5b\u7684\u65f6\u5019\u4e0d\u8981\u6709\u538b\u529b\uff0c\u7279\u522b\u662f\u6700\u540e\u4e00\u4e2a\u5c0f\u65f6\uff0c\u5982\u679c\u5f00\u65b0\u9898\uff0c\u4e00\u5b9a\u8981\u51b7\u9759\uff0c\u4e00\u5b9a\u8981\u628a\u601d\u8def\u60f3\u60f3\u6e05\u695a\uff0c\u4e0d\u8981\u53bb\u770b\u65f6\u95f4\u3002","title":"\u6218\u672f\u7814\u7a76"},{"location":"#\u8bad\u7ec3\u7ec6\u8282","text":"\u7cfb\u7edf\u4f7f\u7528 Ubuntu16.04\uff0c\u7f16\u8f91\u5668\u4f7f\u7528 Vim\uff0c\u53ea\u4f7f\u7528\u4e00\u53f0\u7535\u8111\uff0c\u4e00\u4e2a\u5c4f\u5e55\uff0c\u7528\u666e\u901a\u952e\u76d8\u3002 \u8bd5\u9898\u6253\u5370\uff0c\u4ee3\u7801\u6253\u5370\u3002 \u8981\u4fdd\u6301\u826f\u597d\u7684\u7cbe\u795e\u72b6\u6001\uff0c\u8981\u575a\u6301\u3002","title":"\u8bad\u7ec3\u7ec6\u8282"},{"location":"#onsite","text":"Name Date Award Rank Solved A B C D E F G H I J K L M 2018 ZJPSC 2018.04.29 Bronze 86 6/13 O O . . . . . . . O O O O 2018 CCPC Jilin Onsite 2018.09.22 Bronze 95 5/12 O O O O O . . . . . . . 2018 ICPC Shenyang Onsite 2018.10.21 Bronze 74 2/13 . . O . . . . . . O . . . 2018 ICPC Tsingdao Onsite 2018.11.04 Honorable 241 3/13 . . O . . . . . . O . . O 2018 CCPC Final 2018.11.25 Bronze 43 5/12 O O . . . . O . O . . O 2019 ZJPSC 2019.04.27 Gold 7 9/13 . O O . O O O O O O O . . 2019 ICPC China Nanchang Invitational Programming Contest 2019.06.01 Silver 64 5/12 . . . . . O O . . O O O 2019 CCPC Qinghuangdao Onsite 2019.09.22 Bronze 80 4/12 O . . O . O . . O . . . 2019 CCPC Xiamen Onsite 2019.10.20 Silver 36 5/12 O . . O . . O O . O . . 2019 ICPC Nanjing Onsite 2019.10.27 Silver 40 5/11 O . O . . O . O . . O 2019 ICPC Nanchang Onsite 2019.11.10 Gold 28 5/13 . . O . O . O . . . O O . 2019 CCPC Final 2019.11.17 Honorable 91 3/12 O . . . . . . . . . O O 2019 ICPC EC Final 2019.12.15 Silver 87 4/13 O . . . O . . O . . . . O 2020 ZJPSC 2020.10.17 Gold 12 7/12 O O O . O . O ! O . O . 2021 ZJPSC 2021.04.18 Silver 38 7/13 O . O ! . O O . ! O . O O Comment: O for passing during the contest \u00d8 for passing after the contest ! for attempted but failed \u00b7 for having not attempted yet","title":"Onsite"},{"location":"#online","text":"Name Date Rank Solved 2018 \u4e2d\u56fd\u5927\u5b66\u751f\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b 2018.08.25 213 5/10 ACM-ICPC 2018 \u5357\u4eac\u8d5b\u533a\u7f51\u7edc\u9884\u8d5b 2018.09.01 308 5/12 ACM-ICPC 2018 \u6c88\u9633\u8d5b\u533a\u7f51\u7edc\u9884\u8d5b 2018.09.08 159 6/11 ACM-ICPC 2018 \u5f90\u5dde\u8d5b\u533a\u7f51\u7edc\u9884\u8d5b 2018.09.09 366 5/11 ACM-ICPC 2018 \u7126\u4f5c\u8d5b\u533a\u7f51\u7edc\u9884\u8d5b 2018.09.15 461 6/12 The 2018 ACM-ICPC Asia Qingdao Regional Contest, Online 2018.09.16 331 5/11 The Preliminary Contest for ICPC China Nanchang National Invitational 2019\u4e2d\u56fd\u5927\u5b66\u751f\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\uff08CCPC\uff09 - \u7f51\u7edc\u9009\u62d4\u8d5b The Preliminary Contest for ICPC Asia Nanjing 2019 The Preliminary Contest for ICPC Asia Xuzhou 2019 The 2019 Asia Nanchang First Round Online Programming Contest The Preliminary Contest for ICPC Asia Shenyang 2019 The Preliminary Contest for ICPC Asia Shanghai 2019","title":"Online"},{"location":"#trainings","text":"","title":"Trainings"},{"location":"#icpc-regional-traning","text":"Name Date Rank Solved 2017 ACM/ICPC Guangxi Invitational 2018.08.09 174 4/12 2017 ACM/ICPC Asia Regional Qingdao Online 2018.08.10 5/11 ACM-ICPC 2017 Asia Shenyang 2018.08.17 6/13 2017-2018 ACM-ICPC Asia East Continent League Final (ECL-Final 2017) 2018.08.21 144/329 5/13 2015 ICPC Asia Shenyang Regional Contest 2018.10.13 4/172 6/13 2016 ICPC Asia Shenyang Regional Contest 2018.10.14 24/195 6/13 2016-2017 ACM-ICPC CHINA-Final 2018.11.17 163 5/12 The 2018 ICPC Asia Beijing Regional Contest The 2018 ICPC Asia Nanjing Regional Contest The 2019 ICPC Asia Yinchuan Regional Contest The 2019 ICPC Asia Xuzhou Regional Contest","title":"ICPC Regional Traning"},{"location":"#ccpc-regional-traning","text":"Name Date Rank Solved The 2017 China Collegiate Programming Contest, Hangzhou Site 2018.08.16 42/191 6/12 2017\u4e2d\u56fd\u5927\u5b66\u751f\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b-\u54c8\u5c14\u6ee8\u7ad9 2018.08.23 39/188 4/13 CCPC2018-\u6e56\u5357\u5168\u56fd\u9080\u8bf7\u8d5b 2018.09.05 7/107 7/11 CCPC 2017-2018, Finals 2018.09.12 54/117 5/11 2016 CCPC \u957f\u6625 2018.09.14 37/181 6/11 \u300c\u5b57\u8282\u8df3\u52a8\u676f\u300d2018 \u4e2d\u56fd\u5927\u5b66\u751f\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b-\u5973\u751f\u4e13\u573a 2018.10.25 27/188 5/11 CCPC 2016-2017, Finals 2018.11.10 18/130 8/12 The 2019 China Collegiate Programming Contest Harbin Site 2019\u4e2d\u56fd\u5927\u5b66\u751f\u6210\u7ee9\u8bbe\u8ba1\u7ade\u8d5b-\u5973\u751f\u4e13\u573a 2019CCPC-\u6c5f\u897f\u7701\u8d5b","title":"CCPC Regional Traning"},{"location":"#2018-hdu-multi-university-training","text":"Name Date Rank Solved 2018 Multi-University Training Contest 1 2018.08.29 47/770 6/11 2018 Multi-University Training Contest 2 2018.08.31 90/818 3/10 2018 Multi-University Training Contest 3 2018.09.04 40/817 6/13 2018 Multi-University Training Contest 4 2018.09.06 70/582 6/12 2018 Multi-University Training Contest 5 2018.10.28 281 2/12 2018 Multi-University Training Contest 6 2018.10.07 108/797 3/12 2018 Multi-University Training Contest 7 2018.10.10 95/766 4/11 2018 Multi-University Training Contest 8 2018.10.26 48/859 5/12 2018 Multi-University Training Contest 9 2018.10.12 80/750 3/11 2018 Multi-University Training Contest 10 2018.10.17 198/767 5/12","title":"2018 HDU Multi-University Training"},{"location":"#2018-nowcoder-multi-university-training","text":"Name 2018 Nowcoder Multi-University Training Contest 1 2018 Nowcoder Multi-University Training Contest 2 2018 Nowcoder Multi-University Training Contest 5 2018 Nowcoder Multi-University Training Contest 10","title":"2018 Nowcoder Multi-University Training"},{"location":"#2018-\u725b\u5ba2\u56fd\u5e86\u96c6\u8bad","text":"Name Date Rank Solved 2018 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day1 2018.10.01 248 3/12 2018 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day2 2018.10.02 352 1/11 2018 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day3 2018.10.03 105 3/11 2018 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day4 2018.10.04 105 5/10 2018 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day5 2018.10.05 79 2/12 2018 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day6 2018.10.06 24 6/11 2018 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad\u6d3e\u5bf9 Day7\uff082016 ICPC Tsingdao Regional\uff09 2018.10.07 51 4/13","title":"2018 \u725b\u5ba2\u56fd\u5e86\u96c6\u8bad"},{"location":"#2019-wannafly-winter-camp","text":"Name Date Solved CCPC-Wannafly Winter Camp Day1 (Div2, onsite) 2019-01-20 4/11 CCPC-Wannafly Winter Camp Day2 (Div2, onsite) 2019-01-21 4/12 CCPC-Wannafly Winter Camp Day3 (Div2, onsite) 2019-01-22 5/10 CCPC-Wannafly Winter Camp Day4 (Div2, onsite) 2019-01-23 6/11 CCPC-Wannafly Winter Camp Day5 (Div2, onsite) 2019-01-24 5/10 CCPC-Wannafly Winter Camp Day7 (Div2, onsite) 2019-01-26 6/10 CCPC-Wannafly Winter Camp Day8 (Div2, onsite) 2019-01-27 4/10","title":"2019 Wannafly Winter Camp"},{"location":"#2019-hdu-multi-university-training","text":"Name 2019 Multi-University Training Contest 1 2019 Multi-University Training Contest 2 2019 Multi-University Training Contest 3 2019 Multi-University Training Contest 4 2019 Multi-University Training Contest 5 2019 Multi-University Training Contest 6 2019 Multi-University Training Contest 7 2019 Multi-University Training Contest 8 2019 Multi-University Training Contest 9 2019 Multi-University Training Contest 10","title":"2019 HDU Multi-University Training"},{"location":"#2019-nowcoder-multi-university-training","text":"Name 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u4e00\u573a) 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u4e8c\u573a) 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u4e09\u573a) 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u56db\u573a) 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u4e94\u573a) 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u516d\u573a) 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u4e03\u573a) 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u516b\u573a) 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u4e5d\u573a) 2019\u725b\u5ba2\u6691\u671f\u591a\u6821\u8bad\u7ec3\u8425(\u7b2c\u5341\u573a)","title":"2019 Nowcoder Multi-University Training"},{"location":"#gym","text":"Name The 13 th Chinese Northeast Collegiate Programming Contest 2018-2019 ACM-ICPC, China Multi-Provincial Collegiate Programming Contest 2018 German Collegiate Programming Contest (GCPC 18) 2018-2019 ACM-ICPC, Asia Jiaozuo Regional Contest 2018 Benelux Algorithm Programming Contest (BAPC 18) 2018-2019 ACM-ICPC, Asia Dhaka Regional Contest 2019-2020 ICPC, NERC, Southern and Volga Russian Regional Contest 2019-2020 ICPC, Asia Jakarta Regional Contest ICPC 2019-2020 North-Western Russia Regional Contest","title":"Gym"},{"location":"#opentrains","text":"Name XVII Open Cup named after E.V. Pankratiev. Grand Prix of Two Capitals XVII Open Cup named after E.V. Pankratiev. Grand Prix of Moscow Workshops XVII Open Cup named after E.V. Pankratiev. XXI Ural Championship XVIII Open Cup named after E.V. Pankratiev. Grand Prix of Saratov XVIII Open Cup named after E.V. Pankratiev. Grand Prix of SPb XVIII Open Cup named after E.V. Pankratiev. Ukrainian Grand Prix XVIII Open Cup named after E.V. Pankratiev. Grand Prix of Siberia XIV Open Cup named after E.V. Pankratiev. GP of SPb XIX Open Cup named after E.V. Pankratiev. Grand Prix of SPb XIX Open Cup named after E.V. Pankratiev. Grand Prix of Eurasia XIX Open Cup named after E.V. Pankratiev. Grand Prix of Korea XIX Open Cup named after E.V. Pankratiev. Grand Prix of Peterhof XIX Open Cup named after E.V. Pankratiev. Grand Prix of America XIII Open Grodno SU Championship 2011-2012 Summer Petrozavodsk Camp, Warsaw U Contest Petrozavodsk Summer-2013. Gennady Korotkevich Contest 1 Petrozavodsk Winter-2014. Warsaw U Contest Petrozavodsk Winter-2015. Michael Tikhomirov Contest 1 Petrozavodsk Summer-2016. Moscow IPT Contest Petrozavodsk Summer-2017. Warsaw U Contest, XVII OpenCup Petrozavodsk Winter-2017. Jagiellonian U Contest Petrozavodsk Winter-2018. Jagiellonian U Contest Petrozavodsk Winter-2018. Carnegie Mellon U Contest Petrozavodsk Winter-2019. Fukuoka-2018 NWERC 2018 Asia-Jakarata 2018 Lesnoe Ozero 2017. BSUIR Open 2017","title":"Opentrains"},{"location":"#random-training","text":"Name Date Rank Solved ACM ICPC, JUST Collegiate Programming Contest (2018) 2018.08.11 - 9/11 2017-2018 ACM-ICPC, Asia Daejeon Regional Contest 2018.08.12 30/88 6/12 BUCT20180814\u9080\u8bf7\u8d5b 2018.08.14 37/172 3/6 ACM ICPC, Amman Collegiate Programming Contest (2018) 2018.08.15 2/95 10/13 2017-2018 ACM-ICPC Southeastern European Regional Programming Contest (SEERC 2017) 2018.08.18 41/93 4/12 ACM ICPC, Damascus University Collegiate Programming Contest(2018) 2018.08.20 2/33 8/12 2017-2018 ACM-ICPC East Central North America Regional Contest (ECNA 2017) 2018.08.22 13/139 7/10 2017 Benelux Algorithm Programming Contest (BAPC 17) 2018.08.24 5/55 8/13 2017-2018 ACM-ICPC Pacific Northwest Regional Contest (Div. 1) 2018.08.28 10/69 5/13 2017-2018 ACM-ICPC Nordic Collegiate Programming Contest (NCPC 2017) 2018.08.30 17/253 7/11 2017-2018 ACM-ICPC Latin American Regional Programming Contest 2018.09.02 24/438 7/13 ZOJ Monthly, March 2018 2018.10.24 117/642 4/10 ZOJ Monthly, January 2018 2018.10.27 10/180 5/10 ZOJ Monthly, June 2018 2018.10.31 12/260 4/10 2018-2019 \u0412\u0441\u0435\u0440\u043e\u0441\u0441\u0438\u0439\u0441\u043a\u0430\u044f \u043a\u043e\u043c\u0430\u043d\u0434\u043d\u0430\u044f \u043e\u043b\u0438\u043c\u043f\u0438\u0430\u0434\u0430 \u0448\u043a\u043e\u043b\u044c\u043d\u0438\u043a\u043e\u0432 \u043f\u043e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044e, \u0438\u043d\u0442\u0435\u0440\u043d\u0435\u0442-\u0442\u0443\u0440 + \u043e\u0442\u0431\u043e\u0440\u044b \u0440\u0435\u0433\u0438\u043e\u043d\u043e\u0432 (\u0412\u041a\u041e\u0428\u041f 18, \u0438\u043d\u0442\u0435\u0440\u043d\u0435\u0442-\u0442\u0443\u0440) 2018.11.11 111 6/12 2018-2019 ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) Solution 2018.11.14 211 7/13 2017-2018 ACM-ICPC German Collegiate Programming Contest (GCPC 2017) 2018.11.21 - 3/11 \u54c8\u5c14\u6ee8\u7406\u5de5\u5927\u5b66\u8f6f\u4ef6\u4e0e\u5fae\u7535\u5b50\u5b66\u9662\u7b2c\u516b\u5c4a\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\u540c\u6b65\u8d5b\uff08\u9ad8\u5e74\u7ea7\uff09 2018.12.01 26 9/10 \u5b57\u8282\u8df3\u52a8\u51ac\u4ee4\u8425\u7f51\u7edc\u8d5b 2018.12.01 - 0/10 2018-2019 ACM-ICPC Southeastern European Regional Programming Contest (SEERC 2018) 2018.12.02 62 5/11 2018-2019 ICPC, NEERC, Northern Eurasia Finals (Unrated, Online Mirror, ICPC Rules, Teams Preferred) 2018.12.05 182 5/13 2018-2019 ACM-ICPC Pacific Northwest Regional Contest (Div. 1) 2018.12.07 31 10/13 2018-2019 ACM-ICPC Nordic Collegiate Programming Contest (NCPC 2018) 2018.12.08 90 7/11 2016-2017 ACM-ICPC Pacific Northwest Regional Contest (Div. 1) 2018.12.09 57 8/12 2018\u5e74\u6d59\u6c5f\u4e2d\u533b\u836f\u5927\u5b66\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b 2018.12.22 20 8/13 ZOJ Monthly, January 2019 2019.01.19 16 5/9 2018-2019 Russia Open High School Programming Contest 2019.02.23 94 8/13 2016-2017 CT S03E07: Codeforces Trainings Season 3 Episode 7 2019.02.27 72 6/10 2018-2019 ACM-ICPC, Asia Seoul Regional Contest 2019.03.02 51 4/12 Bubble Cup 11 - Finals [Online Mirror, Div. 1] 2019.03.03 144 2/10 2017-2018 ACM-ICPC, Asia Tsukuba Regional Contest 2019.03.13 37 6/11 \u5e7f\u4e1c\u5de5\u4e1a\u5927\u5b66\u7b2c\u5341\u56db\u5c4a\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b 2019.03.16 8 8/10 \u676d\u5dde\u5e08\u8303\u5927\u5b66\u7b2c\u5341\u4e8c\u5c4a\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b 2019.03.17 - 8/13 \u201c\u7f8e\u767b\u676f\u201d\u4e0a\u6d77\u5e02\u9ad8\u6821\u5927\u5b66\u751f\u7a0b\u5e8f\u8bbe\u8ba1\u9080\u8bf7\u8d5b (\u534e\u4e1c\u7406\u5de5\u5927\u5b66) 2019.05.18 9 6/9 2019CCPC\u6e56\u5357\u5168\u56fd\u9080\u8bf7\u8d5b 2019.05.19 10 5/12 The 10 th Shandong Provincial Collegiate Programming Contest 2019.05.22 4 10/13 2019\u6cb3\u5317\u7701\u5927\u5b66\u751f\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b\uff08\u91cd\u73b0\u8d5b\uff09 2019.05.25 1 9/12 The 2019 ACM-ICPC China Shannxi Provincial Programming Contest 2019.05.26 7 6/13 2020, XIII Samara Regional Intercollegiate Programming Contest 2020.4.6 8/168 13/13 2019-2020 ACM-ICPC Pacific Northwest Regional Contest (Div. 1) 2020.4.11 33/153 9/13 2018 ACM-ICPC, Syrian Collegiate Programming Contest 2020.4.12 17/262 10/12 \u201c\u79d1\u5927\u8baf\u98de\u676f\u201d\u7b2c18\u5c4a\u4e0a\u6d77\u5927\u5b66\u7a0b\u5e8f\u8bbe\u8ba1\u8054\u8d5b\u6625\u5b63\u8d5b\u66a8\u9ad8\u6821\u7f51\u7edc\u53cb\u8c0a\u8d5b 2020.4.18 19/3177 9/12 2019-2020 ACM-ICPC Brazil Subregional Programming Contest 2020.4.19 9/362 11/13 2017-2018 ACM-ICPC, NEERC, Southern Subregional Contest 2020.4.25 99/5078 9/13 2016-2017 ACM-ICPC, NEERC, Southern Subregional Contest 2020.5.4 86/4048 9/12 22019-2020 ACM-ICPC Latin American Regional Programming Contest 2020.5.5 85/1179 7/13","title":"Random Training"},{"location":"online/2018-CCPC-Online/","text":"2018 \u4e2d\u56fd\u5927\u5b66\u751f\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b Contents A. Buy and Resell B. Congruence equation C. Dream D. Find Integer E. GuGu Convolution F. Neko and Inu G. Neko's loop H. Search for Answer I. Tree and Permutation J. YJJ's Salesman A. Buy and Resell \u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u4ea4\u6613\u70b9\uff0c\u6bcf\u6b21\u80fd\u591f\u9009\u62e9\u4e70\u6216\u8005\u5356\uff0c\u6c42\u83b7\u5f97\u6700\u5927\u5229\u6da6\u3002 \u601d\u8def\uff1a \u7ef4\u62a4\u4e24\u4e2a\u4f18\u5148\u961f\u5217\uff0c\u4e00\u4e2a\u662f\u5356\uff0c\u4e00\u4e2a\u662f\u66ff\u6362\uff0c\u5f53\u4ef7\u683c\u5dee\u76f8\u540c\u65f6\uff0c\u4f18\u5148\u66ff\u6362\uff0c\u56e0\u4e3a\u6b21\u6570\u8981\u6700\u5c11\u3002 Code #include <bits/stdc++.h> using namespace std ; #define ll long long #define N 100010 int t , n ; ll arr [ N ]; priority_queue < ll , vector < ll > , greater < ll > > q [ 2 ]; inline void Run () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%lld\" , arr + i ); for ( int i = 0 ; i < 2 ; ++ i ) while ( ! q [ i ]. empty ()) q [ i ]. pop (); ll ans = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( q [ 0 ]. empty () && q [ 1 ]. empty ()) q [ 0 ]. emplace ( arr [ i ]); else if ( q [ 1 ]. empty ()) { ll top = q [ 0 ]. top (); if ( arr [ i ] > top ) { q [ 0 ]. pop (); ans += arr [ i ] - top ; q [ 1 ]. emplace ( arr [ i ]); } else q [ 0 ]. emplace ( arr [ i ]); } else if ( q [ 0 ]. empty ()) { ll top = q [ 1 ]. top (); if ( arr [ i ] > top ) { q [ 1 ]. pop (); ans += arr [ i ] - top ; q [ 0 ]. emplace ( top ); q [ 1 ]. emplace ( arr [ i ]); } else { q [ 0 ]. emplace ( arr [ i ]); } } else { ll top1 = q [ 0 ]. top (), top2 = q [ 1 ]. top (); if ( top1 < top2 ) { if ( arr [ i ] > top1 ) { q [ 0 ]. pop (); ans += arr [ i ] - top1 ; q [ 1 ]. emplace ( arr [ i ]); } else { q [ 0 ]. emplace ( arr [ i ]); } } else { if ( arr [ i ] > top2 ) { q [ 1 ]. pop (); ans += arr [ i ] - top2 ; q [ 0 ]. emplace ( top2 ); q [ 1 ]. emplace ( arr [ i ]); } else { q [ 0 ]. emplace ( arr [ i ]); } } } } printf ( \"%lld %d \\n \" , ans , q [ 1 ]. size () * 2 ); } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; } B. Congruence equation \u7559\u5751\u3002 C. Dream \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a p p \uff0c\u91cd\u5b9a\u4e49\u52a0\u6cd5\u548c\u4e58\u6cd5\uff0c\u4f7f\u5f97\uff1a (m + n)^p = m^p + n^p (m + n)^p = m^p + n^p \u601d\u8def\uff1a \u6709\u8d39\u9a6c\u5c0f\u5b9a\u7406\uff1a a^p \\equiv a \\pmod p a^p \\equiv a \\pmod p \u3002 \u90a3\u53ea\u9700\u8981\u91cd\u5b9a\u4e49\uff1a \\begin{eqnarray*} (m + n) &=& (m + n) \\pmod p \\\\ (m \\cdot n) &=& (m \\cdot n) \\pmod p \\end{eqnarray*} \\begin{eqnarray*} (m + n) &=& (m + n) \\pmod p \\\\ (m \\cdot n) &=& (m \\cdot n) \\pmod p \\end{eqnarray*} \u539f\u6839\u53ef\u4ee5\u4fdd\u8bc1\u4e24\u4e2a\u96c6\u5408\u76f8\u7b49\u3002 Code #include <bits/stdc++.h> using namespace std ; #define ll long long #define N 2010 int t , p ; int a [ N ][ N ], b [ N ][ N ]; inline void Run () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & p ); for ( int i = 0 ; i < p ; ++ i ) { for ( int j = 0 ; j < p ; ++ j ) { a [ i ][ j ] = ( i + j ) % p ; b [ i ][ j ] = ( i * j ) % p ; } } for ( int i = 0 ; i < p ; ++ i ) { for ( int j = 0 ; j < p ; ++ j ) { printf ( \"%d%c\" , a [ i ][ j ], \" \\n \" [ j == p - 1 ]); } } for ( int i = 0 ; i < p ; ++ i ) { for ( int j = 0 ; j < p ; ++ j ) { printf ( \"%d%c\" , b [ i ][ j ], \" \\n \" [ j == p - 1 ]); } } } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; } D. Find Integer \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a n n \u548c\u4e00\u4e2a a a \u3002 \u627e\u51fa\uff1a a^n + b^n = c^n a^n + b^n = c^n \u601d\u8def\uff1a \u6839\u636e\u8d39\u9a6c\u5927\u5b9a\u7406 n \\gt 2 n \\gt 2 \u65e0\u89e3\u3002 \u663e\u7136 n = 0 n = 0 \u65e0\u89e3\u3002 n = 1 n = 1 \uff0c\u76f4\u63a5\u51d1\u3002 n = 2 n = 2 \uff1a \u5982\u679c\u662f\u5947\u6570\uff0c\u6709 \\displaystyle a^2 + (\\frac{a \\cdot a}{2})^2 = (\\frac{(a \\cdot a) + 1}{2}) ^2 \\displaystyle a^2 + (\\frac{a \\cdot a}{2})^2 = (\\frac{(a \\cdot a) + 1}{2}) ^2 \u3002 \u5982\u679c\u662f\u5076\u6570\uff0c\u4e00\u76f4\u9664\u4e0b\u53bb\uff0c\u76f4\u5230\u662f\u5947\u6570\uff0c\u7136\u540e\u628a\u591a\u4f59\u7684\u5076\u6570\u52a0\u5230 b b \u548c c c \u4e0a\u53bb\u3002 \u6216\u8005\uff1a Code #include <bits/stdc++.h> using namespace std ; #define ll long long #define INF 0x3f3f3f3f #define N 40010 int t ; ll n , a , cnt ; ll arr [ N ][ 2 ]; inline void Run () { for ( int i = 3 ; i <= 40000 ; ++ i ) { cnt = 1 ; ll a = i ; while (( a & 1 ) == 0 && a > 4 ) { cnt <<= 1 ; a >>= 1 ; } if ( a == 4 ) { arr [ i ][ 0 ] = cnt * 3 , arr [ i ][ 1 ] = cnt * 4 ; } else { ll b = a * a / 2 ; ll c = b + 1 ; arr [ i ][ 0 ] = b * cnt ; arr [ i ][ 1 ] = c * cnt ; } } scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%lld%lld\" , & n , & a ); if ( n == 0 || n >= 3 ) { puts ( \"-1 -1\" ); continue ; } if ( n == 1 ) { printf ( \"1 %lld \\n \" , a + 1 ); continue ; } printf ( \"%lld %lld \\n \" , arr [ a ][ 0 ], arr [ a ][ 1 ]); } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; } E. GuGu Convolution \u7559\u5751\u3002 F. Neko and Inu \u7559\u5751\u3002 G. Neko's loop \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e3a n n \u7684\u6570\u5217\uff0c\u6bcf\u4e2a\u4f4d\u7f6e\u90fd\u6709\u81ea\u5df1\u7684\u6743\u503c\uff0c\u4f60\u6709 m m \u70b9\u80fd\u91cf\uff0c\u6bcf\u6b21\u53ef\u4ee5\u4ece i i \u8d70\u5230 (i+k) \\bmod n (i+k) \\bmod n \u70b9\uff0c\u53ef\u4ee5\u5728\u4efb\u610f\u65f6\u523b\u505c\u6b62\uff0c\u4e3a\u8fbe\u5230 s s \u70b9\u80fd\u91cf\uff0c\u9700\u8981\u8d77\u59cb\u80fd\u91cf\u4e3a\u591a\u5c11\u3002 \u601d\u8def\uff1a \u53ef\u4ee5\u901a\u8fc7 \\mathcal{O}(n) \\mathcal{O}(n) \u7684\u65f6\u95f4\u5904\u7406\u51fa\u5faa\u73af\u8282\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u5faa\u73af\u8282\uff0c\u6211\u4eec\u53ef\u4ee5\u8d70\u5b8c\u5faa\u73af\u8282\u6216\u8005\u4e0d\u8d70\u5b8c\u3002 \u5bf9\u4e8e\u4e0d\u8d70\u5b8c\u8fd9\u90e8\u5206\u7684\u6b65\u6570\u53ef\u80fd\u4e3a m \\bmod \\mbox{\u5faa\u73af\u8282\u957f\u5ea6} m \\bmod \\mbox{\u5faa\u73af\u8282\u957f\u5ea6} \uff0c\u4e5f\u53ef\u80fd\u4e3a m m \u6216\u8005\u5faa\u73af\u8282\u957f\u5ea6\u3002 \u95ee\u9898\u5c31\u8f6c\u6362\u4e3a\u957f\u5ea6\u4e0d\u8d85\u8fc7\u9650\u5236\u957f\u5ea6\u7684\u6700\u5927\u8fde\u7eed\u5b50\u5e8f\u5217\uff0c\u901a\u8fc7 dp + \u5355\u8c03\u961f\u5217\u6765\u89e3\u51b3\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int MOD = 1e9 + 7 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 10 ; int n , m , k ; ll s , ans , val [ maxn ]; vector < ll > vec ; bool vis [ maxn ]; ll sum [ maxn << 1 ]; ll que [ maxn << 1 ]; inline ll cal ( int count ) { int len = vec . size (); for ( int i = 0 ; i < len ; ++ i ) { que [ i ] = que [ i + len ] = vec [ i ]; } len <<= 1 ; list < ll > q ; int st = 0 ; int ed = 0 ; ll res = 0 ; for ( int i = 0 ; i < len ; ++ i ) { if ( i == 0 ) { sum [ i ] = que [ i ]; } else { sum [ i ] = sum [ i - 1 ] + que [ i ]; } } for ( int i = 0 ; i < len ; ++ i ) { while ( ! q . empty () && sum [ q . front ()] > sum [ i ]) { q . pop_front (); } q . push_front ( i ); while ( ! q . empty () && i - q . back () > count ) { q . pop_back (); } res = max ( res , sum [ i ] - sum [ q . back ()]); } return res ; } inline ll solve () { ll mod = m % vec . size (); ll circle = m / vec . size (); ll sum = 0 ; for ( auto it : vec ) { sum += it ; } ll max1 = cal ( mod ); ll max2 = cal ( vec . size ()); max1 += max ( 0l l , sum ) * circle ; max2 += max ( 0L L , sum ) * (( circle > 2 ) ? circle - 1 : 0 ); return max ( max1 , max2 ); } inline void RUN () { int t ; scanf ( \"%d\" , & t ); for ( int cas = 1 ; cas <= t ; ++ cas ) { memset ( vis , false , sizeof vis ); scanf ( \"%d %lld %d %d\" , & n , & s , & m , & k ); for ( int i = 0 ; i < n ; ++ i ) { scanf ( \"%lld\" , val + i ); } ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! vis [ i ]) { vec . clear (); vis [ i ] = true ; vec . push_back ( val [ i ]); for ( int j = ( i + k ) % n ; j != i && ! vis [ j ]; j = ( j + k ) % n ) { vis [ j ] = true ; vec . push_back ( val [ j ]); } ans = max ( ans , solve ()); } } if ( ans >= s ) ans = 0 ; else ans = s - ans ; printf ( \"Case #%d: %lld \\n \" , cas , ans ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE return 0 ; } H. Search for Answer \u7559\u5751\u3002 I. Tree and Permutation \u9898\u610f\uff1a \u4e00\u4e2a\u5e8f\u5217\u7684\u503c\u4e3a\u7b2c\u4e00\u4e2a\u70b9\u8d70\u5230\u540e\u9762 n-1 n-1 \u4e2a\u70b9\u7684\u8ddd\u79bb\u548c\uff0c\u6c42 n! n! \u4e2a\u5e8f\u5217\u7684\u548c\u3002 \u601d\u8def\uff1a \u5bf9\u4e8e\u6bcf\u6761\u8fb9\uff0c\u8fd9\u6761\u8fb9\u7684\u5de6\u53f3\u7aef\u70b9\u5747\u8981\u8d70\u5411\u5bf9\u65b9\u3002 \u90a3\u4e48\u5bf9\u4e8e\u6bcf\u6761\u8fb9\u7684\u7ecf\u8fc7\u7684\u6b21\u6570\u4e3a\u5de6\u53f3\u7aef\u70b9\u8282\u70b9\u6570\u7684\u4e58\u79ef\u3002\u4f46\u662f\u6bcf\u4e2a\u70b9\u90fd\u4f5c\u4e3a\u8d77\u70b9 (n-1)! (n-1)! \u6b21\uff0c\u6c42\u548c\u5373\u53ef\u5f97\u5230\u7b54\u6848\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int INF = 0x3f3f3f3f ; const ll INFLL = 0x3f3f3f3f3f3f3f3f ; const int MOD = ( int ) 1e9 + 7 ; const int maxn = ( int ) 1e5 + 10 ; struct Edge { int u , v ; ll w ; inline Edge () {} inline Edge ( int u , int v , ll w ) : u ( u ), v ( v ), w ( w ) {} }; int n ; ll ans ; int son [ maxn ]; vector < Edge > G [ maxn ]; inline void Init () { ans = 0 ; memset ( son , 0 , sizeof son ); for ( int i = 1 ; i <= n ; ++ i ) { G [ i ]. clear (); } } inline void DFS ( int u , int pre ) { son [ u ] = 1 ; for ( auto it : G [ u ]) { int v = it . v ; if ( v == pre ) continue ; DFS ( v , u ); son [ u ] += son [ v ]; ans = ( ans + ( ll ) son [ v ] * ( n - son [ v ]) % MOD * it . w ) % MOD ; } } inline void RUN () { while ( ~ scanf ( \"%d\" , & n )) { Init (); for ( int i = 1 ; i < n ; ++ i ) { int u , v ; ll w ; scanf ( \"%d %d %lld\" , & u , & v , & w ); G [ u ]. push_back ( Edge ( u , v , w )); G [ v ]. push_back ( Edge ( v , u , w )); } DFS ( 1 , -1 ); for ( int i = 1 ; i <= n - 1 ; ++ i ) { ans = ( ans * i ) % MOD ; } ans = ( ans * 2 ) % MOD ; printf ( \"%lld \\n \" , ans ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE return 0 ; } J. YJJ's Salesman \u9898\u610f\uff1a \u7ed9\u51fa\u82e5\u5e72\u4e2a\u70b9\uff0c\u8303\u56f4\u5c5e\u4e8e (0, 0) - (10^9, 10^9) (0, 0) - (10^9, 10^9) \u3002 \u4ece (0, 0) (0, 0) \u8d70\u5230 (10^9, 10^9) (10^9, 10^9) \uff0c\u53ea\u80fd\u5411\u4e0a\u8d70\uff0c\u5411\u53f3\u8d70\uff0c\u6216\u8005\u53f3\u4e0a\u89d2\u8d70\uff0c\u6709\u4e9b\u70b9\u6709\u6743\u503c\uff0c\u4e0d\u80fd\u56de\u5934\uff0c\u6c42\u6700\u540e\u83b7\u5f97\u7684\u6700\u5927\u6743\u503c\u3002 \u601d\u8def\uff1a \u6700\u5927\u4e0a\u5347\u5b50\u5e8f\u5217\u7684\u6743\u503c\u548c\uff0c\u5148\u6309 x x \u6392\u5e8f\uff0c\u518d\u5bf9 y y \u79bb\u6563\u5316\uff0c\u7ebf\u6bb5\u6811\u4f18\u5316\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 int t , n , m ; int tmp [ N ]; struct Data { int x , y , v ; inline void scan () { scanf ( \"%d%d%d\" , & x , & y , & v ); } inline bool operator < ( const Data & r ) const { return x < r . x || x == r . x && y < r . y ; } } arr [ N ]; inline void Init () { for ( int i = 1 ; i <= n ; ++ i ) tmp [ i ] = arr [ i ]. y ; sort ( tmp + 1 , tmp + 1 + n ); m = unique ( tmp + 1 , tmp + 1 + n ) - tmp - 1 ; } inline int Get ( int x ) { return lower_bound ( tmp + 1 , tmp + 1 + m , x ) - tmp ; } struct node { int l , r ; int Max ; inline node () {} inline node ( int l , int r , int Max ) : l ( l ), r ( r ), Max ( Max ) {} } tree [ N << 2 ]; inline void pushup ( int id ) { tree [ id ]. Max = max ( tree [ id << 1 ]. Max , tree [ id << 1 | 1 ]. Max ); } inline void build ( int id , int l , int r ) { tree [ id ] = node ( l , r , 0 ); if ( l == r ) return ; int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); } inline void update ( int id , int pos , int val ) { if ( tree [ id ]. l == tree [ id ]. r ) { tree [ id ]. Max = max ( tree [ id ]. Max , val ); return ; } int mid = ( tree [ id ]. l + tree [ id ]. r ) >> 1 ; if ( pos <= mid ) update ( id << 1 , pos , val ); else update ( id << 1 | 1 , pos , val ); pushup ( id ); } int ansMax ; inline void query ( int id , int l , int r ) { if ( l > r ) return ; if ( tree [ id ]. l >= l && tree [ id ]. r <= r ) { ansMax = max ( ansMax , tree [ id ]. Max ); return ; } int mid = ( tree [ id ]. l + tree [ id ]. r ) >> 1 ; if ( l <= mid ) query ( id << 1 , l , r ); if ( r > mid ) query ( id << 1 | 1 , l , r ); } inline void Run () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) arr [ i ]. scan (); sort ( arr + 1 , arr + 1 + n ); Init (); build ( 1 , 1 , n ); for ( int i = 1 ; i <= n ; ++ i ) arr [ i ]. y = Get ( arr [ i ]. y ); vector < int > v ; int ans = arr [ 1 ]. v ; v . push_back ( 1 ); for ( int i = 2 ; i <= n ; ++ i ) { if ( arr [ i ]. x != arr [ i - 1 ]. x ) { for ( auto it : v ) { update ( 1 , arr [ it ]. y , arr [ it ]. v ); } v . clear (); } ansMax = 0 ; query ( 1 , 1 , arr [ i ]. y - 1 ); ans = max ( ans , ansMax + arr [ i ]. v ); // printf(\"%d %d %d\\n\", i, ansMax, arr[i].v); arr [ i ]. v += ansMax ; v . push_back ( i ); } printf ( \"%d \\n \" , ans ); } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; }","title":"2018 \u4e2d\u56fd\u5927\u5b66\u751f\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b"},{"location":"online/2018-CCPC-Online/#a-buy-and-resell","text":"\u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u4ea4\u6613\u70b9\uff0c\u6bcf\u6b21\u80fd\u591f\u9009\u62e9\u4e70\u6216\u8005\u5356\uff0c\u6c42\u83b7\u5f97\u6700\u5927\u5229\u6da6\u3002 \u601d\u8def\uff1a \u7ef4\u62a4\u4e24\u4e2a\u4f18\u5148\u961f\u5217\uff0c\u4e00\u4e2a\u662f\u5356\uff0c\u4e00\u4e2a\u662f\u66ff\u6362\uff0c\u5f53\u4ef7\u683c\u5dee\u76f8\u540c\u65f6\uff0c\u4f18\u5148\u66ff\u6362\uff0c\u56e0\u4e3a\u6b21\u6570\u8981\u6700\u5c11\u3002 Code #include <bits/stdc++.h> using namespace std ; #define ll long long #define N 100010 int t , n ; ll arr [ N ]; priority_queue < ll , vector < ll > , greater < ll > > q [ 2 ]; inline void Run () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%lld\" , arr + i ); for ( int i = 0 ; i < 2 ; ++ i ) while ( ! q [ i ]. empty ()) q [ i ]. pop (); ll ans = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( q [ 0 ]. empty () && q [ 1 ]. empty ()) q [ 0 ]. emplace ( arr [ i ]); else if ( q [ 1 ]. empty ()) { ll top = q [ 0 ]. top (); if ( arr [ i ] > top ) { q [ 0 ]. pop (); ans += arr [ i ] - top ; q [ 1 ]. emplace ( arr [ i ]); } else q [ 0 ]. emplace ( arr [ i ]); } else if ( q [ 0 ]. empty ()) { ll top = q [ 1 ]. top (); if ( arr [ i ] > top ) { q [ 1 ]. pop (); ans += arr [ i ] - top ; q [ 0 ]. emplace ( top ); q [ 1 ]. emplace ( arr [ i ]); } else { q [ 0 ]. emplace ( arr [ i ]); } } else { ll top1 = q [ 0 ]. top (), top2 = q [ 1 ]. top (); if ( top1 < top2 ) { if ( arr [ i ] > top1 ) { q [ 0 ]. pop (); ans += arr [ i ] - top1 ; q [ 1 ]. emplace ( arr [ i ]); } else { q [ 0 ]. emplace ( arr [ i ]); } } else { if ( arr [ i ] > top2 ) { q [ 1 ]. pop (); ans += arr [ i ] - top2 ; q [ 0 ]. emplace ( top2 ); q [ 1 ]. emplace ( arr [ i ]); } else { q [ 0 ]. emplace ( arr [ i ]); } } } } printf ( \"%lld %d \\n \" , ans , q [ 1 ]. size () * 2 ); } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; }","title":"A. Buy and Resell"},{"location":"online/2018-CCPC-Online/#b-congruence-equation","text":"\u7559\u5751\u3002","title":"B. Congruence equation"},{"location":"online/2018-CCPC-Online/#c-dream","text":"\u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a p p \uff0c\u91cd\u5b9a\u4e49\u52a0\u6cd5\u548c\u4e58\u6cd5\uff0c\u4f7f\u5f97\uff1a (m + n)^p = m^p + n^p (m + n)^p = m^p + n^p \u601d\u8def\uff1a \u6709\u8d39\u9a6c\u5c0f\u5b9a\u7406\uff1a a^p \\equiv a \\pmod p a^p \\equiv a \\pmod p \u3002 \u90a3\u53ea\u9700\u8981\u91cd\u5b9a\u4e49\uff1a \\begin{eqnarray*} (m + n) &=& (m + n) \\pmod p \\\\ (m \\cdot n) &=& (m \\cdot n) \\pmod p \\end{eqnarray*} \\begin{eqnarray*} (m + n) &=& (m + n) \\pmod p \\\\ (m \\cdot n) &=& (m \\cdot n) \\pmod p \\end{eqnarray*} \u539f\u6839\u53ef\u4ee5\u4fdd\u8bc1\u4e24\u4e2a\u96c6\u5408\u76f8\u7b49\u3002 Code #include <bits/stdc++.h> using namespace std ; #define ll long long #define N 2010 int t , p ; int a [ N ][ N ], b [ N ][ N ]; inline void Run () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & p ); for ( int i = 0 ; i < p ; ++ i ) { for ( int j = 0 ; j < p ; ++ j ) { a [ i ][ j ] = ( i + j ) % p ; b [ i ][ j ] = ( i * j ) % p ; } } for ( int i = 0 ; i < p ; ++ i ) { for ( int j = 0 ; j < p ; ++ j ) { printf ( \"%d%c\" , a [ i ][ j ], \" \\n \" [ j == p - 1 ]); } } for ( int i = 0 ; i < p ; ++ i ) { for ( int j = 0 ; j < p ; ++ j ) { printf ( \"%d%c\" , b [ i ][ j ], \" \\n \" [ j == p - 1 ]); } } } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; }","title":"C. Dream"},{"location":"online/2018-CCPC-Online/#d-find-integer","text":"\u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a n n \u548c\u4e00\u4e2a a a \u3002 \u627e\u51fa\uff1a a^n + b^n = c^n a^n + b^n = c^n \u601d\u8def\uff1a \u6839\u636e\u8d39\u9a6c\u5927\u5b9a\u7406 n \\gt 2 n \\gt 2 \u65e0\u89e3\u3002 \u663e\u7136 n = 0 n = 0 \u65e0\u89e3\u3002 n = 1 n = 1 \uff0c\u76f4\u63a5\u51d1\u3002 n = 2 n = 2 \uff1a \u5982\u679c\u662f\u5947\u6570\uff0c\u6709 \\displaystyle a^2 + (\\frac{a \\cdot a}{2})^2 = (\\frac{(a \\cdot a) + 1}{2}) ^2 \\displaystyle a^2 + (\\frac{a \\cdot a}{2})^2 = (\\frac{(a \\cdot a) + 1}{2}) ^2 \u3002 \u5982\u679c\u662f\u5076\u6570\uff0c\u4e00\u76f4\u9664\u4e0b\u53bb\uff0c\u76f4\u5230\u662f\u5947\u6570\uff0c\u7136\u540e\u628a\u591a\u4f59\u7684\u5076\u6570\u52a0\u5230 b b \u548c c c \u4e0a\u53bb\u3002 \u6216\u8005\uff1a Code #include <bits/stdc++.h> using namespace std ; #define ll long long #define INF 0x3f3f3f3f #define N 40010 int t ; ll n , a , cnt ; ll arr [ N ][ 2 ]; inline void Run () { for ( int i = 3 ; i <= 40000 ; ++ i ) { cnt = 1 ; ll a = i ; while (( a & 1 ) == 0 && a > 4 ) { cnt <<= 1 ; a >>= 1 ; } if ( a == 4 ) { arr [ i ][ 0 ] = cnt * 3 , arr [ i ][ 1 ] = cnt * 4 ; } else { ll b = a * a / 2 ; ll c = b + 1 ; arr [ i ][ 0 ] = b * cnt ; arr [ i ][ 1 ] = c * cnt ; } } scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%lld%lld\" , & n , & a ); if ( n == 0 || n >= 3 ) { puts ( \"-1 -1\" ); continue ; } if ( n == 1 ) { printf ( \"1 %lld \\n \" , a + 1 ); continue ; } printf ( \"%lld %lld \\n \" , arr [ a ][ 0 ], arr [ a ][ 1 ]); } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; }","title":"D. Find Integer"},{"location":"online/2018-CCPC-Online/#e-gugu-convolution","text":"\u7559\u5751\u3002","title":"E. GuGu Convolution"},{"location":"online/2018-CCPC-Online/#f-neko-and-inu","text":"\u7559\u5751\u3002","title":"F. Neko and Inu"},{"location":"online/2018-CCPC-Online/#g-nekos-loop","text":"\u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e3a n n \u7684\u6570\u5217\uff0c\u6bcf\u4e2a\u4f4d\u7f6e\u90fd\u6709\u81ea\u5df1\u7684\u6743\u503c\uff0c\u4f60\u6709 m m \u70b9\u80fd\u91cf\uff0c\u6bcf\u6b21\u53ef\u4ee5\u4ece i i \u8d70\u5230 (i+k) \\bmod n (i+k) \\bmod n \u70b9\uff0c\u53ef\u4ee5\u5728\u4efb\u610f\u65f6\u523b\u505c\u6b62\uff0c\u4e3a\u8fbe\u5230 s s \u70b9\u80fd\u91cf\uff0c\u9700\u8981\u8d77\u59cb\u80fd\u91cf\u4e3a\u591a\u5c11\u3002 \u601d\u8def\uff1a \u53ef\u4ee5\u901a\u8fc7 \\mathcal{O}(n) \\mathcal{O}(n) \u7684\u65f6\u95f4\u5904\u7406\u51fa\u5faa\u73af\u8282\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u5faa\u73af\u8282\uff0c\u6211\u4eec\u53ef\u4ee5\u8d70\u5b8c\u5faa\u73af\u8282\u6216\u8005\u4e0d\u8d70\u5b8c\u3002 \u5bf9\u4e8e\u4e0d\u8d70\u5b8c\u8fd9\u90e8\u5206\u7684\u6b65\u6570\u53ef\u80fd\u4e3a m \\bmod \\mbox{\u5faa\u73af\u8282\u957f\u5ea6} m \\bmod \\mbox{\u5faa\u73af\u8282\u957f\u5ea6} \uff0c\u4e5f\u53ef\u80fd\u4e3a m m \u6216\u8005\u5faa\u73af\u8282\u957f\u5ea6\u3002 \u95ee\u9898\u5c31\u8f6c\u6362\u4e3a\u957f\u5ea6\u4e0d\u8d85\u8fc7\u9650\u5236\u957f\u5ea6\u7684\u6700\u5927\u8fde\u7eed\u5b50\u5e8f\u5217\uff0c\u901a\u8fc7 dp + \u5355\u8c03\u961f\u5217\u6765\u89e3\u51b3\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int MOD = 1e9 + 7 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 10 ; int n , m , k ; ll s , ans , val [ maxn ]; vector < ll > vec ; bool vis [ maxn ]; ll sum [ maxn << 1 ]; ll que [ maxn << 1 ]; inline ll cal ( int count ) { int len = vec . size (); for ( int i = 0 ; i < len ; ++ i ) { que [ i ] = que [ i + len ] = vec [ i ]; } len <<= 1 ; list < ll > q ; int st = 0 ; int ed = 0 ; ll res = 0 ; for ( int i = 0 ; i < len ; ++ i ) { if ( i == 0 ) { sum [ i ] = que [ i ]; } else { sum [ i ] = sum [ i - 1 ] + que [ i ]; } } for ( int i = 0 ; i < len ; ++ i ) { while ( ! q . empty () && sum [ q . front ()] > sum [ i ]) { q . pop_front (); } q . push_front ( i ); while ( ! q . empty () && i - q . back () > count ) { q . pop_back (); } res = max ( res , sum [ i ] - sum [ q . back ()]); } return res ; } inline ll solve () { ll mod = m % vec . size (); ll circle = m / vec . size (); ll sum = 0 ; for ( auto it : vec ) { sum += it ; } ll max1 = cal ( mod ); ll max2 = cal ( vec . size ()); max1 += max ( 0l l , sum ) * circle ; max2 += max ( 0L L , sum ) * (( circle > 2 ) ? circle - 1 : 0 ); return max ( max1 , max2 ); } inline void RUN () { int t ; scanf ( \"%d\" , & t ); for ( int cas = 1 ; cas <= t ; ++ cas ) { memset ( vis , false , sizeof vis ); scanf ( \"%d %lld %d %d\" , & n , & s , & m , & k ); for ( int i = 0 ; i < n ; ++ i ) { scanf ( \"%lld\" , val + i ); } ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! vis [ i ]) { vec . clear (); vis [ i ] = true ; vec . push_back ( val [ i ]); for ( int j = ( i + k ) % n ; j != i && ! vis [ j ]; j = ( j + k ) % n ) { vis [ j ] = true ; vec . push_back ( val [ j ]); } ans = max ( ans , solve ()); } } if ( ans >= s ) ans = 0 ; else ans = s - ans ; printf ( \"Case #%d: %lld \\n \" , cas , ans ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE return 0 ; }","title":"G. Neko's loop"},{"location":"online/2018-CCPC-Online/#h-search-for-answer","text":"\u7559\u5751\u3002","title":"H. Search for Answer"},{"location":"online/2018-CCPC-Online/#i-tree-and-permutation","text":"\u9898\u610f\uff1a \u4e00\u4e2a\u5e8f\u5217\u7684\u503c\u4e3a\u7b2c\u4e00\u4e2a\u70b9\u8d70\u5230\u540e\u9762 n-1 n-1 \u4e2a\u70b9\u7684\u8ddd\u79bb\u548c\uff0c\u6c42 n! n! \u4e2a\u5e8f\u5217\u7684\u548c\u3002 \u601d\u8def\uff1a \u5bf9\u4e8e\u6bcf\u6761\u8fb9\uff0c\u8fd9\u6761\u8fb9\u7684\u5de6\u53f3\u7aef\u70b9\u5747\u8981\u8d70\u5411\u5bf9\u65b9\u3002 \u90a3\u4e48\u5bf9\u4e8e\u6bcf\u6761\u8fb9\u7684\u7ecf\u8fc7\u7684\u6b21\u6570\u4e3a\u5de6\u53f3\u7aef\u70b9\u8282\u70b9\u6570\u7684\u4e58\u79ef\u3002\u4f46\u662f\u6bcf\u4e2a\u70b9\u90fd\u4f5c\u4e3a\u8d77\u70b9 (n-1)! (n-1)! \u6b21\uff0c\u6c42\u548c\u5373\u53ef\u5f97\u5230\u7b54\u6848\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int INF = 0x3f3f3f3f ; const ll INFLL = 0x3f3f3f3f3f3f3f3f ; const int MOD = ( int ) 1e9 + 7 ; const int maxn = ( int ) 1e5 + 10 ; struct Edge { int u , v ; ll w ; inline Edge () {} inline Edge ( int u , int v , ll w ) : u ( u ), v ( v ), w ( w ) {} }; int n ; ll ans ; int son [ maxn ]; vector < Edge > G [ maxn ]; inline void Init () { ans = 0 ; memset ( son , 0 , sizeof son ); for ( int i = 1 ; i <= n ; ++ i ) { G [ i ]. clear (); } } inline void DFS ( int u , int pre ) { son [ u ] = 1 ; for ( auto it : G [ u ]) { int v = it . v ; if ( v == pre ) continue ; DFS ( v , u ); son [ u ] += son [ v ]; ans = ( ans + ( ll ) son [ v ] * ( n - son [ v ]) % MOD * it . w ) % MOD ; } } inline void RUN () { while ( ~ scanf ( \"%d\" , & n )) { Init (); for ( int i = 1 ; i < n ; ++ i ) { int u , v ; ll w ; scanf ( \"%d %d %lld\" , & u , & v , & w ); G [ u ]. push_back ( Edge ( u , v , w )); G [ v ]. push_back ( Edge ( v , u , w )); } DFS ( 1 , -1 ); for ( int i = 1 ; i <= n - 1 ; ++ i ) { ans = ( ans * i ) % MOD ; } ans = ( ans * 2 ) % MOD ; printf ( \"%lld \\n \" , ans ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE return 0 ; }","title":"I. Tree and Permutation"},{"location":"online/2018-CCPC-Online/#j-yjjs-salesman","text":"\u9898\u610f\uff1a \u7ed9\u51fa\u82e5\u5e72\u4e2a\u70b9\uff0c\u8303\u56f4\u5c5e\u4e8e (0, 0) - (10^9, 10^9) (0, 0) - (10^9, 10^9) \u3002 \u4ece (0, 0) (0, 0) \u8d70\u5230 (10^9, 10^9) (10^9, 10^9) \uff0c\u53ea\u80fd\u5411\u4e0a\u8d70\uff0c\u5411\u53f3\u8d70\uff0c\u6216\u8005\u53f3\u4e0a\u89d2\u8d70\uff0c\u6709\u4e9b\u70b9\u6709\u6743\u503c\uff0c\u4e0d\u80fd\u56de\u5934\uff0c\u6c42\u6700\u540e\u83b7\u5f97\u7684\u6700\u5927\u6743\u503c\u3002 \u601d\u8def\uff1a \u6700\u5927\u4e0a\u5347\u5b50\u5e8f\u5217\u7684\u6743\u503c\u548c\uff0c\u5148\u6309 x x \u6392\u5e8f\uff0c\u518d\u5bf9 y y \u79bb\u6563\u5316\uff0c\u7ebf\u6bb5\u6811\u4f18\u5316\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 int t , n , m ; int tmp [ N ]; struct Data { int x , y , v ; inline void scan () { scanf ( \"%d%d%d\" , & x , & y , & v ); } inline bool operator < ( const Data & r ) const { return x < r . x || x == r . x && y < r . y ; } } arr [ N ]; inline void Init () { for ( int i = 1 ; i <= n ; ++ i ) tmp [ i ] = arr [ i ]. y ; sort ( tmp + 1 , tmp + 1 + n ); m = unique ( tmp + 1 , tmp + 1 + n ) - tmp - 1 ; } inline int Get ( int x ) { return lower_bound ( tmp + 1 , tmp + 1 + m , x ) - tmp ; } struct node { int l , r ; int Max ; inline node () {} inline node ( int l , int r , int Max ) : l ( l ), r ( r ), Max ( Max ) {} } tree [ N << 2 ]; inline void pushup ( int id ) { tree [ id ]. Max = max ( tree [ id << 1 ]. Max , tree [ id << 1 | 1 ]. Max ); } inline void build ( int id , int l , int r ) { tree [ id ] = node ( l , r , 0 ); if ( l == r ) return ; int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); } inline void update ( int id , int pos , int val ) { if ( tree [ id ]. l == tree [ id ]. r ) { tree [ id ]. Max = max ( tree [ id ]. Max , val ); return ; } int mid = ( tree [ id ]. l + tree [ id ]. r ) >> 1 ; if ( pos <= mid ) update ( id << 1 , pos , val ); else update ( id << 1 | 1 , pos , val ); pushup ( id ); } int ansMax ; inline void query ( int id , int l , int r ) { if ( l > r ) return ; if ( tree [ id ]. l >= l && tree [ id ]. r <= r ) { ansMax = max ( ansMax , tree [ id ]. Max ); return ; } int mid = ( tree [ id ]. l + tree [ id ]. r ) >> 1 ; if ( l <= mid ) query ( id << 1 , l , r ); if ( r > mid ) query ( id << 1 | 1 , l , r ); } inline void Run () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) arr [ i ]. scan (); sort ( arr + 1 , arr + 1 + n ); Init (); build ( 1 , 1 , n ); for ( int i = 1 ; i <= n ; ++ i ) arr [ i ]. y = Get ( arr [ i ]. y ); vector < int > v ; int ans = arr [ 1 ]. v ; v . push_back ( 1 ); for ( int i = 2 ; i <= n ; ++ i ) { if ( arr [ i ]. x != arr [ i - 1 ]. x ) { for ( auto it : v ) { update ( 1 , arr [ it ]. y , arr [ it ]. v ); } v . clear (); } ansMax = 0 ; query ( 1 , 1 , arr [ i ]. y - 1 ); ans = max ( ans , ansMax + arr [ i ]. v ); // printf(\"%d %d %d\\n\", i, ansMax, arr[i].v); arr [ i ]. v += ansMax ; v . push_back ( i ); } printf ( \"%d \\n \" , ans ); } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; }","title":"J. YJJ's Salesman"},{"location":"online/2018-ICPC-Nanjing-Online/","text":"ACM-ICPC 2018 \u5357\u4eac\u8d5b\u533a\u7f51\u7edc\u9884\u8d5b Contents A. An Olympian Math Problem B. The writing on the wall C. GDY D. Jerome's House E. AC Challenge F. An Easy Problem On The Trees G. Lpl and Energy-saving Lamps H. Set I. Skr J. Sum K. The Great Nim Game L. Magical Girl Haze A. An Olympian Math Problem cout << n - 1 << endl; Code #include <bits/stdc++.h> using namespace std ; #define ll long long int t ; ll n ; inline void Run () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%lld\" , & n ); printf ( \"%lld \\n \" , n - 1 ); } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; } B. The writing on the wall \u9898\u610f\uff1a \u7ed9\u51fa n \\cdot m n \\cdot m \u7684\u77e9\u5f62\uff0c\u627e\u51fa\u6709\u591a\u5c11\u4e2a\u5b50\u77e9\u5f62\u4e0d\u5305\u542b\u9ed1\u5757\u3002 \u601d\u8def\uff1a \u679a\u4e3e\u6bcf\u4e00\u4e2a\u5f53\u53f3\u4e0b\u89d2\u7684\u60c5\u51b5\uff0c\u90a3\u4e48\u60c5\u51b5\u603b\u6570\u5c31\u662f\u9ed1\u5757\u6784\u6210\u7684\u8fb9\u754c\u91cc\u9762\u7684\u683c\u5b50\u6570\u91cf\uff0c\u4f18\u5148\u961f\u5217\u4f18\u5316\u3002 Code #include <bits/stdc++.h> using namespace std ; #define ll long long #define N 100010 #define M 110 int t , n , m , k ; int G [ N ][ M ]; int low [ M ]; struct node { ll h , num ; inline node () {} inline node ( ll h , ll num ) : h ( h ), num ( num ) {} inline bool operator < ( const node & r ) const { return h < r . h ; } }; priority_queue < node > q ; int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE scanf ( \"%d\" , & t ); for ( int kase = 1 ; kase <= t ; ++ kase ) { printf ( \"Case #%d: \" , kase ); memset ( G , 0 , sizeof G ); memset ( low , 0 , sizeof low ); while ( ! q . empty ()) q . pop (); scanf ( \"%d%d%d\" , & n , & m , & k ); for ( int i = 1 , x , y ; i <= k ; ++ i ) { scanf ( \"%d%d\" , & x , & y ); G [ x ][ y ] = 1 ; } ll ans = 0 , sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { // if (i % 1000 == 0) cout << i << endl; if ( G [ i ][ j ] == 1 ) { while ( ! q . empty ()) q . pop (); sum = 0 ; low [ j ] = i ; continue ; } if ( j == 1 ) { while ( ! q . empty ()) q . pop (); sum = 0 ; } ll H = i - low [ j ]; ll num = 1 ; while ( ! q . empty () && q . top (). h > H ) { num += q . top (). num ; sum -= q . top (). h * q . top (). num ; q . pop (); } sum += num * H ; ans += sum ; q . emplace ( H , num ); } } printf ( \"%lld \\n \" , ans ); } return 0 ; } C. GDY \u6309\u9898\u610f\u6a21\u62df\u5373\u53ef\uff0c\u6ce8\u610f\u7ec6\u8282\u3002 Code #include <bits/stdc++.h> using namespace std ; int Move [] = { 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 1 , 2 , }; struct DT { int num [ 15 ], cnt ; int score ; inline DT () { score = 0 ; cnt = 0 ; memset ( num , 0 , sizeof num ); } inline void Get () { for ( int i = 1 ; i <= 13 ; ++ i ) score += num [ i ] * i ; } } arr [ 250 ]; int t , n , m ; queue < int > q ; inline void work () { int turn = 1 , pre = -1 , tot = 0 , nx ; for ( int i = 0 ; i < 13 ; ++ i ) if ( arr [ 1 ]. num [ Move [ i ]]) { pre = Move [ i ]; -- arr [ 1 ]. num [ Move [ i ]]; -- arr [ 1 ]. cnt ; break ; } while ( true ) { turn = turn % n + 1 ; if ( tot == n - 1 ) { for ( int i = turn ; i <= n ; ++ i ) if ( ! q . empty ()) { ++ arr [ i ]. cnt ; ++ arr [ i ]. num [ q . front ()]; q . pop (); } for ( int i = 1 ; i < turn ; ++ i ) if ( ! q . empty ()) { ++ arr [ i ]. cnt ; ++ arr [ i ]. num [ q . front ()]; q . pop (); } for ( int i = 0 ; i < 13 ; ++ i ) if ( arr [ turn ]. num [ Move [ i ]]) { -- arr [ turn ]. num [ Move [ i ]]; if ( -- arr [ turn ]. cnt == 0 ) return ; pre = Move [ i ]; tot = 0 ; break ; } } else if ( pre == 2 ) tot ++ ; else { if ( pre == 13 ) nx = 1 ; else nx = pre + 1 ; if ( arr [ turn ]. num [ nx ]) { -- arr [ turn ]. num [ nx ]; if ( -- arr [ turn ]. cnt == 0 ) return ; pre = nx ; tot = 0 ; } else { if ( arr [ turn ]. num [ 2 ]) { -- arr [ turn ]. num [ 2 ]; if ( -- arr [ turn ]. cnt == 0 ) return ; pre = 2 ; tot = 0 ; } else tot ++ ; } } } } inline void Run () { scanf ( \"%d\" , & t ); for ( int kase = 1 ; kase <= t ; ++ kase ) { while ( ! q . empty ()) q . pop (); printf ( \"Case #%d: \\n \" , kase ); scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 , u ; i <= m ; ++ i ) { scanf ( \"%d\" , & u ); q . emplace ( u ); } for ( int i = 1 ; i <= n ; ++ i ) { arr [ i ] = DT (); for ( int j = 1 ; j <= 5 ; ++ j ) { if ( ! q . empty ()) { arr [ i ]. num [ q . front ()] ++ ; q . pop (); ++ arr [ i ]. cnt ; } } } work (); for ( int i = 1 ; i <= n ; ++ i ) { arr [ i ]. Get (); if ( arr [ i ]. score == 0 ) puts ( \"Winner\" ); else printf ( \"%d \\n \" , arr [ i ]. score ); } } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; } D. Jerome's House \u7559\u5751\u3002 E. AC Challenge \u9898\u610f\uff1a \u6709 n n \u9053\u9898\u76ee\uff0c\u6bcf\u6b21\u63d0\u4ea4\u5f97\u5230\u5206\u6570 t \\cdot a_i + b_i t \\cdot a_i + b_i \u6709\u4e00\u4e9b\u9898\u76ee\u7684\u63d0\u4ea4\u5fc5\u987b\u8981\u67d0\u4e9b\u9898\u76ee\u63d0\u4ea4\u4e4b\u540e\u624d\u80fd\u63d0\u4ea4\uff0c\u6c42\u6700\u540e\u83b7\u5f97\u7684\u6700\u5927\u5206\u6570\u3002 \u601d\u8def\uff1a \u8bb0\u5fc6\u5316\u641c\u7d22\uff0c\u4e8c\u8fdb\u5236\u6807\u8bb0\u72b6\u6001\u3002 \u6216\u8005 \u72b6\u538b DP\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll dp [ 1 << 20 ]; int n ; struct node { ll ai , bi ; int state ; inline node () {} inline node ( ll ai , ll bi , int state ) : ai ( ai ), bi ( bi ), state ( state ) {} } arr [ 30 ]; inline ll DFS ( int t , int S ) { if ( t > n ) return 0 ; if ( dp [ S ] != -1 ) return dp [ S ]; ll res = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int tmp = 1 << i ; if (( tmp & S ) == 0 ) { if (( S & arr [ i ]. state ) != arr [ i ]. state ) continue ; res = max ( res , t * arr [ i ]. ai + arr [ i ]. bi + DFS ( t + 1 , ( S | tmp ))); } } dp [ S ] = res ; return res ; } inline void RUN () { while ( ~ scanf ( \"%d\" , & n )) { memset ( dp , -1 , sizeof dp ); for ( int i = 0 ; i < n ; ++ i ) { int m ; int S = 0 ; scanf ( \"%lld %lld %d\" , & arr [ i ]. ai , & arr [ i ]. bi , & m ); while ( m -- ) { int tmp = 0 ; scanf ( \"%d\" , & tmp ); S += ( 1 << ( tmp - 1 )); } arr [ i ]. state = S ; } ll ans = DFS ( 1 , 0 ); printf ( \"%lld \\n \" , ans ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE return 0 ; } Code #include <bits/stdc++.h> using namespace std ; #define N (1 << 21) #define ll long long struct node { ll a , b ; int sta ; inline void scan () { int tot , k ; sta = 0 ; scanf ( \"%lld%lld%d\" , & a , & b , & tot ); while ( tot -- ) { scanf ( \"%d\" , & k ); sta |= ( 1 << ( k - 1 )); } } } arr [ 25 ]; int n ; ll dp [ N ]; inline ll Count ( int x ) { int res = 0 ; while ( x ) { ++ res ; x &= ( x - 1 ); } return res ; } inline void Run () { while ( scanf ( \"%d\" , & n ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) arr [ i ]. scan (); memset ( dp , -1 , sizeof dp ); ll ans = 0 ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < ( 1 << n ); ++ i ) { if ( dp [ i ] == -1 ) continue ; for ( int j = 1 ; j <= n ; ++ j ) { if ( ! ( i & ( 1 << ( j - 1 ))) && ( i & ( arr [ j ]. sta )) == arr [ j ]. sta ) { int tmp = i | ( 1 << ( j - 1 )); ll t = Count ( tmp ); dp [ tmp ] = max ( dp [ tmp ], dp [ i ] + arr [ j ]. a * t + arr [ j ]. b ); ans = max ( ans , dp [ tmp ]); } } } printf ( \"%lld \\n \" , ans ); } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; } F. An Easy Problem On The Trees \u7559\u5751\u3002 G. Lpl and Energy-saving Lamps \u9898\u610f\uff1a \u6709 n n \u4e2a\u623f\u95f4\uff0c\u6bcf\u6b21\u6309\u987a\u5e8f\u6362\u706f\u6ce1\uff0c\u4e00\u4e2a\u623f\u95f4\u8981\u4e0d\u6240\u6709\u706f\u6ce1\u90fd\u6362\uff0c\u8981\u4e0d\u4e00\u4e2a\u90fd\u4e0d\u6362\uff0c\u6bcf\u4e2a\u6708\u6709\u56fa\u5b9a\u7684\u65b0\u706f\u6ce1\u6570\uff0c\u6ca1\u8fd8\u5b8c\u7559\u5230\u4e0b\u4e2a\u6708\uff0c\u8be2\u95ee\u7b2c\u51e0\u4e2a\u6708\u80fd\u591f\u6362\u6389\u51e0\u4e2a\u623f\u95f4\u4ee5\u53ca\u5269\u4e0b\u7684\u623f\u95f4\u6570\u3002 \u601d\u8def\uff1a \u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e00\u4e2a\u6700\u5c0f\u503c\uff0c\u9884\u5904\u7406\u7b54\u6848\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 #define INF 0x3f3f3f3f #define ll long long typedef pair < int , int > pii ; int n , m , q , sum ; int arr [ N ]; pii ans [ N ]; struct node { int l , r , cnt ; int Min , sum ; inline node () {} inline node ( int _l , int _r ) { l = _l , r = _r ; Min = sum = 0 ; } } tree [ N << 2 ]; inline void pushup ( int id ) { tree [ id ]. Min = min ( tree [ id << 1 ]. Min , tree [ id << 1 | 1 ]. Min ); tree [ id ]. sum = tree [ id << 1 ]. sum + tree [ id << 1 | 1 ]. sum ; tree [ id ]. cnt = tree [ id << 1 ]. cnt + tree [ id << 1 | 1 ]. cnt ; } inline void build ( int id , int l , int r ) { tree [ id ] = node ( l , r ); if ( l == r ) { tree [ id ]. Min = tree [ id ]. sum = arr [ l ]; tree [ id ]. cnt = 1 ; return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); pushup ( id ); } int anssum , remind ; inline void query ( int id ) { if ( tree [ id ]. Min <= remind && tree [ id ]. sum <= remind ) { anssum += tree [ id ]. cnt ; sum -= tree [ id ]. sum ; remind -= tree [ id ]. sum ; tree [ id ]. Min = INF ; tree [ id ]. sum = 0 ; tree [ id ]. cnt = 0 ; return ; } if ( tree [ id << 1 ]. Min <= remind ) query ( id << 1 ); if ( tree [ id << 1 | 1 ]. Min <= remind ) query ( id << 1 | 1 ); pushup ( id ); } inline void out ( int x ) { if ( x / 10 ) out ( x / 10 ); putchar ( x % 10 + '0' ); } inline void Run () { while ( scanf ( \"%d%d\" , & n , & m ) != EOF ) { memset ( ans , 0 , sizeof ans ); sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , arr + i ), sum += arr [ i ]; build ( 1 , 1 , n ); remind = m ; for ( int i = 1 ; i <= 100000 ; ++ i , remind += m ) { if ( sum == 0 ) { ans [ i ] = ans [ i - 1 ]; continue ; } anssum = 0 ; query ( 1 ); ans [ i ]. first = ans [ i - 1 ]. first + anssum ; ans [ i ]. second = remind ; } scanf ( \"%d\" , & q ); for ( int i = 1 , x ; i <= q ; ++ i ) { scanf ( \"%d\" , & x ); out ( ans [ x ]. first ); putchar ( ' ' ); out ( ans [ x ]. second ); putchar ( '\\n' ); } } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; } H. Set \u7559\u5751\u3002 I. Skr \u7559\u5751\u3002 J. Sum \u9898\u610f\uff1a \u5b9a\u4e49 F[n] = \\mbox{\u6709\u591a\u5c11\u4e2a}n = ab F[n] = \\mbox{\u6709\u591a\u5c11\u4e2a}n = ab a a \u548c b b \u90fd\u4e0d\u80fd\u662f\u5e73\u65b9\u6570\u7684\u500d\u6570\uff0c 1 1 \u9664\u5916\u3002 \u6c42\uff1a \\sum_{i = 1} ^ {i = n} F[n] \\sum_{i = 1} ^ {i = n} F[n] \u601d\u8def\uff1a \u679a\u4e3e\u6bcf\u4e2a\u7d20\u6570\uff0c\u5bf9\u4e8e\u62e5\u6709\u4e0d\u540c\u8d28\u56e0\u5b50\u7684\u6570\uff0c\u6743\u503c\u4e58 2 2 \u3002 \u5bf9\u4e8e\u62e5\u6709\u4e24\u4e2a\u76f8\u540c\u7684\u8d28\u56e0\u5b50\u7684\u6570\uff0c\u6743\u503c\u9664\u4ee5 2 2 \u3002 \u5bf9\u4e8e\u62e5\u6709\u4e09\u4e2a\u6216\u8005\u4e09\u4e2a\u4ee5\u4e0a\u8d28\u56e0\u5b50\u7684\u6570\uff0c\u6743\u503c\u4e3a 0 0 \uff0c\u6700\u540e\u6c42\u548c\u3002 \uff08\u5361\u5e38\uff09 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int maxn = 2e7 + 5 ; int n ; int tot ; int isprime [ maxn ]; int prime [ maxn ]; int a [ maxn ]; int ans [ maxn ]; inline void Init_prime () { tot = 1 ; prime [ 1 ] = 1 ; a [ 1 ] = 1 ; ans [ 1 ] = 1 ; for ( register int i = 2 ; i < maxn ; ++ i ) { a [ i ] = 1 ; if ( ! isprime [ i ]) { prime [ tot ++ ] = i ; } for ( register int j = 1 ; j < tot && i * prime [ j ] < maxn ; ++ j ) { isprime [ i * prime [ j ]] = 1 ; if ( ! ( i % prime [ j ])) { break ; } } } for ( register int i = 1 ; i < tot ; ++ i ) { for ( register int j = 1 ; j * prime [ i ] < maxn ; ++ j ) { a [ j * prime [ i ]] <<= 1 ; } if ( prime [ i ] > maxn / prime [ i ]) continue ; for ( register int j = 1 ; j * prime [ i ] * prime [ i ] < maxn ; ++ j ) { if ( j % prime [ i ] == 0 ) { a [ j * prime [ i ] * prime [ i ]] = 0 ; } a [ j * prime [ i ] * prime [ i ]] >>= 1 ; } } for ( register int i = 1 ; i < maxn ; ++ i ) { ans [ i ] = ans [ i - 1 ] + a [ i ]; } } int main () { Init_prime (); int t ; // cout << tot << endl; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); printf ( \"%d \\n \" , ans [ n ]); } return 0 ; } K. The Great Nim Game \u7559\u5751\u3002 L. Magical Girl Haze \u9898\u610f\uff1a \u6709 n n \u4e2a\u57ce\u5e02\uff0c m m \u6761\u8fb9\uff0c\u53ef\u4ee5\u4ee4 k k \u6761\u8def\u6743\u503c\u4e3a 0 0 \uff0c\u6c42 1 \\rightarrow n 1 \\rightarrow n \u7684\u6700\u77ed\u8def\u3002 \u601d\u8def\uff1a \u5bf9\u4e8e\u6bcf\u4e2a\u57ce\u5e02\uff0c\u679a\u4e3e\u5230\u8fd9\u4e2a\u57ce\u5e02\uff0c\u514d\u8d39 0-k 0-k \u6b21\u7684\u6743\u503c\uff0c\u8dd1\u4e00\u4e2a\uff08\u7acb\u4f53\u7684\uff1f\uff09\u6700\u77ed\u8def\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 #define ll long long #define INFLL 0x3f3f3f3f3f3f3f3f struct Edge { int to , nx ; ll w ; inline Edge () {} inline Edge ( int to , int nx , ll w ) : to ( to ), nx ( nx ), w ( w ) {} } edge [ N << 1 ]; int head [ N ], pos ; inline void Init () { memset ( head , -1 , sizeof head ); pos = 0 ; } inline void addedge ( int u , int v , ll w ) { edge [ ++ pos ] = Edge ( v , head [ u ], w ); head [ u ] = pos ; } struct node { int to , p ; ll w ; inline node () {} inline node ( int to , int p , ll w ) : to ( to ), p ( p ), w ( w ) {} inline bool operator < ( const node & r ) const { return w > r . w ; } }; ll dist [ N ][ 20 ]; bool used [ N ][ 20 ]; int t , n , m , k ; inline void Dijkstra () { for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 0 ; j <= k ; ++ j ) dist [ i ][ j ] = INFLL , used [ i ][ j ] = false ; priority_queue < node > q ; q . emplace ( 1 , 0 , 0 ); dist [ 1 ][ 0 ] = 0 ; while ( ! q . empty ()) { int u = q . top (). to ; int p = q . top (). p ; ll w = q . top (). w ; // cout << w << endl; q . pop (); if ( used [ u ][ p ]) continue ; used [ u ][ p ] = true ; dist [ u ][ p ] = w ; for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nx ) { int v = edge [ i ]. to ; ll c = edge [ i ]. w ; if ( dist [ u ][ p ] + c < dist [ v ][ p ]) { dist [ v ][ p ] = dist [ u ][ p ] + c ; q . emplace ( v , p , dist [ v ][ p ]); } if ( p + 1 <= k && dist [ u ][ p ] < dist [ v ][ p + 1 ]) { dist [ v ][ p + 1 ] = dist [ u ][ p ]; q . emplace ( v , p + 1 , dist [ v ][ p + 1 ]); } } } } inline void Run () { scanf ( \"%d\" , & t ); while ( t -- ) { Init (); scanf ( \"%d%d%d\" , & n , & m , & k ); int u , v ; ll w ; for ( int i = 1 ; i <= m ; ++ i ) { scanf ( \"%d%d%lld\" , & u , & v , & w ); addedge ( u , v , w ); } Dijkstra (); ll ans = dist [ n ][ k ]; printf ( \"%lld \\n \" , ans ); } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; }","title":"ACM-ICPC 2018 \u5357\u4eac\u8d5b\u533a\u7f51\u7edc\u9884\u8d5b"},{"location":"online/2018-ICPC-Nanjing-Online/#a-an-olympian-math-problem","text":"cout << n - 1 << endl; Code #include <bits/stdc++.h> using namespace std ; #define ll long long int t ; ll n ; inline void Run () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%lld\" , & n ); printf ( \"%lld \\n \" , n - 1 ); } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; }","title":"A. An Olympian Math Problem"},{"location":"online/2018-ICPC-Nanjing-Online/#b-the-writing-on-the-wall","text":"\u9898\u610f\uff1a \u7ed9\u51fa n \\cdot m n \\cdot m \u7684\u77e9\u5f62\uff0c\u627e\u51fa\u6709\u591a\u5c11\u4e2a\u5b50\u77e9\u5f62\u4e0d\u5305\u542b\u9ed1\u5757\u3002 \u601d\u8def\uff1a \u679a\u4e3e\u6bcf\u4e00\u4e2a\u5f53\u53f3\u4e0b\u89d2\u7684\u60c5\u51b5\uff0c\u90a3\u4e48\u60c5\u51b5\u603b\u6570\u5c31\u662f\u9ed1\u5757\u6784\u6210\u7684\u8fb9\u754c\u91cc\u9762\u7684\u683c\u5b50\u6570\u91cf\uff0c\u4f18\u5148\u961f\u5217\u4f18\u5316\u3002 Code #include <bits/stdc++.h> using namespace std ; #define ll long long #define N 100010 #define M 110 int t , n , m , k ; int G [ N ][ M ]; int low [ M ]; struct node { ll h , num ; inline node () {} inline node ( ll h , ll num ) : h ( h ), num ( num ) {} inline bool operator < ( const node & r ) const { return h < r . h ; } }; priority_queue < node > q ; int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE scanf ( \"%d\" , & t ); for ( int kase = 1 ; kase <= t ; ++ kase ) { printf ( \"Case #%d: \" , kase ); memset ( G , 0 , sizeof G ); memset ( low , 0 , sizeof low ); while ( ! q . empty ()) q . pop (); scanf ( \"%d%d%d\" , & n , & m , & k ); for ( int i = 1 , x , y ; i <= k ; ++ i ) { scanf ( \"%d%d\" , & x , & y ); G [ x ][ y ] = 1 ; } ll ans = 0 , sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { // if (i % 1000 == 0) cout << i << endl; if ( G [ i ][ j ] == 1 ) { while ( ! q . empty ()) q . pop (); sum = 0 ; low [ j ] = i ; continue ; } if ( j == 1 ) { while ( ! q . empty ()) q . pop (); sum = 0 ; } ll H = i - low [ j ]; ll num = 1 ; while ( ! q . empty () && q . top (). h > H ) { num += q . top (). num ; sum -= q . top (). h * q . top (). num ; q . pop (); } sum += num * H ; ans += sum ; q . emplace ( H , num ); } } printf ( \"%lld \\n \" , ans ); } return 0 ; }","title":"B. The writing on the wall"},{"location":"online/2018-ICPC-Nanjing-Online/#c-gdy","text":"\u6309\u9898\u610f\u6a21\u62df\u5373\u53ef\uff0c\u6ce8\u610f\u7ec6\u8282\u3002 Code #include <bits/stdc++.h> using namespace std ; int Move [] = { 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 1 , 2 , }; struct DT { int num [ 15 ], cnt ; int score ; inline DT () { score = 0 ; cnt = 0 ; memset ( num , 0 , sizeof num ); } inline void Get () { for ( int i = 1 ; i <= 13 ; ++ i ) score += num [ i ] * i ; } } arr [ 250 ]; int t , n , m ; queue < int > q ; inline void work () { int turn = 1 , pre = -1 , tot = 0 , nx ; for ( int i = 0 ; i < 13 ; ++ i ) if ( arr [ 1 ]. num [ Move [ i ]]) { pre = Move [ i ]; -- arr [ 1 ]. num [ Move [ i ]]; -- arr [ 1 ]. cnt ; break ; } while ( true ) { turn = turn % n + 1 ; if ( tot == n - 1 ) { for ( int i = turn ; i <= n ; ++ i ) if ( ! q . empty ()) { ++ arr [ i ]. cnt ; ++ arr [ i ]. num [ q . front ()]; q . pop (); } for ( int i = 1 ; i < turn ; ++ i ) if ( ! q . empty ()) { ++ arr [ i ]. cnt ; ++ arr [ i ]. num [ q . front ()]; q . pop (); } for ( int i = 0 ; i < 13 ; ++ i ) if ( arr [ turn ]. num [ Move [ i ]]) { -- arr [ turn ]. num [ Move [ i ]]; if ( -- arr [ turn ]. cnt == 0 ) return ; pre = Move [ i ]; tot = 0 ; break ; } } else if ( pre == 2 ) tot ++ ; else { if ( pre == 13 ) nx = 1 ; else nx = pre + 1 ; if ( arr [ turn ]. num [ nx ]) { -- arr [ turn ]. num [ nx ]; if ( -- arr [ turn ]. cnt == 0 ) return ; pre = nx ; tot = 0 ; } else { if ( arr [ turn ]. num [ 2 ]) { -- arr [ turn ]. num [ 2 ]; if ( -- arr [ turn ]. cnt == 0 ) return ; pre = 2 ; tot = 0 ; } else tot ++ ; } } } } inline void Run () { scanf ( \"%d\" , & t ); for ( int kase = 1 ; kase <= t ; ++ kase ) { while ( ! q . empty ()) q . pop (); printf ( \"Case #%d: \\n \" , kase ); scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 , u ; i <= m ; ++ i ) { scanf ( \"%d\" , & u ); q . emplace ( u ); } for ( int i = 1 ; i <= n ; ++ i ) { arr [ i ] = DT (); for ( int j = 1 ; j <= 5 ; ++ j ) { if ( ! q . empty ()) { arr [ i ]. num [ q . front ()] ++ ; q . pop (); ++ arr [ i ]. cnt ; } } } work (); for ( int i = 1 ; i <= n ; ++ i ) { arr [ i ]. Get (); if ( arr [ i ]. score == 0 ) puts ( \"Winner\" ); else printf ( \"%d \\n \" , arr [ i ]. score ); } } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; }","title":"C. GDY"},{"location":"online/2018-ICPC-Nanjing-Online/#d-jeromes-house","text":"\u7559\u5751\u3002","title":"D. Jerome's House"},{"location":"online/2018-ICPC-Nanjing-Online/#e-ac-challenge","text":"\u9898\u610f\uff1a \u6709 n n \u9053\u9898\u76ee\uff0c\u6bcf\u6b21\u63d0\u4ea4\u5f97\u5230\u5206\u6570 t \\cdot a_i + b_i t \\cdot a_i + b_i \u6709\u4e00\u4e9b\u9898\u76ee\u7684\u63d0\u4ea4\u5fc5\u987b\u8981\u67d0\u4e9b\u9898\u76ee\u63d0\u4ea4\u4e4b\u540e\u624d\u80fd\u63d0\u4ea4\uff0c\u6c42\u6700\u540e\u83b7\u5f97\u7684\u6700\u5927\u5206\u6570\u3002 \u601d\u8def\uff1a \u8bb0\u5fc6\u5316\u641c\u7d22\uff0c\u4e8c\u8fdb\u5236\u6807\u8bb0\u72b6\u6001\u3002 \u6216\u8005 \u72b6\u538b DP\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll dp [ 1 << 20 ]; int n ; struct node { ll ai , bi ; int state ; inline node () {} inline node ( ll ai , ll bi , int state ) : ai ( ai ), bi ( bi ), state ( state ) {} } arr [ 30 ]; inline ll DFS ( int t , int S ) { if ( t > n ) return 0 ; if ( dp [ S ] != -1 ) return dp [ S ]; ll res = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int tmp = 1 << i ; if (( tmp & S ) == 0 ) { if (( S & arr [ i ]. state ) != arr [ i ]. state ) continue ; res = max ( res , t * arr [ i ]. ai + arr [ i ]. bi + DFS ( t + 1 , ( S | tmp ))); } } dp [ S ] = res ; return res ; } inline void RUN () { while ( ~ scanf ( \"%d\" , & n )) { memset ( dp , -1 , sizeof dp ); for ( int i = 0 ; i < n ; ++ i ) { int m ; int S = 0 ; scanf ( \"%lld %lld %d\" , & arr [ i ]. ai , & arr [ i ]. bi , & m ); while ( m -- ) { int tmp = 0 ; scanf ( \"%d\" , & tmp ); S += ( 1 << ( tmp - 1 )); } arr [ i ]. state = S ; } ll ans = DFS ( 1 , 0 ); printf ( \"%lld \\n \" , ans ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE return 0 ; } Code #include <bits/stdc++.h> using namespace std ; #define N (1 << 21) #define ll long long struct node { ll a , b ; int sta ; inline void scan () { int tot , k ; sta = 0 ; scanf ( \"%lld%lld%d\" , & a , & b , & tot ); while ( tot -- ) { scanf ( \"%d\" , & k ); sta |= ( 1 << ( k - 1 )); } } } arr [ 25 ]; int n ; ll dp [ N ]; inline ll Count ( int x ) { int res = 0 ; while ( x ) { ++ res ; x &= ( x - 1 ); } return res ; } inline void Run () { while ( scanf ( \"%d\" , & n ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) arr [ i ]. scan (); memset ( dp , -1 , sizeof dp ); ll ans = 0 ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < ( 1 << n ); ++ i ) { if ( dp [ i ] == -1 ) continue ; for ( int j = 1 ; j <= n ; ++ j ) { if ( ! ( i & ( 1 << ( j - 1 ))) && ( i & ( arr [ j ]. sta )) == arr [ j ]. sta ) { int tmp = i | ( 1 << ( j - 1 )); ll t = Count ( tmp ); dp [ tmp ] = max ( dp [ tmp ], dp [ i ] + arr [ j ]. a * t + arr [ j ]. b ); ans = max ( ans , dp [ tmp ]); } } } printf ( \"%lld \\n \" , ans ); } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; }","title":"E. AC Challenge"},{"location":"online/2018-ICPC-Nanjing-Online/#f-an-easy-problem-on-the-trees","text":"\u7559\u5751\u3002","title":"F. An Easy Problem On The Trees"},{"location":"online/2018-ICPC-Nanjing-Online/#g-lpl-and-energy-saving-lamps","text":"\u9898\u610f\uff1a \u6709 n n \u4e2a\u623f\u95f4\uff0c\u6bcf\u6b21\u6309\u987a\u5e8f\u6362\u706f\u6ce1\uff0c\u4e00\u4e2a\u623f\u95f4\u8981\u4e0d\u6240\u6709\u706f\u6ce1\u90fd\u6362\uff0c\u8981\u4e0d\u4e00\u4e2a\u90fd\u4e0d\u6362\uff0c\u6bcf\u4e2a\u6708\u6709\u56fa\u5b9a\u7684\u65b0\u706f\u6ce1\u6570\uff0c\u6ca1\u8fd8\u5b8c\u7559\u5230\u4e0b\u4e2a\u6708\uff0c\u8be2\u95ee\u7b2c\u51e0\u4e2a\u6708\u80fd\u591f\u6362\u6389\u51e0\u4e2a\u623f\u95f4\u4ee5\u53ca\u5269\u4e0b\u7684\u623f\u95f4\u6570\u3002 \u601d\u8def\uff1a \u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e00\u4e2a\u6700\u5c0f\u503c\uff0c\u9884\u5904\u7406\u7b54\u6848\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 #define INF 0x3f3f3f3f #define ll long long typedef pair < int , int > pii ; int n , m , q , sum ; int arr [ N ]; pii ans [ N ]; struct node { int l , r , cnt ; int Min , sum ; inline node () {} inline node ( int _l , int _r ) { l = _l , r = _r ; Min = sum = 0 ; } } tree [ N << 2 ]; inline void pushup ( int id ) { tree [ id ]. Min = min ( tree [ id << 1 ]. Min , tree [ id << 1 | 1 ]. Min ); tree [ id ]. sum = tree [ id << 1 ]. sum + tree [ id << 1 | 1 ]. sum ; tree [ id ]. cnt = tree [ id << 1 ]. cnt + tree [ id << 1 | 1 ]. cnt ; } inline void build ( int id , int l , int r ) { tree [ id ] = node ( l , r ); if ( l == r ) { tree [ id ]. Min = tree [ id ]. sum = arr [ l ]; tree [ id ]. cnt = 1 ; return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); pushup ( id ); } int anssum , remind ; inline void query ( int id ) { if ( tree [ id ]. Min <= remind && tree [ id ]. sum <= remind ) { anssum += tree [ id ]. cnt ; sum -= tree [ id ]. sum ; remind -= tree [ id ]. sum ; tree [ id ]. Min = INF ; tree [ id ]. sum = 0 ; tree [ id ]. cnt = 0 ; return ; } if ( tree [ id << 1 ]. Min <= remind ) query ( id << 1 ); if ( tree [ id << 1 | 1 ]. Min <= remind ) query ( id << 1 | 1 ); pushup ( id ); } inline void out ( int x ) { if ( x / 10 ) out ( x / 10 ); putchar ( x % 10 + '0' ); } inline void Run () { while ( scanf ( \"%d%d\" , & n , & m ) != EOF ) { memset ( ans , 0 , sizeof ans ); sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , arr + i ), sum += arr [ i ]; build ( 1 , 1 , n ); remind = m ; for ( int i = 1 ; i <= 100000 ; ++ i , remind += m ) { if ( sum == 0 ) { ans [ i ] = ans [ i - 1 ]; continue ; } anssum = 0 ; query ( 1 ); ans [ i ]. first = ans [ i - 1 ]. first + anssum ; ans [ i ]. second = remind ; } scanf ( \"%d\" , & q ); for ( int i = 1 , x ; i <= q ; ++ i ) { scanf ( \"%d\" , & x ); out ( ans [ x ]. first ); putchar ( ' ' ); out ( ans [ x ]. second ); putchar ( '\\n' ); } } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; }","title":"G. Lpl and Energy-saving Lamps"},{"location":"online/2018-ICPC-Nanjing-Online/#h-set","text":"\u7559\u5751\u3002","title":"H. Set"},{"location":"online/2018-ICPC-Nanjing-Online/#i-skr","text":"\u7559\u5751\u3002","title":"I. Skr"},{"location":"online/2018-ICPC-Nanjing-Online/#j-sum","text":"\u9898\u610f\uff1a \u5b9a\u4e49 F[n] = \\mbox{\u6709\u591a\u5c11\u4e2a}n = ab F[n] = \\mbox{\u6709\u591a\u5c11\u4e2a}n = ab a a \u548c b b \u90fd\u4e0d\u80fd\u662f\u5e73\u65b9\u6570\u7684\u500d\u6570\uff0c 1 1 \u9664\u5916\u3002 \u6c42\uff1a \\sum_{i = 1} ^ {i = n} F[n] \\sum_{i = 1} ^ {i = n} F[n] \u601d\u8def\uff1a \u679a\u4e3e\u6bcf\u4e2a\u7d20\u6570\uff0c\u5bf9\u4e8e\u62e5\u6709\u4e0d\u540c\u8d28\u56e0\u5b50\u7684\u6570\uff0c\u6743\u503c\u4e58 2 2 \u3002 \u5bf9\u4e8e\u62e5\u6709\u4e24\u4e2a\u76f8\u540c\u7684\u8d28\u56e0\u5b50\u7684\u6570\uff0c\u6743\u503c\u9664\u4ee5 2 2 \u3002 \u5bf9\u4e8e\u62e5\u6709\u4e09\u4e2a\u6216\u8005\u4e09\u4e2a\u4ee5\u4e0a\u8d28\u56e0\u5b50\u7684\u6570\uff0c\u6743\u503c\u4e3a 0 0 \uff0c\u6700\u540e\u6c42\u548c\u3002 \uff08\u5361\u5e38\uff09 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int maxn = 2e7 + 5 ; int n ; int tot ; int isprime [ maxn ]; int prime [ maxn ]; int a [ maxn ]; int ans [ maxn ]; inline void Init_prime () { tot = 1 ; prime [ 1 ] = 1 ; a [ 1 ] = 1 ; ans [ 1 ] = 1 ; for ( register int i = 2 ; i < maxn ; ++ i ) { a [ i ] = 1 ; if ( ! isprime [ i ]) { prime [ tot ++ ] = i ; } for ( register int j = 1 ; j < tot && i * prime [ j ] < maxn ; ++ j ) { isprime [ i * prime [ j ]] = 1 ; if ( ! ( i % prime [ j ])) { break ; } } } for ( register int i = 1 ; i < tot ; ++ i ) { for ( register int j = 1 ; j * prime [ i ] < maxn ; ++ j ) { a [ j * prime [ i ]] <<= 1 ; } if ( prime [ i ] > maxn / prime [ i ]) continue ; for ( register int j = 1 ; j * prime [ i ] * prime [ i ] < maxn ; ++ j ) { if ( j % prime [ i ] == 0 ) { a [ j * prime [ i ] * prime [ i ]] = 0 ; } a [ j * prime [ i ] * prime [ i ]] >>= 1 ; } } for ( register int i = 1 ; i < maxn ; ++ i ) { ans [ i ] = ans [ i - 1 ] + a [ i ]; } } int main () { Init_prime (); int t ; // cout << tot << endl; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); printf ( \"%d \\n \" , ans [ n ]); } return 0 ; }","title":"J. Sum"},{"location":"online/2018-ICPC-Nanjing-Online/#k-the-great-nim-game","text":"\u7559\u5751\u3002","title":"K. The Great Nim Game"},{"location":"online/2018-ICPC-Nanjing-Online/#l-magical-girl-haze","text":"\u9898\u610f\uff1a \u6709 n n \u4e2a\u57ce\u5e02\uff0c m m \u6761\u8fb9\uff0c\u53ef\u4ee5\u4ee4 k k \u6761\u8def\u6743\u503c\u4e3a 0 0 \uff0c\u6c42 1 \\rightarrow n 1 \\rightarrow n \u7684\u6700\u77ed\u8def\u3002 \u601d\u8def\uff1a \u5bf9\u4e8e\u6bcf\u4e2a\u57ce\u5e02\uff0c\u679a\u4e3e\u5230\u8fd9\u4e2a\u57ce\u5e02\uff0c\u514d\u8d39 0-k 0-k \u6b21\u7684\u6743\u503c\uff0c\u8dd1\u4e00\u4e2a\uff08\u7acb\u4f53\u7684\uff1f\uff09\u6700\u77ed\u8def\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 #define ll long long #define INFLL 0x3f3f3f3f3f3f3f3f struct Edge { int to , nx ; ll w ; inline Edge () {} inline Edge ( int to , int nx , ll w ) : to ( to ), nx ( nx ), w ( w ) {} } edge [ N << 1 ]; int head [ N ], pos ; inline void Init () { memset ( head , -1 , sizeof head ); pos = 0 ; } inline void addedge ( int u , int v , ll w ) { edge [ ++ pos ] = Edge ( v , head [ u ], w ); head [ u ] = pos ; } struct node { int to , p ; ll w ; inline node () {} inline node ( int to , int p , ll w ) : to ( to ), p ( p ), w ( w ) {} inline bool operator < ( const node & r ) const { return w > r . w ; } }; ll dist [ N ][ 20 ]; bool used [ N ][ 20 ]; int t , n , m , k ; inline void Dijkstra () { for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 0 ; j <= k ; ++ j ) dist [ i ][ j ] = INFLL , used [ i ][ j ] = false ; priority_queue < node > q ; q . emplace ( 1 , 0 , 0 ); dist [ 1 ][ 0 ] = 0 ; while ( ! q . empty ()) { int u = q . top (). to ; int p = q . top (). p ; ll w = q . top (). w ; // cout << w << endl; q . pop (); if ( used [ u ][ p ]) continue ; used [ u ][ p ] = true ; dist [ u ][ p ] = w ; for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nx ) { int v = edge [ i ]. to ; ll c = edge [ i ]. w ; if ( dist [ u ][ p ] + c < dist [ v ][ p ]) { dist [ v ][ p ] = dist [ u ][ p ] + c ; q . emplace ( v , p , dist [ v ][ p ]); } if ( p + 1 <= k && dist [ u ][ p ] < dist [ v ][ p + 1 ]) { dist [ v ][ p + 1 ] = dist [ u ][ p ]; q . emplace ( v , p + 1 , dist [ v ][ p + 1 ]); } } } } inline void Run () { scanf ( \"%d\" , & t ); while ( t -- ) { Init (); scanf ( \"%d%d%d\" , & n , & m , & k ); int u , v ; ll w ; for ( int i = 1 ; i <= m ; ++ i ) { scanf ( \"%d%d%lld\" , & u , & v , & w ); addedge ( u , v , w ); } Dijkstra (); ll ans = dist [ n ][ k ]; printf ( \"%lld \\n \" , ans ); } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; }","title":"L. Magical Girl Haze"},{"location":"online/2018-ICPC-Shenyang-Online/","text":"ACM-ICPC 2018 \u6c88\u9633\u8d5b\u533a\u7f51\u7edc\u9884\u8d5b Contents A. Gudako and Ritsuka B. Call of Accepted C. Convex Hull D. Made In Heaven E. The cake is a lie F. Fantastic Graph G. Spare Tire H. Hamming Weight I. Lattice's basics in digital electronics J. Ka Chang K. Supreme Number A. Gudako and Ritsuka \u7559\u5751\u3002 B. Call of Accepted \u9898\u610f\uff1a \u5b9a\u4e49\u4e86\u4e00\u79cd\u65b0\u7684\u8fd0\u7b97\u7b26 x \\; d \\; y x \\; d \\; y \u7136\u540e\u7ed9\u51fa\u4e2d\u7f00\u8868\u8fbe\u5f0f\uff0c\u6c42\u503c\u3002 \u601d\u8def\uff1a \u5148\u4e2d\u7f00\u8f6c\u540e\u7f00\uff0c\u7136\u540e\u8003\u8651\u5982\u4f55\u6700\u5927\u5982\u4f55\u6700\u5c0f\uff0c\u6309\u9898\u610f\u6a21\u62df\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define ll long long char s [ 110 ]; ll suffix [ 110 ]; int vis [ 110 ]; unordered_map < char , int > mp ; inline void Init () { mp . clear (); mp [ '(' ] = 0 ; mp [ '+' ] = 1 ; mp [ '-' ] = 1 ; mp [ '*' ] = 2 ; mp [ 'd' ] = 3 ; } stack < char > symbol ; stack < ll > Min , Max ; inline void Run () { Init (); while ( scanf ( \"%s\" , s ) != EOF ) { while ( ! symbol . empty ()) symbol . pop (); while ( ! Min . empty ()) Min . pop (); while ( ! Max . empty ()) Max . pop (); memset ( vis , 0 , sizeof vis ); int cnt = 0 ; for ( int i = 0 , len = strlen ( s ); i < len ; ++ i ) { if ( isdigit ( s [ i ])) { ll tmp = 0 ; int flag = 1 ; if ( i == 1 && s [ 0 ] == '-' ) symbol . pop (), flag = -1 ; else if ( i > 1 && s [ i - 1 ] == '-' && s [ i - 2 ] == '(' ) symbol . pop (), flag = -1 ; for (; i < len && isdigit ( s [ i ]); ++ i ) { tmp = tmp * 10 + s [ i ] - '0' ; } suffix [ ++ cnt ] = tmp * flag ; -- i ; } else { if ( symbol . empty ()) symbol . emplace ( s [ i ]); else if ( s [ i ] == '(' ) symbol . emplace ( s [ i ]); else if ( s [ i ] == ')' ) { while ( 1 ) { int top = symbol . top (); symbol . pop (); if ( top == '(' ) break ; suffix [ ++ cnt ] = top ; vis [ cnt ] = 1 ; } } else { while ( ! symbol . empty () && mp [ symbol . top ()] >= mp [ s [ i ]]) { suffix [ ++ cnt ] = symbol . top (); symbol . pop (); vis [ cnt ] = 1 ; } symbol . emplace ( s [ i ]); } } } while ( ! symbol . empty ()) { suffix [ ++ cnt ] = symbol . top (); symbol . pop (); vis [ cnt ] = 1 ; } for ( int i = 1 ; i <= cnt ; ++ i ) { if ( ! vis [ i ]) { Min . emplace ( suffix [ i ]); Max . emplace ( suffix [ i ]); } else { ll top1 = Min . top (); Min . pop (); ll top2 = Min . top (); Min . pop (); ll top3 = Max . top (); Max . pop (); ll top4 = Max . top (); Max . pop (); if ( suffix [ i ] == '+' ) { Min . emplace ( top1 + top2 ); Max . emplace ( top3 + top4 ); } else if ( suffix [ i ] == '-' ) { Min . emplace ( top2 - top3 ); Max . emplace ( top4 - top1 ); } else if ( suffix [ i ] == '*' ) { ll ansmin = top2 * top1 ; ansmin = min ( ansmin , top2 * top3 ); ansmin = min ( ansmin , top4 * top1 ); ansmin = min ( ansmin , top4 * top3 ); ll ansmax = top2 * top1 ; ansmax = max ( ansmax , top2 * top3 ); ansmax = max ( ansmax , top4 * top1 ); ansmax = max ( ansmax , top4 * top3 ); Min . emplace ( ansmin ); Max . emplace ( ansmax ); } else { Min . emplace ( top2 ); Max . emplace ( top3 * top4 ); } } } printf ( \"%lld %lld \\n \" , Min . top (), Max . top ()); } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; } C. Convex Hull \u7559\u5751\u3002 D. Made In Heaven \u9898\u610f\uff1a \u627e\u7b2c k k \u77ed\u8def\u3002 \u601d\u8def\uff1a A* \u7b97\u6cd5\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int MOD = 1e9 + 7 ; const int INF = 0x3f3f3f3f ; const ll INFLL = 0x3f3f3f3f3f3f3f3f ; #define N 1005 #define M 50005 int n , m , k ; ll T ; bool vis [ N ]; int d [ N ]; struct node { int v ; int cost ; node () {} node ( int v , ll cost ) : v ( v ), cost ( cost ) {} inline bool operator < ( const node & b ) const { return cost + d [ v ] > b . cost + d [ b . v ]; } } edge [ M ], revedge [ M ]; struct Edge { int v , cost ; inline Edge () {} inline Edge ( int v , int cost ) : v ( v ), cost ( cost ) {} }; vector < Edge > E [ N ], revE [ N ]; inline void Dijstra ( int st ) { memset ( vis , false , sizeof vis ); for ( int i = 1 ; i <= n ; ++ i ) { d [ i ] = INF ; } priority_queue < node > q ; d [ st ] = 0 ; q . push ( node ( st , 0 )); while ( ! q . empty ()) { node tmp = q . top (); q . pop (); int u = tmp . v ; if ( vis [ u ]) continue ; vis [ u ] = true ; int len = E [ u ]. size (); for ( int i = 0 ; i < len ; ++ i ) { int v = E [ u ][ i ]. v ; int cost = E [ u ][ i ]. cost ; if ( ! vis [ v ] && d [ v ] > d [ u ] + cost ) { d [ v ] = d [ u ] + cost ; q . push ( node ( v , d [ v ])); } } } } inline int A_star ( int st , int ed ) { priority_queue < node > q ; q . push ( node ( st , 0 )); -- k ; while ( ! q . empty ()) { node tmp = q . top (); q . pop (); int u = tmp . v ; if ( u == ed ) { if ( k ) -- k ; else return tmp . cost ; } int len = revE [ u ]. size (); for ( int i = 0 ; i < len ; ++ i ) { int v = revE [ u ][ i ]. v ; int cost = revE [ u ][ i ]. cost ; q . push ( node ( v , tmp . cost + cost )); } } return -1 ; } inline void addedge ( int u , int v , int w ) { revE [ u ]. push_back ( Edge ( v , w )); E [ v ]. push_back ( Edge ( u , w )); } int st , ed ; inline void RUN () { while ( ~ scanf ( \"%d %d\" , & n , & m )) { for ( int i = 0 ; i <= n ; ++ i ) { E [ i ]. clear (); revE [ i ]. clear (); } scanf ( \"%d %d %d %lld\" , & st , & ed , & k , & T ); for ( int i = 1 ; i <= m ; ++ i ) { int u , v , w ; scanf ( \"%d %d %d\" , & u , & v , & w ); addedge ( u , v , w ); } Dijstra ( ed ); if ( d [ st ] == INF ) { puts ( \"Whitesnake!\" ); continue ; } int ans = A_star ( st , ed ); if ( ans == -1 ) { puts ( \"Whitesnake!\" ); continue ; } puts ( ans <= T ? \"yareyaredawa\" : \"Whitesnake!\" ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE } E. The cake is a lie \u7559\u5751\u3002 F. Fantastic Graph \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u5f20\u4e8c\u5206\u56fe\uff0c\u82e5\u5e72\u6761\u8fb9\uff0c\u9009\u62e9\u4e00\u4e9b\u8fb9\u8fdb\u53bb\uff0c\u4f7f\u5f97\u6240\u6709\u70b9\u7684\u5ea6\u6570\u5728 [L,R] [L,R] \u4e4b\u95f4\u3002 \u601d\u8def\uff1a XDL \u8bf4\u7206\u641c\uff0c\u52a0\u4e0a\u4f18\u79c0\u7684\u526a\u679d\uff088ms\uff09\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int MOD = 1e9 + 7 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 10 ; const ll INFLL = 0x3f3f3f3f3f3f3f3f ; struct node { int l , r ; inline node () {} inline node ( int l , int r ) : l ( l ), r ( r ) {} } arr [ maxn ]; bool flag = false ; int n , m , k ; int sum ; int res_L ; int res_R ; int L , R ; int du_left [ maxn ]; int du_right [ maxn ]; inline void Init () { memset ( du_left , 0 , sizeof du_left ); memset ( du_right , 0 , sizeof du_right ); } inline void DFS ( int idx , int cnt ) { if ( sum == n + m ) { flag = true ; return ; } if ( idx > k ) return ; if ( k - idx + 1 + cnt < res_L ) return ; if ( cnt >= res_R ) return ; if ( flag ) return ; // do if ( du_left [ arr [ idx ]. l ] < R && du_right [ arr [ idx ]. r ] < R ) { du_left [ arr [ idx ]. l ] ++ ; du_right [ arr [ idx ]. r ] ++ ; if ( du_left [ arr [ idx ]. l ] == L ) sum ++ ; if ( du_right [ arr [ idx ]. r ] == L ) sum ++ ; DFS ( idx + 1 , cnt + 1 ); if ( flag ) return ; if ( du_left [ arr [ idx ]. l ] == L ) sum -- ; if ( du_right [ arr [ idx ]. r ] == L ) sum -- ; du_left [ arr [ idx ]. l ] -- ; du_right [ arr [ idx ]. r ] -- ; } // not do DFS ( idx + 1 , cnt ); if ( flag ) return ; } inline void RUN () { int cas = 0 ; while ( ~ scanf ( \"%d %d %d\" , & n , & m , & k )) { printf ( \"Case %d: \" , ++ cas ); Init (); scanf ( \"%d %d\" , & L , & R ); int cnt = 0 ; for ( int i = 1 ; i <= k ; ++ i ) { scanf ( \"%d %d\" , & arr [ i ]. l , & arr [ i ]. r ); du_left [ arr [ i ]. l ] ++ ; du_right [ arr [ i ]. r ] ++ ; if ( du_left [ arr [ i ]. l ] == L ) cnt ++ ; if ( du_right [ arr [ i ]. r ] == L ) cnt ++ ; } if ( L == 0 ) { puts ( \"Yes\" ); continue ; } if ( cnt != n + m ) { puts ( \"No\" ); continue ; } sum = 0 ; res_L = (( n + m ) * L + 1 ) / 2 ; res_R = (( n + m ) * R ) / 2 ; Init (); flag = false ; DFS ( 1 , 0 ); puts ( flag ? \"Yes\" : \"No\" ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE } G. Spare Tire \u9898\u610f\uff1a \u7ed9\u5b9a\u4e00\u4e2a\u6570\u5217 A A \uff0c\u4e24\u4e2a\u6574\u6570 n,m n,m \uff0c\u5728 1-n 1-n \u4e2d\u6240\u6709\u4e0e m m \u4e92\u8d28\u7684\u6570\u8bb0\u4e3a b[i] b[i] \uff0c\u6c42\uff1a \\sum_{i = 1}^{i = p} a_{b_i} \\sum_{i = 1}^{i = p} a_{b_i} \u601d\u8def\uff1a \u9996\u5148\u53ef\u4ee5\u53d1\u73b0\uff1a A[i] = i \\cdot (i + 1) = i^2+i A[i] = i \\cdot (i + 1) = i^2+i A A \u7684\u524d n n \u9879\u548c\u4e3a\uff1a \\frac{n \\cdot (n+1) \\cdot (2n+1)}{6} + \\frac{n \\cdot (n+1)}{2} \\frac{n \\cdot (n+1) \\cdot (2n+1)}{6} + \\frac{n \\cdot (n+1)}{2} \u56e0\u4e3a n,m n,m \u5f88\u5927\u6709 10^8 10^8 \uff0c\u800c\u4e14\u4e00\u5171\u6709 15000 15000 \u4e2a case\uff0c\u6240\u4ee5\u7b5b\u6cd5\u80af\u5b9a\u4e0d\u884c\u3002 \u8003\u8651\u5230\uff1a 2 \\times 3 \\times 5 \\times 7 \\times 11 \\times 13 \\times 17 \\times 19 \\times 23=223092870 \\gt 10^8 2 \\times 3 \\times 5 \\times 7 \\times 11 \\times 13 \\times 17 \\times 19 \\times 23=223092870 \\gt 10^8 \u6240\u4ee5 m m \u7684\u8d28\u56e0\u5b50\u7684\u79cd\u7c7b\u80af\u5b9a\u5c11\u4e8e 9 9 \u4e2a\u3002 \u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7528\u5bb9\u65a5\u3002\u5728\u524d n n \u9879\u7684\u548c\u7684\u57fa\u7840\u4e0a\u5bb9\u65a5\u5305\u542b m m \u7684\u4e0d\u540c\u56e0\u5b50\u7684\u9879\u3002\u65f6\u95f4\u590d\u6742\u5ea6\u6700\u591a\u4e3a 2^9 2^9 \u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int MOD = 1e9 + 7 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 10 ; const ll INFLL = 0x3f3f3f3f3f3f3f3f ; int tot ; bool isprime [ maxn ]; int prime [ maxn ]; ll inv [ maxn ]; inline void Init_prime () { inv [ 1 ] = 1 ; for ( int i = 2 ; i < maxn ; ++ i ) { inv [ i ] = inv [ MOD % i ] * ( MOD - MOD / i ) % MOD ; } memset ( isprime , true , sizeof isprime ); tot = 0 ; for ( int i = 2 ; i < maxn ; ++ i ) { if ( isprime [ i ]) { prime [ tot ++ ] = i ; for ( int j = ( i << 1 ); j < maxn ; j += i ) { isprime [ i ] = false ; } } } } vector < ll > vec ; ll n , m ; ll ans ; inline void Init ( ll x ) { vec . clear (); for ( int i = 0 ; i < tot && prime [ i ] < x ; ++ i ) { if ( x % prime [ i ] == 0 ) { vec . push_back ( prime [ i ]); while ( x % prime [ i ] == 0 ) { x /= prime [ i ]; } } } if ( x != 1 ) vec . push_back ( x ); } inline void RUN () { Init_prime (); while ( ~ scanf ( \"%lld %lld\" , & n , & m )) { ans = n % MOD * ( n + 1 ) % MOD * ( n + 2 ) % MOD * inv [ 3 ] % MOD ; if ( m == 1 ) { printf ( \"%lld \\n \" , ans ); continue ; } Init ( m ); int len = vec . size (); for ( int i = 1 ; i < ( 1 << len ); ++ i ) { int cnt = 0 ; ll t = 1 ; for ( int j = 0 ; j < len ; ++ j ) { if ( i & ( 1 << j )) { cnt ++ ; t *= vec [ j ]; } } ll x = n / t ; ll tmp = x % MOD * ( x + 1 ) % MOD * ( 2 * x % MOD + 1 ) % MOD * inv [ 6 ] % MOD * t % MOD * ( t + 1 ) % MOD - x % MOD * ( x + 1 ) % MOD * ( x - 1 ) % MOD * inv [ 3 ] % MOD * t % MOD ; tmp = ( tmp + MOD ) % MOD ; if ( cnt & 1 ) { ans = ( ans - tmp + MOD ) % MOD ; } else { ans = ( ans + tmp ) % MOD ; } } printf ( \"%lld \\n \" , ans ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE } H. Hamming Weight \u7559\u5751\u3002 I. Lattice's basics in digital electronics \u6309\u9898\u610f\u6a21\u62df\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 int t , n , m ; string str , tmp , ttmp , ans , s ; unordered_map < string , char > mp ; unordered_map < char , string > mmp ; inline void Init () { mmp . clear (); mmp [ '0' ] = \"0000\" ; mmp [ '1' ] = \"0001\" ; mmp [ '2' ] = \"0010\" ; mmp [ '3' ] = \"0011\" ; mmp [ '4' ] = \"0100\" ; mmp [ '5' ] = \"0101\" ; mmp [ '6' ] = \"0110\" ; mmp [ '7' ] = \"0111\" ; mmp [ '8' ] = \"1000\" ; mmp [ '9' ] = \"1001\" ; mmp [ 'A' ] = \"1010\" ; mmp [ 'B' ] = \"1011\" ; mmp [ 'C' ] = \"1100\" ; mmp [ 'D' ] = \"1101\" ; mmp [ 'E' ] = \"1110\" ; mmp [ 'F' ] = \"1111\" ; mmp [ 'a' ] = \"1010\" ; mmp [ 'b' ] = \"1011\" ; mmp [ 'c' ] = \"1100\" ; mmp [ 'd' ] = \"1101\" ; mmp [ 'e' ] = \"1110\" ; mmp [ 'f' ] = \"1111\" ; } inline bool ok ( string s ) { int cnt = 0 ; for ( int i = 0 ; i < 8 ; ++ i ) cnt += ( s [ i ] == '1' ); if (( s [ 8 ] == '0' && ( cnt & 1 )) || ( s [ 8 ] == '1' && ( cnt & 1 ) == 0 )) return true ; return false ; } inline void Run () { cin . tie ( 0 ), cout . tie ( 0 ); Init (); ios :: sync_with_stdio ( false ); cin >> t ; while ( t -- ) { mp . clear (); cin >> m >> n ; for ( int i = 1 , num ; i <= n ; ++ i ) { cin >> num >> str ; mp [ str ] = num ; } cin >> s ; tmp = \"\" ; str = \"\" ; for ( int i = 0 , len = s . size (); i < len ; ++ i ) tmp += mmp [ s [ i ]]; for ( int i = 0 , len = tmp . size (); i < len ;) { if ( len - i < 9 ) break ; ttmp = \"\" ; for ( int cnt = 0 ; cnt < 9 ; ++ cnt , ++ i ) ttmp += tmp [ i ]; if ( ok ( ttmp )) { ttmp . erase ( ttmp . end () - 1 ); str += ttmp ; // cout << ttmp << endl; } } // for (auto it : mp) cout << it.first << \" \" << it.second << endl; ans . clear (), tmp . clear (); for ( int i = 0 , len = str . size (); i < len && ans . size () < m ; ++ i ) { tmp += str [ i ]; if ( mp . find ( tmp ) != mp . end ()) { ans += mp [ tmp ]; tmp = \"\" ; } } cout << ans << endl ; } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; } J. Ka Chang \u9898\u610f\uff1a \u4e24\u79cd\u64cd\u4f5c\uff1a 1 \\; L \\; X 1 \\; L \\; X \u6240\u6709\u6df1\u5ea6\u4e3a L L \u7684\u52a0\u4e0a x x \u3002 2 \\; X 2 \\; X \u67e5\u8be2\u4ee5 x x \u4e3a\u6839\u7684\u6240\u6709\u5b50\u8282\u70b9\u7684\u548c\u3002 \u601d\u8def\uff1a \u4ee5 x x \u4e3a\u6839\u7684\u5b50\u8282\u70b9\u7684\u548c\u53ef\u4ee5\u7528 DFS \u5e8f\u4f7f\u5f97\u6240\u6709\u5b50\u6811\u7684\u6807\u53f7\u5728\u4e00\u5757\u3002 \u7136\u540e\u5bf9\u4e8e\u66f4\u65b0\u64cd\u4f5c\uff0c\u8003\u8651\u4e24\u79cd\u65b9\u6cd5\u64cd\u4f5c\uff1a \u66b4\u529b\u66f4\u65b0\u6bcf\u4e2a\u70b9 \u8bb0\u5f55\u8fd9\u4e2a\u6df1\u5ea6\u66f4\u65b0\u4e86\u591a\u5c11\uff0c\u67e5\u8be2\u7684\u65f6\u5019\u627e\u51fa\u8fd9\u4e2a\u6df1\u5ea6\u4e2d\u6709\u5b50\u8282\u70b9\u6709\u51e0\u4e2a\uff0c\u76f4\u63a5\u52a0\u4e0a\u3002 \u5982\u679c\u53ea\u7528\u7b2c\u4e8c\u4e2a\u64cd\u4f5c\u66f4\u65b0\uff0c\u90a3\u4e48\u5f53\u7ed9\u7684\u6811\u662f\u4e00\u6761\u94fe\u7684\u65f6\u5019\uff0c\u67e5\u8be2\u7684\u590d\u6742\u5ea6\u8fbe\u5230 O(n \\log n) O(n \\log n) \u3002 \u53ea\u7528\u7b2c\u4e00\u4e2a\u64cd\u4f5c\u66f4\u65b0\uff0c\u90a3\u4e48\u66f4\u65b0\u7684\u64cd\u4f5c\u5f53\u7ed9\u7684\u6811\u662f\u83ca\u82b1\u5f62\u7684\u65f6\u5019\uff0c\u66f4\u65b0\u7684\u590d\u6742\u5ea6\u8fbe\u5230 O(n \\log n) O(n \\log n) \u3002 \u90a3\u4e48\u8003\u8651\u5c06\u4e24\u79cd\u64cd\u4f5c\u7ed3\u5408\uff0c\u5f53\u67d0\u4e2a\u6df1\u5ea6\u4e2d\u5143\u7d20\u4e2a\u6570\u5927\u4e8e sqrt(10^5) sqrt(10^5) \u7684\u65f6\u5019\uff0c\u7528\u7b2c\u4e8c\u79cd\u64cd\u4f5c \u5426\u5219\u7528\u7b2c\u4e00\u79cd \u7136\u540e\u67e5\u8be2\u7684\u65f6\u5019\uff0c\u8981\u8bb0\u5f97\u90fd\u52a0\u4e0a\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 #define ll long long struct Edge { int to , nx ; inline Edge () {} inline Edge ( int to , int nx ) : to ( to ), nx ( nx ) {} } edge [ N << 1 ]; int n , q , Maxdeep ; int head [ N ], pos ; int ord [ N ], son [ N ], deep [ N ], fa [ N ], cnt ; vector < int > dep [ N ], Lar ; ll sum [ N ]; inline void Init () { memset ( head , -1 , sizeof head ); pos = 0 ; cnt = 0 ; Maxdeep = 0 ; Lar . clear (); for ( int i = 0 ; i <= 1 ; ++ i ) dep [ i ]. clear (); fa [ 1 ] = 1 ; deep [ 1 ] = 0 ; } inline void addedge ( int u , int v ) { edge [ ++ pos ] = Edge ( v , head [ u ]); head [ u ] = pos ; } inline void DFS ( int u , int pre ) { ord [ u ] = ++ cnt ; dep [ deep [ u ]]. emplace_back ( cnt ); Maxdeep = max ( Maxdeep , deep [ u ]); for ( int it = head [ u ]; ~ it ; it = edge [ it ]. nx ) { int v = edge [ it ]. to ; if ( v == pre ) continue ; deep [ v ] = deep [ u ] + 1 ; DFS ( v , u ); } son [ u ] = cnt ; } struct node { int l , r ; ll sum ; inline node () {} inline node ( int l , int r , ll sum ) : l ( l ), r ( r ), sum ( sum ) {} } tree [ N << 2 ]; inline void pushup ( int id ) { tree [ id ]. sum = tree [ id << 1 ]. sum + tree [ id << 1 | 1 ]. sum ; } inline void build ( int id , int l , int r ) { tree [ id ] = node ( l , r , 0 ); if ( l == r ) return ; int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); } inline void update ( int id , int pos , ll val ) { if ( tree [ id ]. l == tree [ id ]. r ) { tree [ id ]. sum += val ; return ; } int mid = ( tree [ id ]. l + tree [ id ]. r ) >> 1 ; if ( pos <= mid ) update ( id << 1 , pos , val ); else if ( pos > mid ) update ( id << 1 | 1 , pos , val ); pushup ( id ); } ll anssum ; inline void query ( int id , int l , int r ) { if ( tree [ id ]. l >= l && tree [ id ]. r <= r ) { anssum += tree [ id ]. sum ; return ; } int mid = ( tree [ id ]. l + tree [ id ]. r ) >> 1 ; if ( l <= mid ) query ( id << 1 , l , r ); if ( r > mid ) query ( id << 1 | 1 , l , r ); } inline void Run () { while ( scanf ( \"%d%d\" , & n , & q ) != EOF ) { Init (); for ( int i = 1 , u , v ; i < n ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); addedge ( u , v ); addedge ( v , u ); } DFS ( 1 , 1 ); build ( 1 , 1 , n ); int limit = ( int ) sqrt ( 100000 ); for ( int i = 1 ; i <= Maxdeep ; ++ i ) { if ( dep [ i ]. size () >= limit ) { Lar . emplace_back ( i ); sort ( dep [ i ]. begin (), dep [ i ]. end ()); } } for ( int i = 1 , op , l , x ; i <= q ; ++ i ) { scanf ( \"%d\" , & op ); if ( op == 1 ) { scanf ( \"%d%d\" , & l , & x ); if ( dep [ l ]. size () < limit ) { for ( auto it : dep [ l ]) update ( 1 , it , ( ll ) x ); } else sum [ l ] += ( ll ) x ; } else { scanf ( \"%d\" , & x ); anssum = 0 ; query ( 1 , ord [ x ], son [ x ]); ll ans = anssum ; int l = ord [ x ], r = son [ x ]; for ( auto it : Lar ) { if ( it < deep [ x ]) continue ; int k = upper_bound ( dep [ it ]. begin (), dep [ it ]. end (), r ) - lower_bound ( dep [ it ]. begin (), dep [ it ]. end (), l ); if ( k == 0 ) break ; ans += sum [ it ] * k ; } printf ( \"%lld \\n \" , ans ); } } } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; } K. Supreme Number \u53ea\u6709\u51e0\u4e2a\u6570\uff0c\u7206\u641c\u51fa\u6765\uff0c\u5224\u65ad\u4e00\u4e0b Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int MOD = 1e9 + 7 ; const int INF = 0x3f3f3f3f ; const int maxn = 2e6 + 10 ; string s [] = { \"1\" , \"2\" , \"3\" , \"5\" , \"7\" , \"11\" , \"13\" , \"17\" , \"23\" , \"31\" , \"37\" , \"53\" , \"71\" , \"73\" , \"113\" , \"131\" , \"137\" , \"173\" , \"311\" , \"317\" }; inline void RUN () { int t ; cin >> t ; for ( int cas = 1 ; cas <= t ; ++ cas ) { cout << \"Case #\" << cas << \": \" ; string ans ; string str ; cin >> str ; for ( int i = 0 ; i < 20 ; ++ i ) { if ( str . length () == s [ i ]. length ()) { if ( str >= s [ i ]) ans = s [ i ]; } else if ( str . length () < s [ i ]. length ()) { continue ; } else ans = s [ i ]; } cout << ans << endl ; } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE }","title":"ACM-ICPC 2018 \u6c88\u9633\u8d5b\u533a\u7f51\u7edc\u9884\u8d5b"},{"location":"online/2018-ICPC-Shenyang-Online/#a-gudako-and-ritsuka","text":"\u7559\u5751\u3002","title":"A. Gudako and Ritsuka"},{"location":"online/2018-ICPC-Shenyang-Online/#b-call-of-accepted","text":"\u9898\u610f\uff1a \u5b9a\u4e49\u4e86\u4e00\u79cd\u65b0\u7684\u8fd0\u7b97\u7b26 x \\; d \\; y x \\; d \\; y \u7136\u540e\u7ed9\u51fa\u4e2d\u7f00\u8868\u8fbe\u5f0f\uff0c\u6c42\u503c\u3002 \u601d\u8def\uff1a \u5148\u4e2d\u7f00\u8f6c\u540e\u7f00\uff0c\u7136\u540e\u8003\u8651\u5982\u4f55\u6700\u5927\u5982\u4f55\u6700\u5c0f\uff0c\u6309\u9898\u610f\u6a21\u62df\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define ll long long char s [ 110 ]; ll suffix [ 110 ]; int vis [ 110 ]; unordered_map < char , int > mp ; inline void Init () { mp . clear (); mp [ '(' ] = 0 ; mp [ '+' ] = 1 ; mp [ '-' ] = 1 ; mp [ '*' ] = 2 ; mp [ 'd' ] = 3 ; } stack < char > symbol ; stack < ll > Min , Max ; inline void Run () { Init (); while ( scanf ( \"%s\" , s ) != EOF ) { while ( ! symbol . empty ()) symbol . pop (); while ( ! Min . empty ()) Min . pop (); while ( ! Max . empty ()) Max . pop (); memset ( vis , 0 , sizeof vis ); int cnt = 0 ; for ( int i = 0 , len = strlen ( s ); i < len ; ++ i ) { if ( isdigit ( s [ i ])) { ll tmp = 0 ; int flag = 1 ; if ( i == 1 && s [ 0 ] == '-' ) symbol . pop (), flag = -1 ; else if ( i > 1 && s [ i - 1 ] == '-' && s [ i - 2 ] == '(' ) symbol . pop (), flag = -1 ; for (; i < len && isdigit ( s [ i ]); ++ i ) { tmp = tmp * 10 + s [ i ] - '0' ; } suffix [ ++ cnt ] = tmp * flag ; -- i ; } else { if ( symbol . empty ()) symbol . emplace ( s [ i ]); else if ( s [ i ] == '(' ) symbol . emplace ( s [ i ]); else if ( s [ i ] == ')' ) { while ( 1 ) { int top = symbol . top (); symbol . pop (); if ( top == '(' ) break ; suffix [ ++ cnt ] = top ; vis [ cnt ] = 1 ; } } else { while ( ! symbol . empty () && mp [ symbol . top ()] >= mp [ s [ i ]]) { suffix [ ++ cnt ] = symbol . top (); symbol . pop (); vis [ cnt ] = 1 ; } symbol . emplace ( s [ i ]); } } } while ( ! symbol . empty ()) { suffix [ ++ cnt ] = symbol . top (); symbol . pop (); vis [ cnt ] = 1 ; } for ( int i = 1 ; i <= cnt ; ++ i ) { if ( ! vis [ i ]) { Min . emplace ( suffix [ i ]); Max . emplace ( suffix [ i ]); } else { ll top1 = Min . top (); Min . pop (); ll top2 = Min . top (); Min . pop (); ll top3 = Max . top (); Max . pop (); ll top4 = Max . top (); Max . pop (); if ( suffix [ i ] == '+' ) { Min . emplace ( top1 + top2 ); Max . emplace ( top3 + top4 ); } else if ( suffix [ i ] == '-' ) { Min . emplace ( top2 - top3 ); Max . emplace ( top4 - top1 ); } else if ( suffix [ i ] == '*' ) { ll ansmin = top2 * top1 ; ansmin = min ( ansmin , top2 * top3 ); ansmin = min ( ansmin , top4 * top1 ); ansmin = min ( ansmin , top4 * top3 ); ll ansmax = top2 * top1 ; ansmax = max ( ansmax , top2 * top3 ); ansmax = max ( ansmax , top4 * top1 ); ansmax = max ( ansmax , top4 * top3 ); Min . emplace ( ansmin ); Max . emplace ( ansmax ); } else { Min . emplace ( top2 ); Max . emplace ( top3 * top4 ); } } } printf ( \"%lld %lld \\n \" , Min . top (), Max . top ()); } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; }","title":"B. Call of Accepted"},{"location":"online/2018-ICPC-Shenyang-Online/#c-convex-hull","text":"\u7559\u5751\u3002","title":"C. Convex Hull"},{"location":"online/2018-ICPC-Shenyang-Online/#d-made-in-heaven","text":"\u9898\u610f\uff1a \u627e\u7b2c k k \u77ed\u8def\u3002 \u601d\u8def\uff1a A* \u7b97\u6cd5\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int MOD = 1e9 + 7 ; const int INF = 0x3f3f3f3f ; const ll INFLL = 0x3f3f3f3f3f3f3f3f ; #define N 1005 #define M 50005 int n , m , k ; ll T ; bool vis [ N ]; int d [ N ]; struct node { int v ; int cost ; node () {} node ( int v , ll cost ) : v ( v ), cost ( cost ) {} inline bool operator < ( const node & b ) const { return cost + d [ v ] > b . cost + d [ b . v ]; } } edge [ M ], revedge [ M ]; struct Edge { int v , cost ; inline Edge () {} inline Edge ( int v , int cost ) : v ( v ), cost ( cost ) {} }; vector < Edge > E [ N ], revE [ N ]; inline void Dijstra ( int st ) { memset ( vis , false , sizeof vis ); for ( int i = 1 ; i <= n ; ++ i ) { d [ i ] = INF ; } priority_queue < node > q ; d [ st ] = 0 ; q . push ( node ( st , 0 )); while ( ! q . empty ()) { node tmp = q . top (); q . pop (); int u = tmp . v ; if ( vis [ u ]) continue ; vis [ u ] = true ; int len = E [ u ]. size (); for ( int i = 0 ; i < len ; ++ i ) { int v = E [ u ][ i ]. v ; int cost = E [ u ][ i ]. cost ; if ( ! vis [ v ] && d [ v ] > d [ u ] + cost ) { d [ v ] = d [ u ] + cost ; q . push ( node ( v , d [ v ])); } } } } inline int A_star ( int st , int ed ) { priority_queue < node > q ; q . push ( node ( st , 0 )); -- k ; while ( ! q . empty ()) { node tmp = q . top (); q . pop (); int u = tmp . v ; if ( u == ed ) { if ( k ) -- k ; else return tmp . cost ; } int len = revE [ u ]. size (); for ( int i = 0 ; i < len ; ++ i ) { int v = revE [ u ][ i ]. v ; int cost = revE [ u ][ i ]. cost ; q . push ( node ( v , tmp . cost + cost )); } } return -1 ; } inline void addedge ( int u , int v , int w ) { revE [ u ]. push_back ( Edge ( v , w )); E [ v ]. push_back ( Edge ( u , w )); } int st , ed ; inline void RUN () { while ( ~ scanf ( \"%d %d\" , & n , & m )) { for ( int i = 0 ; i <= n ; ++ i ) { E [ i ]. clear (); revE [ i ]. clear (); } scanf ( \"%d %d %d %lld\" , & st , & ed , & k , & T ); for ( int i = 1 ; i <= m ; ++ i ) { int u , v , w ; scanf ( \"%d %d %d\" , & u , & v , & w ); addedge ( u , v , w ); } Dijstra ( ed ); if ( d [ st ] == INF ) { puts ( \"Whitesnake!\" ); continue ; } int ans = A_star ( st , ed ); if ( ans == -1 ) { puts ( \"Whitesnake!\" ); continue ; } puts ( ans <= T ? \"yareyaredawa\" : \"Whitesnake!\" ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE }","title":"D. Made In Heaven"},{"location":"online/2018-ICPC-Shenyang-Online/#e-the-cake-is-a-lie","text":"\u7559\u5751\u3002","title":"E. The cake is a lie"},{"location":"online/2018-ICPC-Shenyang-Online/#f-fantastic-graph","text":"\u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u5f20\u4e8c\u5206\u56fe\uff0c\u82e5\u5e72\u6761\u8fb9\uff0c\u9009\u62e9\u4e00\u4e9b\u8fb9\u8fdb\u53bb\uff0c\u4f7f\u5f97\u6240\u6709\u70b9\u7684\u5ea6\u6570\u5728 [L,R] [L,R] \u4e4b\u95f4\u3002 \u601d\u8def\uff1a XDL \u8bf4\u7206\u641c\uff0c\u52a0\u4e0a\u4f18\u79c0\u7684\u526a\u679d\uff088ms\uff09\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int MOD = 1e9 + 7 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 10 ; const ll INFLL = 0x3f3f3f3f3f3f3f3f ; struct node { int l , r ; inline node () {} inline node ( int l , int r ) : l ( l ), r ( r ) {} } arr [ maxn ]; bool flag = false ; int n , m , k ; int sum ; int res_L ; int res_R ; int L , R ; int du_left [ maxn ]; int du_right [ maxn ]; inline void Init () { memset ( du_left , 0 , sizeof du_left ); memset ( du_right , 0 , sizeof du_right ); } inline void DFS ( int idx , int cnt ) { if ( sum == n + m ) { flag = true ; return ; } if ( idx > k ) return ; if ( k - idx + 1 + cnt < res_L ) return ; if ( cnt >= res_R ) return ; if ( flag ) return ; // do if ( du_left [ arr [ idx ]. l ] < R && du_right [ arr [ idx ]. r ] < R ) { du_left [ arr [ idx ]. l ] ++ ; du_right [ arr [ idx ]. r ] ++ ; if ( du_left [ arr [ idx ]. l ] == L ) sum ++ ; if ( du_right [ arr [ idx ]. r ] == L ) sum ++ ; DFS ( idx + 1 , cnt + 1 ); if ( flag ) return ; if ( du_left [ arr [ idx ]. l ] == L ) sum -- ; if ( du_right [ arr [ idx ]. r ] == L ) sum -- ; du_left [ arr [ idx ]. l ] -- ; du_right [ arr [ idx ]. r ] -- ; } // not do DFS ( idx + 1 , cnt ); if ( flag ) return ; } inline void RUN () { int cas = 0 ; while ( ~ scanf ( \"%d %d %d\" , & n , & m , & k )) { printf ( \"Case %d: \" , ++ cas ); Init (); scanf ( \"%d %d\" , & L , & R ); int cnt = 0 ; for ( int i = 1 ; i <= k ; ++ i ) { scanf ( \"%d %d\" , & arr [ i ]. l , & arr [ i ]. r ); du_left [ arr [ i ]. l ] ++ ; du_right [ arr [ i ]. r ] ++ ; if ( du_left [ arr [ i ]. l ] == L ) cnt ++ ; if ( du_right [ arr [ i ]. r ] == L ) cnt ++ ; } if ( L == 0 ) { puts ( \"Yes\" ); continue ; } if ( cnt != n + m ) { puts ( \"No\" ); continue ; } sum = 0 ; res_L = (( n + m ) * L + 1 ) / 2 ; res_R = (( n + m ) * R ) / 2 ; Init (); flag = false ; DFS ( 1 , 0 ); puts ( flag ? \"Yes\" : \"No\" ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE }","title":"F. Fantastic Graph"},{"location":"online/2018-ICPC-Shenyang-Online/#g-spare-tire","text":"\u9898\u610f\uff1a \u7ed9\u5b9a\u4e00\u4e2a\u6570\u5217 A A \uff0c\u4e24\u4e2a\u6574\u6570 n,m n,m \uff0c\u5728 1-n 1-n \u4e2d\u6240\u6709\u4e0e m m \u4e92\u8d28\u7684\u6570\u8bb0\u4e3a b[i] b[i] \uff0c\u6c42\uff1a \\sum_{i = 1}^{i = p} a_{b_i} \\sum_{i = 1}^{i = p} a_{b_i} \u601d\u8def\uff1a \u9996\u5148\u53ef\u4ee5\u53d1\u73b0\uff1a A[i] = i \\cdot (i + 1) = i^2+i A[i] = i \\cdot (i + 1) = i^2+i A A \u7684\u524d n n \u9879\u548c\u4e3a\uff1a \\frac{n \\cdot (n+1) \\cdot (2n+1)}{6} + \\frac{n \\cdot (n+1)}{2} \\frac{n \\cdot (n+1) \\cdot (2n+1)}{6} + \\frac{n \\cdot (n+1)}{2} \u56e0\u4e3a n,m n,m \u5f88\u5927\u6709 10^8 10^8 \uff0c\u800c\u4e14\u4e00\u5171\u6709 15000 15000 \u4e2a case\uff0c\u6240\u4ee5\u7b5b\u6cd5\u80af\u5b9a\u4e0d\u884c\u3002 \u8003\u8651\u5230\uff1a 2 \\times 3 \\times 5 \\times 7 \\times 11 \\times 13 \\times 17 \\times 19 \\times 23=223092870 \\gt 10^8 2 \\times 3 \\times 5 \\times 7 \\times 11 \\times 13 \\times 17 \\times 19 \\times 23=223092870 \\gt 10^8 \u6240\u4ee5 m m \u7684\u8d28\u56e0\u5b50\u7684\u79cd\u7c7b\u80af\u5b9a\u5c11\u4e8e 9 9 \u4e2a\u3002 \u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7528\u5bb9\u65a5\u3002\u5728\u524d n n \u9879\u7684\u548c\u7684\u57fa\u7840\u4e0a\u5bb9\u65a5\u5305\u542b m m \u7684\u4e0d\u540c\u56e0\u5b50\u7684\u9879\u3002\u65f6\u95f4\u590d\u6742\u5ea6\u6700\u591a\u4e3a 2^9 2^9 \u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int MOD = 1e9 + 7 ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 10 ; const ll INFLL = 0x3f3f3f3f3f3f3f3f ; int tot ; bool isprime [ maxn ]; int prime [ maxn ]; ll inv [ maxn ]; inline void Init_prime () { inv [ 1 ] = 1 ; for ( int i = 2 ; i < maxn ; ++ i ) { inv [ i ] = inv [ MOD % i ] * ( MOD - MOD / i ) % MOD ; } memset ( isprime , true , sizeof isprime ); tot = 0 ; for ( int i = 2 ; i < maxn ; ++ i ) { if ( isprime [ i ]) { prime [ tot ++ ] = i ; for ( int j = ( i << 1 ); j < maxn ; j += i ) { isprime [ i ] = false ; } } } } vector < ll > vec ; ll n , m ; ll ans ; inline void Init ( ll x ) { vec . clear (); for ( int i = 0 ; i < tot && prime [ i ] < x ; ++ i ) { if ( x % prime [ i ] == 0 ) { vec . push_back ( prime [ i ]); while ( x % prime [ i ] == 0 ) { x /= prime [ i ]; } } } if ( x != 1 ) vec . push_back ( x ); } inline void RUN () { Init_prime (); while ( ~ scanf ( \"%lld %lld\" , & n , & m )) { ans = n % MOD * ( n + 1 ) % MOD * ( n + 2 ) % MOD * inv [ 3 ] % MOD ; if ( m == 1 ) { printf ( \"%lld \\n \" , ans ); continue ; } Init ( m ); int len = vec . size (); for ( int i = 1 ; i < ( 1 << len ); ++ i ) { int cnt = 0 ; ll t = 1 ; for ( int j = 0 ; j < len ; ++ j ) { if ( i & ( 1 << j )) { cnt ++ ; t *= vec [ j ]; } } ll x = n / t ; ll tmp = x % MOD * ( x + 1 ) % MOD * ( 2 * x % MOD + 1 ) % MOD * inv [ 6 ] % MOD * t % MOD * ( t + 1 ) % MOD - x % MOD * ( x + 1 ) % MOD * ( x - 1 ) % MOD * inv [ 3 ] % MOD * t % MOD ; tmp = ( tmp + MOD ) % MOD ; if ( cnt & 1 ) { ans = ( ans - tmp + MOD ) % MOD ; } else { ans = ( ans + tmp ) % MOD ; } } printf ( \"%lld \\n \" , ans ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE }","title":"G. Spare Tire"},{"location":"online/2018-ICPC-Shenyang-Online/#h-hamming-weight","text":"\u7559\u5751\u3002","title":"H. Hamming Weight"},{"location":"online/2018-ICPC-Shenyang-Online/#i-lattices-basics-in-digital-electronics","text":"\u6309\u9898\u610f\u6a21\u62df\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 int t , n , m ; string str , tmp , ttmp , ans , s ; unordered_map < string , char > mp ; unordered_map < char , string > mmp ; inline void Init () { mmp . clear (); mmp [ '0' ] = \"0000\" ; mmp [ '1' ] = \"0001\" ; mmp [ '2' ] = \"0010\" ; mmp [ '3' ] = \"0011\" ; mmp [ '4' ] = \"0100\" ; mmp [ '5' ] = \"0101\" ; mmp [ '6' ] = \"0110\" ; mmp [ '7' ] = \"0111\" ; mmp [ '8' ] = \"1000\" ; mmp [ '9' ] = \"1001\" ; mmp [ 'A' ] = \"1010\" ; mmp [ 'B' ] = \"1011\" ; mmp [ 'C' ] = \"1100\" ; mmp [ 'D' ] = \"1101\" ; mmp [ 'E' ] = \"1110\" ; mmp [ 'F' ] = \"1111\" ; mmp [ 'a' ] = \"1010\" ; mmp [ 'b' ] = \"1011\" ; mmp [ 'c' ] = \"1100\" ; mmp [ 'd' ] = \"1101\" ; mmp [ 'e' ] = \"1110\" ; mmp [ 'f' ] = \"1111\" ; } inline bool ok ( string s ) { int cnt = 0 ; for ( int i = 0 ; i < 8 ; ++ i ) cnt += ( s [ i ] == '1' ); if (( s [ 8 ] == '0' && ( cnt & 1 )) || ( s [ 8 ] == '1' && ( cnt & 1 ) == 0 )) return true ; return false ; } inline void Run () { cin . tie ( 0 ), cout . tie ( 0 ); Init (); ios :: sync_with_stdio ( false ); cin >> t ; while ( t -- ) { mp . clear (); cin >> m >> n ; for ( int i = 1 , num ; i <= n ; ++ i ) { cin >> num >> str ; mp [ str ] = num ; } cin >> s ; tmp = \"\" ; str = \"\" ; for ( int i = 0 , len = s . size (); i < len ; ++ i ) tmp += mmp [ s [ i ]]; for ( int i = 0 , len = tmp . size (); i < len ;) { if ( len - i < 9 ) break ; ttmp = \"\" ; for ( int cnt = 0 ; cnt < 9 ; ++ cnt , ++ i ) ttmp += tmp [ i ]; if ( ok ( ttmp )) { ttmp . erase ( ttmp . end () - 1 ); str += ttmp ; // cout << ttmp << endl; } } // for (auto it : mp) cout << it.first << \" \" << it.second << endl; ans . clear (), tmp . clear (); for ( int i = 0 , len = str . size (); i < len && ans . size () < m ; ++ i ) { tmp += str [ i ]; if ( mp . find ( tmp ) != mp . end ()) { ans += mp [ tmp ]; tmp = \"\" ; } } cout << ans << endl ; } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; }","title":"I. Lattice's basics in digital electronics"},{"location":"online/2018-ICPC-Shenyang-Online/#j-ka-chang","text":"\u9898\u610f\uff1a \u4e24\u79cd\u64cd\u4f5c\uff1a 1 \\; L \\; X 1 \\; L \\; X \u6240\u6709\u6df1\u5ea6\u4e3a L L \u7684\u52a0\u4e0a x x \u3002 2 \\; X 2 \\; X \u67e5\u8be2\u4ee5 x x \u4e3a\u6839\u7684\u6240\u6709\u5b50\u8282\u70b9\u7684\u548c\u3002 \u601d\u8def\uff1a \u4ee5 x x \u4e3a\u6839\u7684\u5b50\u8282\u70b9\u7684\u548c\u53ef\u4ee5\u7528 DFS \u5e8f\u4f7f\u5f97\u6240\u6709\u5b50\u6811\u7684\u6807\u53f7\u5728\u4e00\u5757\u3002 \u7136\u540e\u5bf9\u4e8e\u66f4\u65b0\u64cd\u4f5c\uff0c\u8003\u8651\u4e24\u79cd\u65b9\u6cd5\u64cd\u4f5c\uff1a \u66b4\u529b\u66f4\u65b0\u6bcf\u4e2a\u70b9 \u8bb0\u5f55\u8fd9\u4e2a\u6df1\u5ea6\u66f4\u65b0\u4e86\u591a\u5c11\uff0c\u67e5\u8be2\u7684\u65f6\u5019\u627e\u51fa\u8fd9\u4e2a\u6df1\u5ea6\u4e2d\u6709\u5b50\u8282\u70b9\u6709\u51e0\u4e2a\uff0c\u76f4\u63a5\u52a0\u4e0a\u3002 \u5982\u679c\u53ea\u7528\u7b2c\u4e8c\u4e2a\u64cd\u4f5c\u66f4\u65b0\uff0c\u90a3\u4e48\u5f53\u7ed9\u7684\u6811\u662f\u4e00\u6761\u94fe\u7684\u65f6\u5019\uff0c\u67e5\u8be2\u7684\u590d\u6742\u5ea6\u8fbe\u5230 O(n \\log n) O(n \\log n) \u3002 \u53ea\u7528\u7b2c\u4e00\u4e2a\u64cd\u4f5c\u66f4\u65b0\uff0c\u90a3\u4e48\u66f4\u65b0\u7684\u64cd\u4f5c\u5f53\u7ed9\u7684\u6811\u662f\u83ca\u82b1\u5f62\u7684\u65f6\u5019\uff0c\u66f4\u65b0\u7684\u590d\u6742\u5ea6\u8fbe\u5230 O(n \\log n) O(n \\log n) \u3002 \u90a3\u4e48\u8003\u8651\u5c06\u4e24\u79cd\u64cd\u4f5c\u7ed3\u5408\uff0c\u5f53\u67d0\u4e2a\u6df1\u5ea6\u4e2d\u5143\u7d20\u4e2a\u6570\u5927\u4e8e sqrt(10^5) sqrt(10^5) \u7684\u65f6\u5019\uff0c\u7528\u7b2c\u4e8c\u79cd\u64cd\u4f5c \u5426\u5219\u7528\u7b2c\u4e00\u79cd \u7136\u540e\u67e5\u8be2\u7684\u65f6\u5019\uff0c\u8981\u8bb0\u5f97\u90fd\u52a0\u4e0a\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 #define ll long long struct Edge { int to , nx ; inline Edge () {} inline Edge ( int to , int nx ) : to ( to ), nx ( nx ) {} } edge [ N << 1 ]; int n , q , Maxdeep ; int head [ N ], pos ; int ord [ N ], son [ N ], deep [ N ], fa [ N ], cnt ; vector < int > dep [ N ], Lar ; ll sum [ N ]; inline void Init () { memset ( head , -1 , sizeof head ); pos = 0 ; cnt = 0 ; Maxdeep = 0 ; Lar . clear (); for ( int i = 0 ; i <= 1 ; ++ i ) dep [ i ]. clear (); fa [ 1 ] = 1 ; deep [ 1 ] = 0 ; } inline void addedge ( int u , int v ) { edge [ ++ pos ] = Edge ( v , head [ u ]); head [ u ] = pos ; } inline void DFS ( int u , int pre ) { ord [ u ] = ++ cnt ; dep [ deep [ u ]]. emplace_back ( cnt ); Maxdeep = max ( Maxdeep , deep [ u ]); for ( int it = head [ u ]; ~ it ; it = edge [ it ]. nx ) { int v = edge [ it ]. to ; if ( v == pre ) continue ; deep [ v ] = deep [ u ] + 1 ; DFS ( v , u ); } son [ u ] = cnt ; } struct node { int l , r ; ll sum ; inline node () {} inline node ( int l , int r , ll sum ) : l ( l ), r ( r ), sum ( sum ) {} } tree [ N << 2 ]; inline void pushup ( int id ) { tree [ id ]. sum = tree [ id << 1 ]. sum + tree [ id << 1 | 1 ]. sum ; } inline void build ( int id , int l , int r ) { tree [ id ] = node ( l , r , 0 ); if ( l == r ) return ; int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); } inline void update ( int id , int pos , ll val ) { if ( tree [ id ]. l == tree [ id ]. r ) { tree [ id ]. sum += val ; return ; } int mid = ( tree [ id ]. l + tree [ id ]. r ) >> 1 ; if ( pos <= mid ) update ( id << 1 , pos , val ); else if ( pos > mid ) update ( id << 1 | 1 , pos , val ); pushup ( id ); } ll anssum ; inline void query ( int id , int l , int r ) { if ( tree [ id ]. l >= l && tree [ id ]. r <= r ) { anssum += tree [ id ]. sum ; return ; } int mid = ( tree [ id ]. l + tree [ id ]. r ) >> 1 ; if ( l <= mid ) query ( id << 1 , l , r ); if ( r > mid ) query ( id << 1 | 1 , l , r ); } inline void Run () { while ( scanf ( \"%d%d\" , & n , & q ) != EOF ) { Init (); for ( int i = 1 , u , v ; i < n ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); addedge ( u , v ); addedge ( v , u ); } DFS ( 1 , 1 ); build ( 1 , 1 , n ); int limit = ( int ) sqrt ( 100000 ); for ( int i = 1 ; i <= Maxdeep ; ++ i ) { if ( dep [ i ]. size () >= limit ) { Lar . emplace_back ( i ); sort ( dep [ i ]. begin (), dep [ i ]. end ()); } } for ( int i = 1 , op , l , x ; i <= q ; ++ i ) { scanf ( \"%d\" , & op ); if ( op == 1 ) { scanf ( \"%d%d\" , & l , & x ); if ( dep [ l ]. size () < limit ) { for ( auto it : dep [ l ]) update ( 1 , it , ( ll ) x ); } else sum [ l ] += ( ll ) x ; } else { scanf ( \"%d\" , & x ); anssum = 0 ; query ( 1 , ord [ x ], son [ x ]); ll ans = anssum ; int l = ord [ x ], r = son [ x ]; for ( auto it : Lar ) { if ( it < deep [ x ]) continue ; int k = upper_bound ( dep [ it ]. begin (), dep [ it ]. end (), r ) - lower_bound ( dep [ it ]. begin (), dep [ it ]. end (), l ); if ( k == 0 ) break ; ans += sum [ it ] * k ; } printf ( \"%lld \\n \" , ans ); } } } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; }","title":"J. Ka Chang"},{"location":"online/2018-ICPC-Shenyang-Online/#k-supreme-number","text":"\u53ea\u6709\u51e0\u4e2a\u6570\uff0c\u7206\u641c\u51fa\u6765\uff0c\u5224\u65ad\u4e00\u4e0b Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int MOD = 1e9 + 7 ; const int INF = 0x3f3f3f3f ; const int maxn = 2e6 + 10 ; string s [] = { \"1\" , \"2\" , \"3\" , \"5\" , \"7\" , \"11\" , \"13\" , \"17\" , \"23\" , \"31\" , \"37\" , \"53\" , \"71\" , \"73\" , \"113\" , \"131\" , \"137\" , \"173\" , \"311\" , \"317\" }; inline void RUN () { int t ; cin >> t ; for ( int cas = 1 ; cas <= t ; ++ cas ) { cout << \"Case #\" << cas << \": \" ; string ans ; string str ; cin >> str ; for ( int i = 0 ; i < 20 ; ++ i ) { if ( str . length () == s [ i ]. length ()) { if ( str >= s [ i ]) ans = s [ i ]; } else if ( str . length () < s [ i ]. length ()) { continue ; } else ans = s [ i ]; } cout << ans << endl ; } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE }","title":"K. Supreme Number"},{"location":"onsite/17th-zjpsc/","text":"\u7b2c 17 \u5c4a\u6d59\u6c5f\u7701\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b Contents Contest Info Reply Solutions Problem A. AD 2020 Problem B. Bin Packing Problem Problem C. Crossword Validation Problem D. Dividing the Points Problem E. Easy DP Problem Problem F. Finding a Sample Problem G. Gliding Problem H. Huge Clouds Problem I. Invoking the Magic Problem J. Just an Old Problem Problem K. Killing the Brute-forces Problem L. List of Products Contest Info Practice Link Solved A B C D E F G H I J K L 7/12 O O O - O - O ! O - O - O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5 Reply Dup4: \u676d\u7535\u771f\u5f3a\u3002 \u592a\u83dc\u4e86\u554a\uff0c\u8d5b\u65f6\u8fde\u533a\u95f4\u7b2c k k \u5927\u90fd\u4e0d\u77e5\u9053\u600e\u4e48\u6c42\u4e86\u554a\u3002 Hash \u8fd8\u662f Trie , \u50bb\u50bb\u5206\u4e0d\u6e05\u4e86\u554a\u3002 \u597d\u50cf\u9664\u4e86\u7b2c\u4e00\u5e74\u6253\u7701\u8d5b\u628a\u5361\u7740\u7684\u90a3\u4e00\u9898\u8fc7\u4e86\uff0c\u4e4b\u540e\u4e24\u5e74\u90fd\u6ca1\u8fc7\u554a\uff1f Hsueh-\uff1a \u8001\u4e86\u8be5\u9000\u5f79\u4e86\uff0c\u6bd4\u8d5b\u7684\u65f6\u5019\u5e76\u67e5\u96c6\u90fd\u5199\u7684\u4e00\u6123\u4e00\u6123\u7684\u3002 \u51e0\u4f55\u6c38\u8fdc\u51fa\u4e0d\u6765\uff0c\u613f\u5929\u5802\u6ca1\u6709\u8ba1\u7b97\u51e0\u4f55\u3002 Solutions Problem A. AD 2020 Solved By Dup4 & Hsueh-. 01:10(+) \u9898\u610f\uff1a \u5982\u679c\u4e00\u4e2a\u65e5\u671f\u5b57\u7b26\u4e32\u4e2d\u5305\u542b 202 \u8fd9\u4e2a\u5b50\u4e32\uff0c\u90a3\u4e48\u79f0\u5b83\u4e3a Disaster Reduction \u3002 \u7ed9\u51fa\u4e00\u4e2a\u8d77\u59cb\u65e5\u671f\u548c\u4e00\u4e2a\u7ec8\u6b62\u65e5\u671f\uff0c\u95ee\u8fd9\u4e4b\u95f4\u7684\u65e5\u671f\u6709\u591a\u5c11\u4e2a Disaster Reduction \uff1f \u601d\u8def\uff1a \u9884\u5904\u7406\u4e00\u4e0b\uff0c\u5904\u7406\u4e00\u4e2a\u8fb9\u8fb9\u89d2\u89d2\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int f [ N ]; int y [ 2 ], m [ 2 ], d [ 2 ]; int Mon [ 2 ][ 13 ] = { 0 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 0 , 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; bool isLeap ( int y ) { if ( y % 400 == 0 || ( y % 4 == 0 && y % 100 != 0 )) { return true ; } return false ; } int allD ( int y ) { if ( isLeap ( y )) return 366 ; else return 365 ; } int getAll ( int y ) { if ( y / 10 == 202 ) return allD ( y ); if ( y % 1000 == 202 ) return allD ( y ); int res = 1 ; if ( y % 10 == 2 ) { if ( isLeap ( y )) res += 1 ; res += 28 ; } else { res += 1 ; } return res ; } int calc ( int y , int m , int d ) { if ( y / 10 == 202 || y % 1000 == 202 ) { int res = 0 ; int ok = isLeap ( y ); for ( int i = 1 ; i < m ; ++ i ) { res += Mon [ ok ][ i ]; } res += d ; return res ; } int res = 0 ; if ( y % 10 == 2 ) { if ( m == 2 ) res += d ; else if ( m > 2 ) res += int ( isLeap ( y )) + 28 ; } else { if ( m == 2 && d >= 2 ) res += 1 ; else if ( m > 2 ) res += 1 ; } if ( m == 12 && d >= 2 ) res += 1 ; return res ; } int valid ( int y , int m , int d ) { if ( y / 10 == 202 || y % 1000 == 202 ) { return 1 ; } if ( m == 12 && d == 2 ) return 1 ; if ( y % 10 == 2 ) { if ( m == 2 ) return 1 ; } else { if ( m == 2 && d == 2 ) return 1 ; } return 0 ; } int main () { for ( int i = 2000 ; i <= 9999 ; ++ i ) { f [ i ] = f [ i - 1 ] + getAll ( i ); } // cout << f[9999] << endl; int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { for ( int i = 0 ; i < 2 ; ++ i ) { scanf ( \"%d %d %d\" , y + i , m + i , d + i ); } int l = y [ 0 ], r = y [ 1 ]; int res = 0 ; if ( l < r ) { res += f [ r - 1 ] - f [ l ]; } if ( l == r ) { res += calc ( y [ 1 ], m [ 1 ], d [ 1 ]) - calc ( y [ 0 ], m [ 0 ], d [ 0 ]) + valid ( y [ 0 ], m [ 0 ], d [ 0 ]); } else { res += calc ( y [ 0 ], 12 , 31 ) - calc ( y [ 0 ], m [ 0 ], d [ 0 ]) + valid ( y [ 0 ], m [ 0 ], d [ 0 ]); res += calc ( y [ 1 ], m [ 1 ], d [ 1 ]); } printf ( \"%d \\n \" , res ); } return 0 ; } Problem B. Bin Packing Problem Solved By all. 00:57(+) \u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u77f3\u5934\uff0c\u548c\u65e0\u9650\u4e2a\u5bb9\u91cf\u4e3a C C \u7684\u7bb1\u5b50\uff0c\u6bcf\u4e2a\u77f3\u5934\u7684\u5bb9\u91cf\u4e3a a_i a_i \u3002 \u73b0\u5728\u8981\u5c06\u77f3\u5934\u90fd\u653e\u8fdb\u7bb1\u5b50\u4e2d\uff0c\u73b0\u5728\u6709\u4e24\u79cd\u505a\u6cd5\uff1a \u5bf9\u4e8e\u7b2c i i \u4e2a\u77f3\u5934\uff1a \u6309\u987a\u5e8f\u904d\u5386\uff0c\u9047\u5230\u80fd\u653e\u7684\u5c31\u653e\u3002 \u627e\u4e00\u4e2a\u6700\u5c0f\u7684\u5e76\u4e14\u80fd\u653e\u4e0b\u7684\u7bb1\u5b50\uff0c\u5c06\u5f53\u524d\u7684\u77f3\u5934\u653e\u4e0b\u3002 \u6c42\u51fa\u4e24\u79cd\u505a\u6cd5\u5206\u522b\u6c42\u51fa\u6240\u9700\u7684\u7bb1\u5b50\u6570\u91cf\u3002 \u601d\u8def\uff1a \u7ebf\u6bb5\u6811\u7ef4\u62a4\u7bb1\u5b50\u5bb9\u91cf\u7684\u6700\u5927\u503c\uff0c\u4f18\u5148\u8d70\u5de6\u513f\u5b50\u3002 \u7528\u4e00\u4e2a set \u7ef4\u62a4\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e6 + 10 ; int n , C ; int a [ N ]; struct SEG { int t [ N << 2 ]; void build ( int id , int l , int r ) { t [ id ] = 0 ; if ( l == r ) { return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); } void update ( int id , int l , int r , int pos , int v ) { if ( l == r ) { t [ id ] += v ; return ; } int mid = ( l + r ) >> 1 ; if ( pos <= mid ) update ( id << 1 , l , mid , pos , v ); else update ( id << 1 | 1 , mid + 1 , r , pos , v ); t [ id ] = max ( t [ id << 1 ], t [ id << 1 | 1 ]); } int query ( int id , int l , int r , int v ) { if ( l == r ) return l ; int mid = ( l + r ) >> 1 ; if ( t [ id << 1 ] >= v ) return query ( id << 1 , l , mid , v ); return query ( id << 1 | 1 , mid + 1 , r , v ); } } seg ; int gao () { int m = 0 ; seg . build ( 1 , 1 , n ); seg . update ( 1 , 1 , n , m + 1 , C ); m += 1 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( seg . t [ 1 ] < a [ i ]) { seg . update ( 1 , 1 , n , m + 1 , C ); m += 1 ; } int pos = seg . query ( 1 , 1 , n , a [ i ]); seg . update ( 1 , 1 , n , pos , - a [ i ]); } return m ; } int gao1 () { multiset < int > se ; for ( int i = 1 ; i <= n ; ++ i ) { auto pos = se . lower_bound ( a [ i ]); if ( pos == se . end ()) { se . insert ( C ); pos = se . lower_bound ( a [ i ]); } int now = * pos - a [ i ]; se . erase ( pos ); se . insert ( now ); // cout << now << endl; } // cout << \"----\\n\"; // for (auto &it : se) // cout << it << endl; return int ( se . size ()); } int main () { int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d%d\" , & n , & C ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); } int A = gao (); int B = gao1 (); printf ( \"%d %d \\n \" , A , B ); } return 0 ; } Problem C. Crossword Validation Solved By Dup4 & Hsueh-. 02:57(+1) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a n \\cdot n n \\cdot n \u7684\u5b57\u7b26\u77e9\u9635\uff0c\u6a2a\u7740\u7ad6\u7740\u4ee5 # \u5206\u5272\u5f00\u82e5\u5e72\u4e2a\u5b57\u7b26\u4e32\uff0c\u518d\u7ed9\u51fa m m \u4e2a\u5b57\u5178\uff0c\u5e76\u4e14\u5b57\u5178\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u4e32\u90fd\u6709\u4ef7\u503c v_i v_i \u3002\u5b57\u5178\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u4e32\u90fd\u4e24\u4e24\u4e0d\u540c\u3002 \u73b0\u5728\u8981\u5c06\u4ee5 # \u5206\u5272\u5f00\u7684\u6bcf\u4e2a\u5b57\u7b26\u4e32\u627e\u5230\u5b57\u5178\u4e2d\u5bf9\u5e94\u5b57\u7b26\u4e32\u7684\u4ef7\u503c\u7d2f\u52a0\u8d77\u6765\u3002 \u5982\u679c\u51fa\u73b0\u4e00\u4e2a\u5b57\u7b26\u4e32\u672a\u51fa\u73b0\u5728\u5b57\u5178\u4e2d\uff0c\u90a3\u4e48\u8f93\u51fa -1 -1 \u3002 \u601d\u8def\uff1a \u76f4\u63a5\u5efa\u7acb\u4e00\u4e2a Trie \u5373\u53ef\uff0c\u521a\u5f00\u59cb\u5199\u4e86\u4e2a Hash \uff0c\u88ab\u5361\u4e86\u3002 \u800c\u4e14 Trie \u590d\u6742\u5ea6\u975e\u5e38\u6b63\u786e\uff0c\u53c8\u4e0d\u4f1a\u6709\u51b2\u7a81\u3002 \u542c\u8bf4\u81ea\u7136\u6ea2\u51fa\u8fc7\u4e86\uff1f Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 4e6 + 10 ; const int M = 1e3 + 10 ; const int ALP = 26 ; #define fi first #define se second int n , m ; char s [ N ]; char t [ M ][ M ]; struct Trie { struct node { int nx [ ALP ]; int v ; int cnt ; void init () { memset ( nx , -1 , sizeof nx ); v = 0 ; cnt = 0 ; } } t [ N ]; int root , tot ; int newnode () { ++ tot ; t [ tot ]. init (); return tot ; } void init () { tot = 0 ; root = newnode (); } void insert ( char * s , int v ) { int len = strlen ( s ); int now = root ; for ( int i = 0 ; i < len ; ++ i ) { if ( t [ now ]. nx [ s [ i ] - 'a' ] == -1 ) { t [ now ]. nx [ s [ i ] - 'a' ] = newnode (); } now = t [ now ]. nx [ s [ i ] - 'a' ]; } t [ now ]. v += v ; t [ now ]. cnt ++ ; } int query ( char * s ) { int len = strlen ( s ); int now = root ; for ( int i = 0 ; i < len ; ++ i ) { int ch = s [ i ] - 'a' ; if ( t [ now ]. nx [ ch ] == -1 ) return -1 ; now = t [ now ]. nx [ ch ]; } if ( t [ now ]. cnt == 0 ) return -1 ; return t [ now ]. v ; } } trie ; ll gao () { ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { int len = 0 ; for ( int j = 1 ; j <= n ; ++ j ) { if ( t [ i ][ j ] == '#' ) { s [ len ] = 0 ; if ( len ) { int now = trie . query ( s ); if ( now == -1 ) return -1ll ; res += now ; } len = 0 ; } else { s [ len ] = t [ i ][ j ]; len ++ ; } } if ( len ) { s [ len ] = 0 ; int now = trie . query ( s ); if ( now == -1 ) return -1ll ; res += now ; } } for ( int i = 1 ; i <= n ; ++ i ) { int len = 0 ; for ( int j = 1 ; j <= n ; ++ j ) { if ( t [ j ][ i ] == '#' ) { s [ len ] = 0 ; if ( len ) { int now = trie . query ( s ); if ( now == -1 ) return -1ll ; res += now ; } len = 0 ; } else { s [ len ] = t [ j ][ i ]; len ++ ; } } if ( len ) { s [ len ] = 0 ; int now = trie . query ( s ); if ( now == -1 ) return -1ll ; res += now ; } } return res ; } int main () { int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%s\" , t [ i ] + 1 ); } trie . init (); for ( int i = 1 , v ; i <= m ; ++ i ) { scanf ( \"%s%d\" , s , & v ); trie . insert ( s , v ); } printf ( \"%lld \\n \" , gao ()); } return 0 ; } Problem D. Dividing the Points Upsolved By -. \u9898\u610f\uff1a \u601d\u8def\uff1a Problem E. Easy DP Problem Solved By all. 02:09(+) \u9898\u610f\uff1a \u7ed9\u51fa dp[i][j] dp[i][j] \u7684\u8f6c\u79fb\u8fc7\u7a0b\uff1a dp[i][j] = \\left\\{ \\begin{array}{c} 0 & (i = 0)\\\\ i^2 + dp[i - 1][j] & (i > 0, j = 0) \\\\ i^2 + \\max(dp[i - 1][j], dp[i - 1][j - 1] + b[i]) & (i > 0, j > 0) \\end{array} \\right. dp[i][j] = \\left\\{ \\begin{array}{c} 0 & (i = 0)\\\\ i^2 + dp[i - 1][j] & (i > 0, j = 0) \\\\ i^2 + \\max(dp[i - 1][j], dp[i - 1][j - 1] + b[i]) & (i > 0, j > 0) \\end{array} \\right. \u7136\u540e\u7ed9\u51fa n n \u4e2a\u6570 b_i b_i \uff0c\u6bcf\u6b21\u8be2\u95ee\u7ed9\u51fa l_i, r_i, k_i l_i, r_i, k_i \uff0c\u8981\u6c42\u7528 b_l, \\cdots, b_r b_l, \\cdots, b_r \u8fdb\u884c\u8f6c\u79fb, \u6c42 dp[m_i][k_i] dp[m_i][k_i] \u3002 \u601d\u8def\uff1a \u4e0d\u8003\u8651 i^2 i^2 \uff0c\u90a3\u4e48\u8fd9\u4e2a dp \u7684\u610f\u4e49\u662f\u627e\u51fa\u533a\u95f4\u5185\u6700\u5927\u7684 k k \u4e2a\u6570\u7684\u548c\u3002 \u7136\u540e\u5bf9\u4e8e i^2 i^2 \uff0c\u5b83\u6839\u672c\u4e0d\u4f1a\u5f71\u54cd dp \u8fc7\u7a0b\u3002 \u6240\u4ee5\u7528\u4e3b\u5e2d\u6811\u591a\u7ef4\u62a4\u4e00\u4e0b\u6570\u7684\u548c\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 1e5 + 10 ; int n , m , q ; int a [ N ], t [ N ]; ll f [ N ]; struct Hash { int a [ N ]; void init () { * a = 0 ; } int size () { return * a ; } void add ( int x ) { a [ ++* a ] = x ; } void gao () { sort ( a + 1 , a + 1 + * a ); * a = unique ( a + 1 , a + 1 + * a ) - a - 1 ; // cout << *a << endl; } int get ( int x ) { return lower_bound ( a + 1 , a + 1 + * a , x ) - a ; } } hs ; struct SEG { struct node { int ls , rs , sum ; ll S ; void init () { ls = rs = sum = 0 ; S = 0 ; } } t [ N * 50 ]; int tot ; ll res ; void init () { tot = 0 ; t [ tot ]. init (); } int newnode () { ++ tot ; t [ tot ]. init (); return tot ; } void build ( int & id , int l , int r ) { if ( ! id ) id = newnode (); if ( l == r ) return ; int mid = ( l + r ) >> 1 ; build ( t [ id ]. ls , l , mid ); build ( t [ id ]. rs , mid + 1 , r ); } void update ( int & rt , int l , int r , int pos , int v ) { int now = newnode (); t [ now ] = t [ rt ]; t [ now ]. sum += v ; t [ now ]. S += 1l l * hs . a [ pos ] * v ; if ( l == r ) { rt = now ; return ; } int mid = ( l + r ) >> 1 ; if ( pos <= mid ) update ( t [ now ]. ls , l , mid , pos , v ); else update ( t [ now ]. rs , mid + 1 , r , pos , v ); rt = now ; } void query ( int l_rt , int r_rt , int l , int r , int k ) { if ( l == r ) { // dbg(k, hs.a[l], res); res += 1l l * k * hs . a [ l ]; return ; } int mid = ( l + r ) >> 1 ; int lsum = t [ t [ l_rt ]. rs ]. sum , rsum = t [ t [ r_rt ]. rs ]. sum ; if ( rsum - lsum >= k ) { l_rt = t [ l_rt ]. rs ; r_rt = t [ r_rt ]. rs ; query ( l_rt , r_rt , mid + 1 , r , k ); } else { ll lS = t [ t [ l_rt ]. rs ]. S , rS = t [ t [ r_rt ]. rs ]. S ; res += rS - lS ; // dbg(lsum, rsum, lS, rS, res); l_rt = t [ l_rt ]. ls ; r_rt = t [ r_rt ]. ls ; query ( l_rt , r_rt , l , mid , k - ( rsum - lsum )); } } } seg ; int main () { f [ 0 ] = 0 ; for ( int i = 1 ; i < N ; ++ i ) { f [ i ] = f [ i - 1 ] + 1l l * i * i ; } int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d\" , & n ); hs . init (); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); hs . add ( a [ i ]); } hs . gao (); m = hs . size (); // dbg(m); // for (int i = 1; i <= m; ++i) dbg(i, hs.a[i]); seg . init (); t [ 0 ] = 0 ; seg . build ( t [ 0 ], 1 , m ); for ( int i = 1 ; i <= n ; ++ i ) { t [ i ] = t [ i - 1 ]; // dbg(i, hs.get(a[i])); seg . update ( t [ i ], 1 , m , hs . get ( a [ i ]), 1 ); } scanf ( \"%d\" , & q ); for ( int i = 1 , l , r , k ; i <= q ; ++ i ) { scanf ( \"%d%d%d\" , & l , & r , & k ); ll res = f [ r - l + 1 ]; seg . res = 0 ; seg . query ( t [ l - 1 ], t [ r ], 1 , m , k ); res += seg . res ; printf ( \"%lld \\n \" , res ); } } return 0 ; } Problem F. Finding a Sample Upsolved By -. \u9898\u610f\uff1a \u601d\u8def\uff1a Problem G. Gliding Solved By Hsueh- & ltslts. 03:33(+1) \u9898\u610f\uff1a \u7ed9\u51fa\u8d77\u70b9\u7ec8\u70b9\uff0c v_f, v_p, v_h v_f, v_p, v_h \uff0c\u8868\u793a\u4e0d\u5f00\u964d\u843d\u4f1e\u4e0b\u843d\u901f\u5ea6\uff0c\u5f00\u964d\u843d\u4f1e\u4e0b\u843d\u901f\u5ea6\uff0c\u6c34\u5e73\u79fb\u52a8\u901f\u5ea6\u3002 \u7ed9\u51fa n+1 n+1 \u4e2a\u70b9,\u6bcf\u4e2a\u70b9\u90fd\u6709\u4e00\u4e2a\u5411\u4e0a\u901f\u5ea6\u4e3a v_i v_i \u7684\u6c34\u6d41\uff0c\u5728\u7b2c i i \u4e2a\u6c34\u6d41\u4e0a\u7684\u901f\u5ea6\u4e3a v_i - v_p v_i - v_p \u3002 \u95ee\u8d77\u70b9\u5230\u7ec8\u70b9\u7684\u6700\u77ed\u65f6\u95f4\u3002 \u601d\u8def\uff1a \u5c06\u4e8c\u7ef4\u56fe\u8f6c\u5316\u4e3a\u7b80\u5355\u7684\u56fe\uff0c\u6bcf\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4e3a \\displaystyle \\frac{dis}{v_h} \\displaystyle \\frac{dis}{v_h} \u3002 \u53ef\u4ee5\u80af\u5b9a\u6bcf\u4e2a\u901f\u5ea6\u4e3a v_i v_i \u7684\u70b9\u4f1a\u5411\u901f\u5ea6\u66f4\u5927\u7684\u70b9\u79fb\u52a8\uff0c\u90a3\u4e48\u5f88\u663e\u7136\u5c06 n+1 n+1 \u4e2a\u70b9\u6309\u7167\u901f\u5ea6\u6392\u5e8f\uff0c\u7136\u540e\u4ece f[i] f[i] \u5411 f[j](i \\lt j) f[j](i \\lt j) \u8f6c\u79fb\uff0c\u6bcf\u6b21\u8f6c\u79fb\u65f6\u95f4\u4e3a\u6c34\u5e73\u79fb\u52a8\u65f6\u95f4\u4ee5\u53ca\u9700\u8981\u505c\u7559\u7684\u65f6\u95f4\u3002 \u7b80\u5355\u7684\u4e8c\u7ef4 dp dp \u65b9\u7a0b\u8f6c\u79fb\u4e00\u4e0b\u5373\u53ef\u3002 PS: \u6700\u77ed\u8def\u8fb9\u592a\u591a\u4e86\uff0c\u53ef\u80fd\u4f1a TLE \u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 4e3 + 10 ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } using db = double ; struct node { int x , y , h ; node () {} node ( int x , int y , int h ) : x ( x ), y ( y ), h ( h ) {} void input () { scanf ( \"%d %d %d\" , & x , & y , & h ); } bool operator < ( const node & other ) { return h < other . h ; } } a [ N ]; int n ; int sx , sy , ex , ey ; int vf , vp , vh ; db f [ N ]; db dis ( int i , int j ) { db res = ( a [ i ]. x - a [ j ]. x ) * ( a [ i ]. x - a [ j ]. x ) + ( a [ i ]. y - a [ j ]. y ) * ( a [ i ]. y - a [ j ]. y ); return sqrt ( res ); } db calc ( int i , int j ) { db t = dis ( i , j ) / vh ; db d = t * vp ; if ( a [ i ]. h - vp <= 0 ) return 1e9 ; t += d / ( a [ i ]. h - vp ); return t ; } int main () { int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d %d %d %d\" , & sx , & sy , & ex , & ey ); scanf ( \"%d %d %d\" , & vf , & vp , & vh ); scanf ( \"%d\" , & n ); ++ n ; for ( int i = 1 ; i <= n ; ++ i ) { a [ i ]. input (); } ++ n ; a [ n ] = node ( ex , ey , 100000 ); sort ( a + 1 , a + 1 + n ); for ( int i = 1 ; i <= n ; ++ i ) f [ i ] = 1e9 ; int st = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( a [ i ]. x == sx && a [ i ]. y == sy ) st = i ; } f [ st ] = 0 ; for ( int i = st ; i <= n ; ++ i ) { for ( int j = i + 1 ; j <= n ; ++ j ) { f [ j ] = min ( f [ j ], f [ i ] + calc ( i , j )); } } printf ( \"%.10f \\n \" , f [ n ]); } return 0 ; } Problem H. Huge Clouds Upsolved By -. \u9898\u610f\uff1a \u601d\u8def\uff1a Problem I. Invoking the Magic Solved By Hsueh- & ltslts. 00:16(+) \u9898\u610f\uff1a \u6709 n n \u5bf9\u889c\u5b50\uff0c\u6709\u4e00\u4e2a\u673a\u5668\u53ef\u4ee5\u5c06\u4e22\u8fdb\u53bb\u7684 x x \u5806\u889c\u5b50\u914d\u5bf9\u597d\uff0c\u95ee\u6700\u5c0f\u7684 x x \u3002 \u601d\u8def\uff1a \u7b7e\u5230\u3002 \u6c42\u8fde\u901a\u5757\u5927\u5c0f\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int n , tot ; int fa [ N ], sze [ N ], num [ N ]; map < int , int > mp ; int get ( int x ) { if ( mp . count ( x )) return mp [ x ]; mp [ x ] = ++ tot ; return tot ; } int find ( int x ) { return x == fa [ x ] ? fa [ x ] : fa [ x ] = find ( fa [ x ]); } void Union ( int x , int y ) { x = find ( x ), y = find ( y ); if ( x != y ) { if ( sze [ x ] > sze [ y ]) swap ( x , y ); fa [ y ] = x ; sze [ x ] += sze [ y ]; } } int main () { int T ; scanf ( \"%d\" , & T ); while ( T -- ) { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { sze [ i ] = 1 , num [ i ] = 0 , fa [ i ] = i ; } tot = 0 ; mp . clear (); for ( int i = 1 , u , v ; i <= n ; ++ i ) { scanf ( \"%d %d\" , & u , & v ); u = get ( u ), v = get ( v ); Union ( u , v ); } for ( int i = 1 ; i <= n ; ++ i ) { num [ find ( i )] ++ ; } int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) res = max ( res , num [ i ]); printf ( \"%d \\n \" , res ); } return 0 ; } Problem J. Just an Old Problem Upsolved By -. \u9898\u610f\uff1a \u601d\u8def\uff1a Problem K. Killing the Brute-forces Solved By Dup4. 00:14(+) \u9898\u610f\uff1a \u7b7e\u5230\u9898\u3002 \u601d\u8def\uff1a Code #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int a [ N ], b [ N ]; int main () { int _T ; cin >> _T ; while ( _T -- ) { int m ; scanf ( \"%d\" , & m ); for ( int i = 1 ; i <= m ; ++ i ) { scanf ( \"%d\" , a + i ); } for ( int i = 1 ; i <= m ; ++ i ) { scanf ( \"%d\" , b + i ); } int n = -1 ; for ( int i = 1 ; i <= m ; ++ i ) { if ( a [ i ] * 3 < b [ i ]) { n = i ; break ; } } printf ( \"%d \\n \" , n ); } return 0 ; } Problem L. List of Products Upsolved By -. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"\u7b2c 17 \u5c4a\u6d59\u6c5f\u7701\u7a0b\u5e8f\u8bbe\u8ba1\u7ade\u8d5b"},{"location":"onsite/17th-zjpsc/#contest-info","text":"Practice Link Solved A B C D E F G H I J K L 7/12 O O O - O - O ! O - O - O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5","title":"Contest Info"},{"location":"onsite/17th-zjpsc/#reply","text":"Dup4: \u676d\u7535\u771f\u5f3a\u3002 \u592a\u83dc\u4e86\u554a\uff0c\u8d5b\u65f6\u8fde\u533a\u95f4\u7b2c k k \u5927\u90fd\u4e0d\u77e5\u9053\u600e\u4e48\u6c42\u4e86\u554a\u3002 Hash \u8fd8\u662f Trie , \u50bb\u50bb\u5206\u4e0d\u6e05\u4e86\u554a\u3002 \u597d\u50cf\u9664\u4e86\u7b2c\u4e00\u5e74\u6253\u7701\u8d5b\u628a\u5361\u7740\u7684\u90a3\u4e00\u9898\u8fc7\u4e86\uff0c\u4e4b\u540e\u4e24\u5e74\u90fd\u6ca1\u8fc7\u554a\uff1f Hsueh-\uff1a \u8001\u4e86\u8be5\u9000\u5f79\u4e86\uff0c\u6bd4\u8d5b\u7684\u65f6\u5019\u5e76\u67e5\u96c6\u90fd\u5199\u7684\u4e00\u6123\u4e00\u6123\u7684\u3002 \u51e0\u4f55\u6c38\u8fdc\u51fa\u4e0d\u6765\uff0c\u613f\u5929\u5802\u6ca1\u6709\u8ba1\u7b97\u51e0\u4f55\u3002","title":"Reply"},{"location":"onsite/17th-zjpsc/#solutions","text":"","title":"Solutions"},{"location":"onsite/17th-zjpsc/#problem-a-ad-2020","text":"Solved By Dup4 & Hsueh-. 01:10(+) \u9898\u610f\uff1a \u5982\u679c\u4e00\u4e2a\u65e5\u671f\u5b57\u7b26\u4e32\u4e2d\u5305\u542b 202 \u8fd9\u4e2a\u5b50\u4e32\uff0c\u90a3\u4e48\u79f0\u5b83\u4e3a Disaster Reduction \u3002 \u7ed9\u51fa\u4e00\u4e2a\u8d77\u59cb\u65e5\u671f\u548c\u4e00\u4e2a\u7ec8\u6b62\u65e5\u671f\uff0c\u95ee\u8fd9\u4e4b\u95f4\u7684\u65e5\u671f\u6709\u591a\u5c11\u4e2a Disaster Reduction \uff1f \u601d\u8def\uff1a \u9884\u5904\u7406\u4e00\u4e0b\uff0c\u5904\u7406\u4e00\u4e2a\u8fb9\u8fb9\u89d2\u89d2\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int f [ N ]; int y [ 2 ], m [ 2 ], d [ 2 ]; int Mon [ 2 ][ 13 ] = { 0 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 , 0 , 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 }; bool isLeap ( int y ) { if ( y % 400 == 0 || ( y % 4 == 0 && y % 100 != 0 )) { return true ; } return false ; } int allD ( int y ) { if ( isLeap ( y )) return 366 ; else return 365 ; } int getAll ( int y ) { if ( y / 10 == 202 ) return allD ( y ); if ( y % 1000 == 202 ) return allD ( y ); int res = 1 ; if ( y % 10 == 2 ) { if ( isLeap ( y )) res += 1 ; res += 28 ; } else { res += 1 ; } return res ; } int calc ( int y , int m , int d ) { if ( y / 10 == 202 || y % 1000 == 202 ) { int res = 0 ; int ok = isLeap ( y ); for ( int i = 1 ; i < m ; ++ i ) { res += Mon [ ok ][ i ]; } res += d ; return res ; } int res = 0 ; if ( y % 10 == 2 ) { if ( m == 2 ) res += d ; else if ( m > 2 ) res += int ( isLeap ( y )) + 28 ; } else { if ( m == 2 && d >= 2 ) res += 1 ; else if ( m > 2 ) res += 1 ; } if ( m == 12 && d >= 2 ) res += 1 ; return res ; } int valid ( int y , int m , int d ) { if ( y / 10 == 202 || y % 1000 == 202 ) { return 1 ; } if ( m == 12 && d == 2 ) return 1 ; if ( y % 10 == 2 ) { if ( m == 2 ) return 1 ; } else { if ( m == 2 && d == 2 ) return 1 ; } return 0 ; } int main () { for ( int i = 2000 ; i <= 9999 ; ++ i ) { f [ i ] = f [ i - 1 ] + getAll ( i ); } // cout << f[9999] << endl; int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { for ( int i = 0 ; i < 2 ; ++ i ) { scanf ( \"%d %d %d\" , y + i , m + i , d + i ); } int l = y [ 0 ], r = y [ 1 ]; int res = 0 ; if ( l < r ) { res += f [ r - 1 ] - f [ l ]; } if ( l == r ) { res += calc ( y [ 1 ], m [ 1 ], d [ 1 ]) - calc ( y [ 0 ], m [ 0 ], d [ 0 ]) + valid ( y [ 0 ], m [ 0 ], d [ 0 ]); } else { res += calc ( y [ 0 ], 12 , 31 ) - calc ( y [ 0 ], m [ 0 ], d [ 0 ]) + valid ( y [ 0 ], m [ 0 ], d [ 0 ]); res += calc ( y [ 1 ], m [ 1 ], d [ 1 ]); } printf ( \"%d \\n \" , res ); } return 0 ; }","title":"Problem A. AD 2020"},{"location":"onsite/17th-zjpsc/#problem-b-bin-packing-problem","text":"Solved By all. 00:57(+) \u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u77f3\u5934\uff0c\u548c\u65e0\u9650\u4e2a\u5bb9\u91cf\u4e3a C C \u7684\u7bb1\u5b50\uff0c\u6bcf\u4e2a\u77f3\u5934\u7684\u5bb9\u91cf\u4e3a a_i a_i \u3002 \u73b0\u5728\u8981\u5c06\u77f3\u5934\u90fd\u653e\u8fdb\u7bb1\u5b50\u4e2d\uff0c\u73b0\u5728\u6709\u4e24\u79cd\u505a\u6cd5\uff1a \u5bf9\u4e8e\u7b2c i i \u4e2a\u77f3\u5934\uff1a \u6309\u987a\u5e8f\u904d\u5386\uff0c\u9047\u5230\u80fd\u653e\u7684\u5c31\u653e\u3002 \u627e\u4e00\u4e2a\u6700\u5c0f\u7684\u5e76\u4e14\u80fd\u653e\u4e0b\u7684\u7bb1\u5b50\uff0c\u5c06\u5f53\u524d\u7684\u77f3\u5934\u653e\u4e0b\u3002 \u6c42\u51fa\u4e24\u79cd\u505a\u6cd5\u5206\u522b\u6c42\u51fa\u6240\u9700\u7684\u7bb1\u5b50\u6570\u91cf\u3002 \u601d\u8def\uff1a \u7ebf\u6bb5\u6811\u7ef4\u62a4\u7bb1\u5b50\u5bb9\u91cf\u7684\u6700\u5927\u503c\uff0c\u4f18\u5148\u8d70\u5de6\u513f\u5b50\u3002 \u7528\u4e00\u4e2a set \u7ef4\u62a4\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e6 + 10 ; int n , C ; int a [ N ]; struct SEG { int t [ N << 2 ]; void build ( int id , int l , int r ) { t [ id ] = 0 ; if ( l == r ) { return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); } void update ( int id , int l , int r , int pos , int v ) { if ( l == r ) { t [ id ] += v ; return ; } int mid = ( l + r ) >> 1 ; if ( pos <= mid ) update ( id << 1 , l , mid , pos , v ); else update ( id << 1 | 1 , mid + 1 , r , pos , v ); t [ id ] = max ( t [ id << 1 ], t [ id << 1 | 1 ]); } int query ( int id , int l , int r , int v ) { if ( l == r ) return l ; int mid = ( l + r ) >> 1 ; if ( t [ id << 1 ] >= v ) return query ( id << 1 , l , mid , v ); return query ( id << 1 | 1 , mid + 1 , r , v ); } } seg ; int gao () { int m = 0 ; seg . build ( 1 , 1 , n ); seg . update ( 1 , 1 , n , m + 1 , C ); m += 1 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( seg . t [ 1 ] < a [ i ]) { seg . update ( 1 , 1 , n , m + 1 , C ); m += 1 ; } int pos = seg . query ( 1 , 1 , n , a [ i ]); seg . update ( 1 , 1 , n , pos , - a [ i ]); } return m ; } int gao1 () { multiset < int > se ; for ( int i = 1 ; i <= n ; ++ i ) { auto pos = se . lower_bound ( a [ i ]); if ( pos == se . end ()) { se . insert ( C ); pos = se . lower_bound ( a [ i ]); } int now = * pos - a [ i ]; se . erase ( pos ); se . insert ( now ); // cout << now << endl; } // cout << \"----\\n\"; // for (auto &it : se) // cout << it << endl; return int ( se . size ()); } int main () { int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d%d\" , & n , & C ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); } int A = gao (); int B = gao1 (); printf ( \"%d %d \\n \" , A , B ); } return 0 ; }","title":"Problem B. Bin Packing Problem"},{"location":"onsite/17th-zjpsc/#problem-c-crossword-validation","text":"Solved By Dup4 & Hsueh-. 02:57(+1) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a n \\cdot n n \\cdot n \u7684\u5b57\u7b26\u77e9\u9635\uff0c\u6a2a\u7740\u7ad6\u7740\u4ee5 # \u5206\u5272\u5f00\u82e5\u5e72\u4e2a\u5b57\u7b26\u4e32\uff0c\u518d\u7ed9\u51fa m m \u4e2a\u5b57\u5178\uff0c\u5e76\u4e14\u5b57\u5178\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u4e32\u90fd\u6709\u4ef7\u503c v_i v_i \u3002\u5b57\u5178\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u4e32\u90fd\u4e24\u4e24\u4e0d\u540c\u3002 \u73b0\u5728\u8981\u5c06\u4ee5 # \u5206\u5272\u5f00\u7684\u6bcf\u4e2a\u5b57\u7b26\u4e32\u627e\u5230\u5b57\u5178\u4e2d\u5bf9\u5e94\u5b57\u7b26\u4e32\u7684\u4ef7\u503c\u7d2f\u52a0\u8d77\u6765\u3002 \u5982\u679c\u51fa\u73b0\u4e00\u4e2a\u5b57\u7b26\u4e32\u672a\u51fa\u73b0\u5728\u5b57\u5178\u4e2d\uff0c\u90a3\u4e48\u8f93\u51fa -1 -1 \u3002 \u601d\u8def\uff1a \u76f4\u63a5\u5efa\u7acb\u4e00\u4e2a Trie \u5373\u53ef\uff0c\u521a\u5f00\u59cb\u5199\u4e86\u4e2a Hash \uff0c\u88ab\u5361\u4e86\u3002 \u800c\u4e14 Trie \u590d\u6742\u5ea6\u975e\u5e38\u6b63\u786e\uff0c\u53c8\u4e0d\u4f1a\u6709\u51b2\u7a81\u3002 \u542c\u8bf4\u81ea\u7136\u6ea2\u51fa\u8fc7\u4e86\uff1f Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 4e6 + 10 ; const int M = 1e3 + 10 ; const int ALP = 26 ; #define fi first #define se second int n , m ; char s [ N ]; char t [ M ][ M ]; struct Trie { struct node { int nx [ ALP ]; int v ; int cnt ; void init () { memset ( nx , -1 , sizeof nx ); v = 0 ; cnt = 0 ; } } t [ N ]; int root , tot ; int newnode () { ++ tot ; t [ tot ]. init (); return tot ; } void init () { tot = 0 ; root = newnode (); } void insert ( char * s , int v ) { int len = strlen ( s ); int now = root ; for ( int i = 0 ; i < len ; ++ i ) { if ( t [ now ]. nx [ s [ i ] - 'a' ] == -1 ) { t [ now ]. nx [ s [ i ] - 'a' ] = newnode (); } now = t [ now ]. nx [ s [ i ] - 'a' ]; } t [ now ]. v += v ; t [ now ]. cnt ++ ; } int query ( char * s ) { int len = strlen ( s ); int now = root ; for ( int i = 0 ; i < len ; ++ i ) { int ch = s [ i ] - 'a' ; if ( t [ now ]. nx [ ch ] == -1 ) return -1 ; now = t [ now ]. nx [ ch ]; } if ( t [ now ]. cnt == 0 ) return -1 ; return t [ now ]. v ; } } trie ; ll gao () { ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { int len = 0 ; for ( int j = 1 ; j <= n ; ++ j ) { if ( t [ i ][ j ] == '#' ) { s [ len ] = 0 ; if ( len ) { int now = trie . query ( s ); if ( now == -1 ) return -1ll ; res += now ; } len = 0 ; } else { s [ len ] = t [ i ][ j ]; len ++ ; } } if ( len ) { s [ len ] = 0 ; int now = trie . query ( s ); if ( now == -1 ) return -1ll ; res += now ; } } for ( int i = 1 ; i <= n ; ++ i ) { int len = 0 ; for ( int j = 1 ; j <= n ; ++ j ) { if ( t [ j ][ i ] == '#' ) { s [ len ] = 0 ; if ( len ) { int now = trie . query ( s ); if ( now == -1 ) return -1ll ; res += now ; } len = 0 ; } else { s [ len ] = t [ j ][ i ]; len ++ ; } } if ( len ) { s [ len ] = 0 ; int now = trie . query ( s ); if ( now == -1 ) return -1ll ; res += now ; } } return res ; } int main () { int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%s\" , t [ i ] + 1 ); } trie . init (); for ( int i = 1 , v ; i <= m ; ++ i ) { scanf ( \"%s%d\" , s , & v ); trie . insert ( s , v ); } printf ( \"%lld \\n \" , gao ()); } return 0 ; }","title":"Problem C. Crossword Validation"},{"location":"onsite/17th-zjpsc/#problem-d-dividing-the-points","text":"Upsolved By -. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"Problem D. Dividing the Points"},{"location":"onsite/17th-zjpsc/#problem-e-easy-dp-problem","text":"Solved By all. 02:09(+) \u9898\u610f\uff1a \u7ed9\u51fa dp[i][j] dp[i][j] \u7684\u8f6c\u79fb\u8fc7\u7a0b\uff1a dp[i][j] = \\left\\{ \\begin{array}{c} 0 & (i = 0)\\\\ i^2 + dp[i - 1][j] & (i > 0, j = 0) \\\\ i^2 + \\max(dp[i - 1][j], dp[i - 1][j - 1] + b[i]) & (i > 0, j > 0) \\end{array} \\right. dp[i][j] = \\left\\{ \\begin{array}{c} 0 & (i = 0)\\\\ i^2 + dp[i - 1][j] & (i > 0, j = 0) \\\\ i^2 + \\max(dp[i - 1][j], dp[i - 1][j - 1] + b[i]) & (i > 0, j > 0) \\end{array} \\right. \u7136\u540e\u7ed9\u51fa n n \u4e2a\u6570 b_i b_i \uff0c\u6bcf\u6b21\u8be2\u95ee\u7ed9\u51fa l_i, r_i, k_i l_i, r_i, k_i \uff0c\u8981\u6c42\u7528 b_l, \\cdots, b_r b_l, \\cdots, b_r \u8fdb\u884c\u8f6c\u79fb, \u6c42 dp[m_i][k_i] dp[m_i][k_i] \u3002 \u601d\u8def\uff1a \u4e0d\u8003\u8651 i^2 i^2 \uff0c\u90a3\u4e48\u8fd9\u4e2a dp \u7684\u610f\u4e49\u662f\u627e\u51fa\u533a\u95f4\u5185\u6700\u5927\u7684 k k \u4e2a\u6570\u7684\u548c\u3002 \u7136\u540e\u5bf9\u4e8e i^2 i^2 \uff0c\u5b83\u6839\u672c\u4e0d\u4f1a\u5f71\u54cd dp \u8fc7\u7a0b\u3002 \u6240\u4ee5\u7528\u4e3b\u5e2d\u6811\u591a\u7ef4\u62a4\u4e00\u4e0b\u6570\u7684\u548c\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 1e5 + 10 ; int n , m , q ; int a [ N ], t [ N ]; ll f [ N ]; struct Hash { int a [ N ]; void init () { * a = 0 ; } int size () { return * a ; } void add ( int x ) { a [ ++* a ] = x ; } void gao () { sort ( a + 1 , a + 1 + * a ); * a = unique ( a + 1 , a + 1 + * a ) - a - 1 ; // cout << *a << endl; } int get ( int x ) { return lower_bound ( a + 1 , a + 1 + * a , x ) - a ; } } hs ; struct SEG { struct node { int ls , rs , sum ; ll S ; void init () { ls = rs = sum = 0 ; S = 0 ; } } t [ N * 50 ]; int tot ; ll res ; void init () { tot = 0 ; t [ tot ]. init (); } int newnode () { ++ tot ; t [ tot ]. init (); return tot ; } void build ( int & id , int l , int r ) { if ( ! id ) id = newnode (); if ( l == r ) return ; int mid = ( l + r ) >> 1 ; build ( t [ id ]. ls , l , mid ); build ( t [ id ]. rs , mid + 1 , r ); } void update ( int & rt , int l , int r , int pos , int v ) { int now = newnode (); t [ now ] = t [ rt ]; t [ now ]. sum += v ; t [ now ]. S += 1l l * hs . a [ pos ] * v ; if ( l == r ) { rt = now ; return ; } int mid = ( l + r ) >> 1 ; if ( pos <= mid ) update ( t [ now ]. ls , l , mid , pos , v ); else update ( t [ now ]. rs , mid + 1 , r , pos , v ); rt = now ; } void query ( int l_rt , int r_rt , int l , int r , int k ) { if ( l == r ) { // dbg(k, hs.a[l], res); res += 1l l * k * hs . a [ l ]; return ; } int mid = ( l + r ) >> 1 ; int lsum = t [ t [ l_rt ]. rs ]. sum , rsum = t [ t [ r_rt ]. rs ]. sum ; if ( rsum - lsum >= k ) { l_rt = t [ l_rt ]. rs ; r_rt = t [ r_rt ]. rs ; query ( l_rt , r_rt , mid + 1 , r , k ); } else { ll lS = t [ t [ l_rt ]. rs ]. S , rS = t [ t [ r_rt ]. rs ]. S ; res += rS - lS ; // dbg(lsum, rsum, lS, rS, res); l_rt = t [ l_rt ]. ls ; r_rt = t [ r_rt ]. ls ; query ( l_rt , r_rt , l , mid , k - ( rsum - lsum )); } } } seg ; int main () { f [ 0 ] = 0 ; for ( int i = 1 ; i < N ; ++ i ) { f [ i ] = f [ i - 1 ] + 1l l * i * i ; } int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d\" , & n ); hs . init (); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); hs . add ( a [ i ]); } hs . gao (); m = hs . size (); // dbg(m); // for (int i = 1; i <= m; ++i) dbg(i, hs.a[i]); seg . init (); t [ 0 ] = 0 ; seg . build ( t [ 0 ], 1 , m ); for ( int i = 1 ; i <= n ; ++ i ) { t [ i ] = t [ i - 1 ]; // dbg(i, hs.get(a[i])); seg . update ( t [ i ], 1 , m , hs . get ( a [ i ]), 1 ); } scanf ( \"%d\" , & q ); for ( int i = 1 , l , r , k ; i <= q ; ++ i ) { scanf ( \"%d%d%d\" , & l , & r , & k ); ll res = f [ r - l + 1 ]; seg . res = 0 ; seg . query ( t [ l - 1 ], t [ r ], 1 , m , k ); res += seg . res ; printf ( \"%lld \\n \" , res ); } } return 0 ; }","title":"Problem E. Easy DP Problem"},{"location":"onsite/17th-zjpsc/#problem-f-finding-a-sample","text":"Upsolved By -. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"Problem F. Finding a Sample"},{"location":"onsite/17th-zjpsc/#problem-g-gliding","text":"Solved By Hsueh- & ltslts. 03:33(+1) \u9898\u610f\uff1a \u7ed9\u51fa\u8d77\u70b9\u7ec8\u70b9\uff0c v_f, v_p, v_h v_f, v_p, v_h \uff0c\u8868\u793a\u4e0d\u5f00\u964d\u843d\u4f1e\u4e0b\u843d\u901f\u5ea6\uff0c\u5f00\u964d\u843d\u4f1e\u4e0b\u843d\u901f\u5ea6\uff0c\u6c34\u5e73\u79fb\u52a8\u901f\u5ea6\u3002 \u7ed9\u51fa n+1 n+1 \u4e2a\u70b9,\u6bcf\u4e2a\u70b9\u90fd\u6709\u4e00\u4e2a\u5411\u4e0a\u901f\u5ea6\u4e3a v_i v_i \u7684\u6c34\u6d41\uff0c\u5728\u7b2c i i \u4e2a\u6c34\u6d41\u4e0a\u7684\u901f\u5ea6\u4e3a v_i - v_p v_i - v_p \u3002 \u95ee\u8d77\u70b9\u5230\u7ec8\u70b9\u7684\u6700\u77ed\u65f6\u95f4\u3002 \u601d\u8def\uff1a \u5c06\u4e8c\u7ef4\u56fe\u8f6c\u5316\u4e3a\u7b80\u5355\u7684\u56fe\uff0c\u6bcf\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4e3a \\displaystyle \\frac{dis}{v_h} \\displaystyle \\frac{dis}{v_h} \u3002 \u53ef\u4ee5\u80af\u5b9a\u6bcf\u4e2a\u901f\u5ea6\u4e3a v_i v_i \u7684\u70b9\u4f1a\u5411\u901f\u5ea6\u66f4\u5927\u7684\u70b9\u79fb\u52a8\uff0c\u90a3\u4e48\u5f88\u663e\u7136\u5c06 n+1 n+1 \u4e2a\u70b9\u6309\u7167\u901f\u5ea6\u6392\u5e8f\uff0c\u7136\u540e\u4ece f[i] f[i] \u5411 f[j](i \\lt j) f[j](i \\lt j) \u8f6c\u79fb\uff0c\u6bcf\u6b21\u8f6c\u79fb\u65f6\u95f4\u4e3a\u6c34\u5e73\u79fb\u52a8\u65f6\u95f4\u4ee5\u53ca\u9700\u8981\u505c\u7559\u7684\u65f6\u95f4\u3002 \u7b80\u5355\u7684\u4e8c\u7ef4 dp dp \u65b9\u7a0b\u8f6c\u79fb\u4e00\u4e0b\u5373\u53ef\u3002 PS: \u6700\u77ed\u8def\u8fb9\u592a\u591a\u4e86\uff0c\u53ef\u80fd\u4f1a TLE \u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 4e3 + 10 ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } using db = double ; struct node { int x , y , h ; node () {} node ( int x , int y , int h ) : x ( x ), y ( y ), h ( h ) {} void input () { scanf ( \"%d %d %d\" , & x , & y , & h ); } bool operator < ( const node & other ) { return h < other . h ; } } a [ N ]; int n ; int sx , sy , ex , ey ; int vf , vp , vh ; db f [ N ]; db dis ( int i , int j ) { db res = ( a [ i ]. x - a [ j ]. x ) * ( a [ i ]. x - a [ j ]. x ) + ( a [ i ]. y - a [ j ]. y ) * ( a [ i ]. y - a [ j ]. y ); return sqrt ( res ); } db calc ( int i , int j ) { db t = dis ( i , j ) / vh ; db d = t * vp ; if ( a [ i ]. h - vp <= 0 ) return 1e9 ; t += d / ( a [ i ]. h - vp ); return t ; } int main () { int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d %d %d %d\" , & sx , & sy , & ex , & ey ); scanf ( \"%d %d %d\" , & vf , & vp , & vh ); scanf ( \"%d\" , & n ); ++ n ; for ( int i = 1 ; i <= n ; ++ i ) { a [ i ]. input (); } ++ n ; a [ n ] = node ( ex , ey , 100000 ); sort ( a + 1 , a + 1 + n ); for ( int i = 1 ; i <= n ; ++ i ) f [ i ] = 1e9 ; int st = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( a [ i ]. x == sx && a [ i ]. y == sy ) st = i ; } f [ st ] = 0 ; for ( int i = st ; i <= n ; ++ i ) { for ( int j = i + 1 ; j <= n ; ++ j ) { f [ j ] = min ( f [ j ], f [ i ] + calc ( i , j )); } } printf ( \"%.10f \\n \" , f [ n ]); } return 0 ; }","title":"Problem G. Gliding"},{"location":"onsite/17th-zjpsc/#problem-h-huge-clouds","text":"Upsolved By -. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"Problem H. Huge Clouds"},{"location":"onsite/17th-zjpsc/#problem-i-invoking-the-magic","text":"Solved By Hsueh- & ltslts. 00:16(+) \u9898\u610f\uff1a \u6709 n n \u5bf9\u889c\u5b50\uff0c\u6709\u4e00\u4e2a\u673a\u5668\u53ef\u4ee5\u5c06\u4e22\u8fdb\u53bb\u7684 x x \u5806\u889c\u5b50\u914d\u5bf9\u597d\uff0c\u95ee\u6700\u5c0f\u7684 x x \u3002 \u601d\u8def\uff1a \u7b7e\u5230\u3002 \u6c42\u8fde\u901a\u5757\u5927\u5c0f\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int n , tot ; int fa [ N ], sze [ N ], num [ N ]; map < int , int > mp ; int get ( int x ) { if ( mp . count ( x )) return mp [ x ]; mp [ x ] = ++ tot ; return tot ; } int find ( int x ) { return x == fa [ x ] ? fa [ x ] : fa [ x ] = find ( fa [ x ]); } void Union ( int x , int y ) { x = find ( x ), y = find ( y ); if ( x != y ) { if ( sze [ x ] > sze [ y ]) swap ( x , y ); fa [ y ] = x ; sze [ x ] += sze [ y ]; } } int main () { int T ; scanf ( \"%d\" , & T ); while ( T -- ) { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { sze [ i ] = 1 , num [ i ] = 0 , fa [ i ] = i ; } tot = 0 ; mp . clear (); for ( int i = 1 , u , v ; i <= n ; ++ i ) { scanf ( \"%d %d\" , & u , & v ); u = get ( u ), v = get ( v ); Union ( u , v ); } for ( int i = 1 ; i <= n ; ++ i ) { num [ find ( i )] ++ ; } int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) res = max ( res , num [ i ]); printf ( \"%d \\n \" , res ); } return 0 ; }","title":"Problem I. Invoking the Magic"},{"location":"onsite/17th-zjpsc/#problem-j-just-an-old-problem","text":"Upsolved By -. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"Problem J. Just an Old Problem"},{"location":"onsite/17th-zjpsc/#problem-k-killing-the-brute-forces","text":"Solved By Dup4. 00:14(+) \u9898\u610f\uff1a \u7b7e\u5230\u9898\u3002 \u601d\u8def\uff1a Code #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int a [ N ], b [ N ]; int main () { int _T ; cin >> _T ; while ( _T -- ) { int m ; scanf ( \"%d\" , & m ); for ( int i = 1 ; i <= m ; ++ i ) { scanf ( \"%d\" , a + i ); } for ( int i = 1 ; i <= m ; ++ i ) { scanf ( \"%d\" , b + i ); } int n = -1 ; for ( int i = 1 ; i <= m ; ++ i ) { if ( a [ i ] * 3 < b [ i ]) { n = i ; break ; } } printf ( \"%d \\n \" , n ); } return 0 ; }","title":"Problem K. Killing the Brute-forces"},{"location":"onsite/17th-zjpsc/#problem-l-list-of-products","text":"Upsolved By -. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"Problem L. List of Products"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Announcement/","text":"The Hangzhou Normal U Qualification Trials for Zhejiang Provincial Collegiate Programming Contest 2020 Announcement Hello everyone! There will be 13 13 problems and we will given 4 4 hours 20 20 minutes to solve them. In the last 52 52 minutes , the standings will be frozend. The language of the statement is English and each team will be distributed 3 3 copies printed statements. During the contest, if nothing happens, we will provide code printing function and Clarifications , you can find them in contest page easily. What you need to pay attention to is that if you have any questions about the statements during the contest, please ask questions in English. You need to obverse the following rules: Each team can only use one computer. Each team can carry any paper materials. We will provided a PDF version of KUANGBIN-ACM/ICPC-TEMPLATE-2018 , you can use it in your computer. In addition, you cannot use any other electronic materials. If you are not confident in your English reading ability, we recommend you bring a dictionary. The contest will take place on Wednesday, September 16, 2020 at 13:00 . If you have an urgent matter, you can leave early 30 30 minutes after the start of the contest. The final interpretation right belongs to the head coach Zhenyu Shan. The problem were created by Dup4 , Hsueh- and lts . Thanks to MikeMirzayanov for the Codeforces and Polygon platforms. We tried to make interesting problems, short statements, useful samples and strong datatests, and we hope you will like it. The domain name of the contest page is hznu.cc . To prevent accidents, we have prepared 3 3 additional alternate domain names: t1.dup4.top t2.dup4.top t3.dup4.top Behind these four domain names are four different links to the Codeforces server in Russia, which may have different effects in different network environments. In theory, hznu.cc is the fastest. But when it can't get in, we recommend you to try an alternate domain name, it may be useful. In order for everyone to adapt to the competition platform in advance, we have prepared a warm-up contest. The warm-up contest will take place on Thursday, September 10, 2020 at 12:00 , and the duration is 5 5 days . You can experience the code printing function and Clarifications . We sincerely recommend you to try the interactive problem in the warm-up contest, if you have never tried interactive problem . The account of the warm-up contest will be given below, but the account of the official contest will be distributed on the venue. Please do not sign in with your own codeforces account\uff0cor you will be redirected to strange places. The account of the warm-up contest Handle Password Name team2943441 VJWPV5 HZNU_kindergarten - \u5305\u654f\u3001\u5b59\u5468\u6bc5\u3001\u9b4f\u709c team2943442 JLETVU Fingertip melody - \u8c22\u4f5c\u6770\u3001\u5362\u9716\u7edf\u3001\u6768\u660c\u6797 team2943443 1PF4E9 HZNU_Tourists - \u5f20\u51ef\u8389\u3001\u90b1\u9f99\u98ce\u3001\u5f20\u4f20 team2943444 RSSH87 Schroedinger's Pig - \u6731\u6e56\u5065\u3001\u9646\u5bb6\u8f89\u3001\u6881\u6587\u535a team2943445 T4CYNZ Cabbage - \u65bd\u9a8f\u709c\u3001\u9648\u601d\u6b23\u3001\u6bdb\u6631\u6ee2 team2943446 QANPIR Three Fruits - \u6e29\u94ed\u6d69\u3001\u9b4f\u4f9d\u6d0b\u3001\u674e\u6d69\u7136 team2943447 1P2QX5 pupil NB - \u4fde\u4f73\u6743\u3001\u738b\u51cc\u8a00\u3001\u949f\u607a team2943448 KKLM3R washing washing sleeping - \u4f55\u9648\u806a\u3001\u4ed8\u4fca\u3001\u674e\u9a8b team2943449 2GA887 Kitten Marine Corp - \u5218\u6052\u7fbd\u3001\u53f6\u521d\u822a\u3001\u5468\u5a49\u5a67 team29434410 PHLKVY yingyingying - \u90b5\u94c1\u592b\u3001\u6e29\u58f0\u8363\u3001\u82cf\u6850\u6e24 team29434411 C4Z8F1 O (n!) -> O (1)- \u5f20\u67a8\u3001\u9648\u67ef\u6d9b\u3001\u5434\u9648\u5b87 team29434412 PXSMB9 acwork - \u5168\u632f\u5b87\u3001\u5b8b\u535a\u5e06\u3001\u738b\u827a\u84c9 team29434413 WKWU7Z NULL - \u6797\u5cf0\u3001\u6881\u6db5\u6770\u3001\u5f90\u5149\u6cfd team29434414 EI9JDW Turing - \u9648\u96e8\u6b23\u3001\u5468\u73c8\u4f0a\u3001\u5f90\u8c6a\u6770 team29434415 ZUXS5V play snake - \u674e\u5f66\u5e86\u3001\u6768\u4e91\u9f99\u3001\u6797\u6cd3\u4f7a team29434416 92PZU7 Fried tomatoes - \u6bdb\u6f5c\u98de\u3001\u65b9\u4e00\u660a\u3001\u53f6\u4fca team29434417 R9LWB2 dancing lightning - \u5f90\u6d69\u7136\u3001\u6881\u96e8\u6b23\u3001\u6768\u5e06 team29434418 NW5CY4 non-prepared guys - \u8521\u6797\u8fbe\u3001\u9ad8\u7b11\u82b8\u3001\u5218\u5174\u677e The editorial will be posted shortly after the contest (it is already written). Good luck!","title":"The Hangzhou Normal U Qualification Trials for Zhejiang Provincial Collegiate Programming Contest 2020 Announcement"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/","text":"The Hangzhou Normal U Qualification Trials for Zhejiang Provincial Collegiate Programming Contest 2020 Editorial Contents Our Sponsor Thanks Talks Materials Solutions A. A simple problem \u9898\u610f \u601d\u8def B. Hsueh- play balls \u9898\u610f \u601d\u8def C. Hoogle Machine Translation \u9898\u610f \u601d\u8def D. Dup4 and pebble pile \u9898\u610f \u601d\u8def E. The King of Sum Xor \u9898\u610f \u601d\u8def F. Hsueh- Love Matrix \u9898\u610f \u601d\u8def G. LTS owns large quantities of apples \u9898\u610f \u601d\u8def H. Hsueh- and keyboard \u9898\u610f \u601d\u8def I. LTS and rectangular area union \u9898\u610f \u601d\u8def J. Hsueh- owns large quantities of apples \u9898\u610f \u601d\u8def K. LTS buy wine \u9898\u610f \u601d\u8def L. Line problem \u9898\u610f \u601d\u8def M. Rikka with Random Graph \u9898\u610f \u601d\u8def Our Sponsor \u672c\u573a\u6bd4\u8d5b\u7531 DMI\uff08\u6570\u5b57\u5a92\u4f53\u4e0e\u4eba\u673a\u4ea4\u4e92\uff09\u4e2d\u5fc3\u8d5e\u52a9\u3002 DMI \u4e2d\u5fc3\u4e3b\u8981\u7814\u7a76\u65b9\u5411\uff1a \u667a\u80fd\u89c6\u9891\u7f16\u7801\uff1a\u501f\u52a9\u4e8e\u6df1\u5ea6\u5b66\u4e60\u6280\u672f\uff0c\u5c06\u5176\u5e94\u7528\u4e8e\u89c6\u9891\u7f16\u7801\u4e2d\uff0c\u63d0\u9ad8\u538b\u7f29\u6548\u7387\u3002 \u56fe\u50cf\u8d28\u91cf\u589e\u5f3a\uff1a\u501f\u52a9\u4e8e\u673a\u5668\u5b66\u4e60\uff0c\u63d0\u9ad8\u53d7\u635f\u56fe\u50cf\u4e3b\u5ba2\u89c2\u8d28\u91cf\u6216\u5206\u8fa8\u7387\u3002 \u89c6\u9891\u7f16\u7801\u7b97\u6cd5\u4f18\u5316\uff1a\u8bbe\u8ba1\u5feb\u901f\u7b97\u6cd5\uff0c\u5728\u4fdd\u8bc1\u89c6\u9891\u7f16\u7801\u6548\u7387\u7684\u540c\u65f6\u63d0\u9ad8\u7f16\u7801\u901f\u5ea6\u3002 DMI \u4e2d\u5fc3\u62e5\u6709\uff1a 100 \u5e73\u7c73\u7684\u5b9e\u9a8c\u5ba4\u3002 20 \u53f0\u53ef\u8fdb\u884c\u6df1\u5ea6\u5b66\u4e60\u7684\u673a\u5668\uff0c2080TI \u662f\u6807\u914d\u3002 DMI \u4e2d\u5fc3\u8054\u7cfb\u4eba\uff1a \u4e01\u4e39\u4e39\u8001\u5e08\uff0c\u6d59\u6c5f\u5927\u5b66\u535a\u58eb\u5b66\u4f4d\u3002 QQ: 187113186 Email: DandanDing@hznu.edu.cn Thanks \u611f\u8c22\u6240\u6709\u9a8c\u9898\u4eba\u7ed9\u6211\u4eec\u63d0\u51fa\u7684\u5b9d\u8d35\u7684\u610f\u89c1\u3002 Talks \u8fd9\u4e2a\u968f\u673a\u4f1a\u4e0d\u4f1a\u88ab\u4eba\u6253\u6b7b\u3002 \u679c\u7136\u300c\u597d\u9898\u76ee\u662f\u6539\u51fa\u6765\u7684\u300d\uff0c\u5f53\u4f60\u611f\u89c9\u826f\u597d\u7684\u65f6\u5019\uff0c\u603b\u6709\u9a8c\u9898\u4eba\u6765\u7ed9\u4f60\u5f53\u5934\u68d2\u559d\uff0c\u8fd9\u91cc\u7684\u300c\u597d\u300d\u6307\u7684\u662f\u9898\u9762\u9610\u8ff0\u6e05\u695a\uff0c\u6570\u636e\u5065\u58ee\uff0c\u800c\u975e\u300c\u597d\u9898\u300d\uff08\u9003\u3002 Materials PRACTICE LINK account Handle Password Name team2950361 16PGIH HZNU_kindergarten-C5-\u5305\u654f\u3001\u5b59\u5468\u6bc5\u3001\u9b4f\u709c team2950362 4R3PJ9 Fingertip melody-D3-\u8c22\u4f5c\u6770\u3001\u5362\u9716\u7edf\u3001\u6768\u660c\u6797 team2950363 5I1SMD HZNU_Tourists-A3-\u5f20\u51ef\u8389\u3001\u90b1\u9f99\u98ce\u3001\u5f20\u4f20 team2950364 53BJ3G Schroedinger's Pig-C1-\u6731\u6e56\u5065\u3001\u9646\u5bb6\u8f89\u3001\u6881\u6587\u535a team2950365 6AERHL Cabbage-B5-\u65bd\u9a8f\u709c\u3001\u9648\u601d\u6b23\u3001\u6bdb\u6631\u6ee2 team2950366 GVKNB4 Three Fruits-D5-\u6e29\u94ed\u6d69\u3001\u9b4f\u4f9d\u6d0b\u3001\u674e\u6d69\u7136 team2950367 XGFX11 pupil NB-C3-\u4fde\u4f73\u6743\u3001\u738b\u51cc\u8a00\u3001\u949f\u607a team2950368 UJVQEJ washing washing sleeping -D2-\u4f55\u9648\u806a\u3001\u4ed8\u4fca\u3001\u674e\u9a8b team2950369 UZHKAE Kitten Marine Corp-A4-\u5218\u6052\u7fbd\u3001\u53f6\u521d\u822a\u3001\u5468\u5a49\u5a67 team29503610 IDM6ND yingyingying-B4-\u90b5\u94c1\u592b\u3001\u6e29\u58f0\u8363\u3001\u82cf\u6850\u6e24 team29503611 ZEXXUY O(n!) -> O(1)-C4-\u5f20\u67a8\u3001\u9648\u67ef\u6d9b\u3001\u5434\u9648\u5b87 team29503612 YQ2QQH acwork-A2-\u5168\u632f\u5b87\u3001\u5b8b\u535a\u5e06\u3001\u738b\u827a\u84c9 team29503613 GI9PXJ NULL-B1-\u6797\u5cf0\u3001\u6881\u6db5\u6770\u3001\u5f90\u5149\u6cfd team29503614 C82J2C Turing-D4-\u9648\u96e8\u6b23\u3001\u5468\u73c8\u4f0a\u3001\u5f90\u8c6a\u6770 team29503615 2S3CJB play snake-B2-\u674e\u5f66\u5e86\u3001\u6768\u4e91\u9f99\u3001\u6797\u6cd3\u4f7a team29503616 2ZFGJA Fried tomatoes-C2-\u6bdb\u6f5c\u98de\u3001\u65b9\u4e00\u660a\u3001\u53f6\u4fca team29503617 H8ZIP2 dancing lightning-B3-\u5f90\u6d69\u7136\u3001\u6881\u96e8\u6b23\u3001\u6768\u5e06 team29503618 2R6WYC non-prepared guys-A5-\u8521\u6797\u8fbe\u3001\u9ad8\u7b11\u82b8\u3001\u5218\u5174\u677e Solutions A. A simple problem \u9898\u610f \u7ed9\u51fa 0-n 0-n \u7684\u5168\u6392\u5217\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u6392\u5217\u5c06\u6bcf\u4e2a\u6570\u5b57\u4e32\u8d77\u6765\u7ec4\u6210\u65b0\u7684\u6574\u6570\uff0c\u95ee\u4e0d\u542b\u524d\u5bfc\u96f6\u4e14\u88ab m m \u6574\u9664\u6709\u591a\u5c11\u4e2a\u6570\u5b57 \u601d\u8def \u770b\u6570\u636e\u8303\u56f4\u7ecf\u5178\u72b6\u538b dp dp , dp[S][i] dp[S][i] \u8868\u793a\u5df2\u7ecf\u7528\u4e86\u7684\u6570\u5b57\u72b6\u6001\u4e3a S S , \u4f59\u6570\u4e3a i i \u7684\u4e2a\u6570\uff0c\u6bcf\u6b21\u679a\u4e3e\u6ca1\u7528\u8fc7\u7684\u6570\u5b57\u5411\u4e0b\u63a8\u5373\u53ef\uff08\u53ef\u53c2\u8003\u5927\u6574\u6570\u53d6\u4f59\uff09\uff0c\u5f53\u7136\u6ce8\u610f 10,11,12,13,14,15 10,11,12,13,14,15 \u90fd\u662f\u4e24\u4f4d\u6570 Code #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } #define endl \"\\n\" #define all(A) A.begin(), A.end() using ll = long long ; using db = double ; using pII = pair < int , int > ; const int INF = 0x3f3f3f3f ; const ll INFLL = 0x3f3f3f3f3f3f3f3f ; const int N = 16 , M = 100 ; int n , m ; ll f [ 1 << N ][ M ]; void RUN () { cin >> n >> m ; ++ n ; f [ 0 ][ 0 ] = 1 ; int limit = 1 << n ; for ( int S = 0 ; S < limit ; ++ S ) { for ( int i = 0 ; i < n ; ++ i ) { if ( S & ( 1 << i )) continue ; if ( S == 0 && i == 0 ) continue ; int nxt = S | ( 1 << i ); for ( int j = 0 ; j < m ; ++ j ) { if ( i >= 10 ) { f [ nxt ][( j * 100 + i ) % m ] += f [ S ][ j ]; } else { f [ nxt ][( j * 10 + i ) % m ] += f [ S ][ j ]; } } } } cout << f [ limit - 1 ][ 0 ] << endl ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ), cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); RUN (); return 0 ; } B. Hsueh- play balls \u9898\u610f \u6709 n n \u4e2a\u767d\u7403\u548c m m \u4e2a\u9ed1\u7403\u5728\u76d2\u5b50\u91cc\uff0c\u6bcf\u6b21\u4ece\u4e2d\u53d6\u51fa\u4e00\u4e2a\u7403\u5230\u76d2\u5b50\u5916\uff0c\u95ee\u53d6\u7403\u8fc7\u7a0b\u4e2d\u5c06\u6240\u6709\u7403\u53d6\u51fa\u7684\u8fc7\u7a0b\u4e2d\u76d2\u5b50\u5916\u7684\u7403\u4e2d\uff0c\u767d\u7403\u4e2a\u6570\u548c\u9ed1\u7403\u4e2a\u6570\u81f3\u5c11\u6709\u4e00\u6b21\u76f8\u7b49\u7684\u6982\u7387\u662f\u591a\u5c11\uff1f \u601d\u8def \u7b54\u6848\u662f\uff1a \\begin{eqnarray*} \\Large \\frac{{n + m \\choose n} - {n + m - 1 \\choose n - 1} - {n + m - 1 \\choose m - 1}}{{n + m \\choose n}} \\end{eqnarray*} \\begin{eqnarray*} \\Large \\frac{{n + m \\choose n} - {n + m - 1 \\choose n - 1} - {n + m - 1 \\choose m - 1}}{{n + m \\choose n}} \\end{eqnarray*} \u8003\u8651\u6b64\u5904\u6982\u7387\u5c31\u662f \\displaystyle \\frac{\\mbox{\u5408\u6cd5\u7684\u65b9\u6848\u6570}}{\\mbox{\u603b\u65b9\u6848\u6570}} \\displaystyle \\frac{\\mbox{\u5408\u6cd5\u7684\u65b9\u6848\u6570}}{\\mbox{\u603b\u65b9\u6848\u6570}} \u3002 \u603b\u65b9\u6848\u6570\u663e\u7136\u662f \\displaystyle {n + m \\choose n} \\displaystyle {n + m \\choose n} \u3002 \u5408\u6cd5\u7684\u65b9\u6848\u6570\u662f\u4ec0\u4e48\uff0c\u5c31\u662f\u53d6\u7403\u8fc7\u7a0b\u4e2d\u767d\u7403\u4e2a\u6570\u548c\u9ed1\u7403\u4e2a\u6570\u81f3\u5c11\u6709\u4e00\u6b21\u76f8\u7b49\u7684\u65b9\u6848\uff0c\u8003\u8651\u53cd\u9762\uff0c\u5c31\u662f \\mbox{\u603b\u65b9\u6848\u6570} - \\mbox{\u53d6\u7403\u8fc7\u7a0b\u4e2d\u767d\u7403\u4e2a\u6570\u548c\u9ed1\u7403\u4e2a\u6570\u4e00\u6b21\u90fd\u4e0d\u76f8\u7b49\u7684\u65b9\u6848} \\mbox{\u603b\u65b9\u6848\u6570} - \\mbox{\u53d6\u7403\u8fc7\u7a0b\u4e2d\u767d\u7403\u4e2a\u6570\u548c\u9ed1\u7403\u4e2a\u6570\u4e00\u6b21\u90fd\u4e0d\u76f8\u7b49\u7684\u65b9\u6848} \u3002 \u6211\u4eec\u4e0d\u59a8\u4ee4 n \\geq m n \\geq m : \u9996\u5148\u6211\u4eec\u9700\u8981\u4e24\u6761\u9884\u5907\u77e5\u8bc6\uff1a \u4ece (0, 0) (0, 0) \u5230 (n, m) (n, m) \u7684\u975e\u964d\u8def\u5f84\u6761\u6570\uff1a \\displaystyle {n + m \\choose n} \\displaystyle {n + m \\choose n} \u4ece (s, t) (s, t) \u5230 (n, m) (n, m) \u7684\u975e\u964d\u8def\u5f84\u6761\u6570\uff1a \\displaystyle {n + m - s - t \\choose n - s} \\displaystyle {n + m - s - t \\choose n - s} \u90a3\u4e48\u6211\u4eec\u8f6c\u5316\u4e00\u4e0b\uff0c\u770b\u6210\u5750\u6807\u7cfb\u4e2d\uff0c\u4ece (0, 0) (0, 0) \u8d70\u5230 (n, m) (n, m) , \u53d6\u767d\u7403\u770b\u6210\u5411\u4e0a\u8d70\uff0c\u53d6\u9ed1\u7403\u770b\u6210\u5411\u53f3\u8d70\uff0c\u90a3\u4e48\u4efb\u610f\u65f6\u523b\u5411\u4e0a\u8d70\u7684\u6b65\u6570\u4e0d\u80fd\u5c0f\u4e8e\u5411\u53f3\u8d70\u7684\u6b65\u6570\uff0c\u5373\u4e0d\u7ecf\u8fc7 y = x y = x \uff08\u4e0d\u5305\u62ec (0, 0) (0, 0) \u8fd9\u4e2a\u70b9\uff09\u3002 \u603b\u7684\u60c5\u51b5\u6570\u4e3a \\displaystyle {n + m \\choose n} \\displaystyle {n + m \\choose n} (0, 0) (0, 0) \u5148\u5411\u4e0a\u8d70\u5230 (0, 1) (0, 1) \uff0c\u90a3\u4e48\u5230\u7ec8\u70b9 (n, m) (n, m) \u4e00\u5b9a\u4f1a\u7ecf\u8fc7 y = x y = x \u8fd9\u6761\u76f4\u7ebf\uff0c\u8fd9\u79cd\u975e\u6cd5\u60c5\u51b5\u4e3a (0, 1) (0, 1) \u5230 (n, m) (n, m) \u7684\u975e\u964d\u8def\u5f84\u6761\u6570 \\displaystyle {n + m - 1 \\choose n} \\displaystyle {n + m - 1 \\choose n} \u4ece (0, 0) (0, 0) \u5411\u53f3\u8d70\u5230 (1, 0) (1, 0) \uff0c\u8fd9\u65f6\u5019\u6709\u4e24\u79cd\u60c5\u51b5\uff0c\u4e00\u79cd\u60c5\u51b5\u662f\u5408\u6cd5\u7684\uff0c\u53e6\u4e00\u79cd\u60c5\u51b5\u8fd8\u662f\u4f1a\u7ecf\u8fc7 y = x y = x \uff0c\u8fd9\u65f6\u5019\u8bb0\u8be5\u8def\u7ebf\u4e00\u6b21\u7ecf\u8fc7 y = x y = x \u7684\u70b9\u4e3a C C \uff0c\u5c06 (1, 0) (1, 0) \u5230\u70b9 C C \u95f4\u7684\u8def\u5f84\u5173\u4e8e y = x y = x \u5bf9\u79f0\uff0c\u53ef\u4ee5\u5f97\u5230\u4e0e\u60c5\u51b5 2 2 \u7684\u4e00\u4e00\u6620\u5c04\uff0c\u5373\u4e0d\u5408\u6cd5\u60c5\u51b5\u7684\u8def\u5f84\u6761\u6570\u4e3a \\displaystyle {n + m - 1 \\choose n} \\displaystyle {n + m - 1 \\choose n} \u6240\u4ee5\u603b\u7684\u6ee1\u8db3\u6761\u4ef6\u7684\u8def\u5f84\u6761\u6570\u4e3a \\displaystyle {n + m \\choose n} - 2{n + m - 1 \\choose n} \\displaystyle {n + m \\choose n} - 2{n + m - 1 \\choose n} \u3002 \u4e5f\u53ef\u4ee5\u76f4\u63a5\u8003\u8651\u5f3a\u5236\u7b2c\u4e00\u6b65\u5f80\u53f3\u8d70\uff0c\u90a3\u4e48\u603b\u7684\u65b9\u6848\u6570\u4e3a \\displaystyle {n + m - 1 \\choose n - 1} \\displaystyle {n + m - 1 \\choose n - 1} \uff0c\u518d\u8003\u8651\u4e0a\u8ff0\u7684\u7b2c\u4e09\u79cd\u60c5\u51b5\u7684\u4e0d\u5408\u6cd5\u65b9\u6848\u6570\uff0c\u90a3\u4e48\u4e0d\u5408\u6cd5\u7684\u6709 \\displaystyle {n + m - 1 \\choose n} \\displaystyle {n + m - 1 \\choose n} \uff0c\u6240\u4ee5\u5408\u6cd5\u65b9\u6848\u6570\u4e3a \\displaystyle {n + m - 1 \\choose n - 1} - {n + m - 1 \\choose n} = {n + m - 1 \\choose n - 1} - {n + m - 1 \\choose m - 1} \\displaystyle {n + m - 1 \\choose n - 1} - {n + m - 1 \\choose n} = {n + m - 1 \\choose n - 1} - {n + m - 1 \\choose m - 1} Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 998244353 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 2e6 + 10 ; int n , m , fac [ N ], inv [ N ]; ll C ( int n , int m ) { if ( n < m ) return 0 ; return 1l l * fac [ n ] * inv [ n - m ] % mod * inv [ m ] % mod ; } void run () { rd ( n , m ); if ( n == m ) return pt ( 1 ); if ( n < m ) swap ( n , m ); ll tot = C ( n + m , n ); ll cur = ( C ( n + m - 1 , n - 1 ) - C ( n + m - 1 , m - 1 ) + mod ) % mod ; ll numerator = ( tot - cur + mod ) % mod ; ll denominator = tot ; // dbg(numerator, denominator); ll res = numerator * qpow ( denominator , mod - 2 ) % mod ; pt ( res ); } int main () { fac [ 0 ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) fac [ i ] = 1l l * fac [ i - 1 ] * i % mod ; inv [ N - 1 ] = qpow ( fac [ N - 1 ], mod - 2 ); for ( int i = N - 1 ; i >= 1 ; -- i ) inv [ i - 1 ] = 1l l * inv [ i ] * i % mod ; ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } C. Hoogle Machine Translation \u9898\u610f \u6709\u4e00\u4e2a\u7ffb\u8bd1\u673a\u5668\uff0c\u6bcf\u6b21\u80fd\u7ffb\u8bd1\u82e5\u5e72\u4e2a\u5355\u8bcd\uff0c\u4f46\u662f\u8fd4\u56de\u7684\u91ca\u4e49\u7684\u987a\u5e8f\u662f\u6df7\u4e71\u7684\uff0c\u73b0\u5728\u8981\u6c42\u5728 25 25 \u6b21\u8be2\u95ee\u5185\uff0c\u5f97\u51fa n(1 \\leq n \\leq 10^5) n(1 \\leq n \\leq 10^5) \u4e2a\u5355\u8bcd\u7684\u91ca\u4e49\u3002 \u601d\u8def \u505a\u6cd5\u4e00 \u663e\u7136\uff0c\u9700\u8981\u7528 \\log n \\log n \u6b21\u8be2\u95ee\u89e3\u51b3\u95ee\u9898\u3002 \u90a3\u4e48\u6211\u4eec\u5bf9\u6bcf\u4e2a\u5355\u8bcd\u4ece 1 1 \u5230 n n \u8fdb\u884c\u7f16\u53f7\uff0c\u90a3\u4e48\u6211\u4eec\u5728 \\log n \\log n \u6b21\u8be2\u95ee\u4e2d\uff0c\u5728\u7b2c i i \u6b21\u8be2\u95ee\uff0c\u5bf9\u4e8e 1 1 \u5230 n n \u4e2d\u7684\u7b2c j j \u4e2a\u5355\u8bcd\uff0c\u5982\u679c j j \u5728\u4e8c\u8fdb\u5236\u8868\u793a\u4e0b\uff0c\u7b2c i i \u4f4d\u4e0a\u4e3a 1 1 \uff0c\u90a3\u4e48\u5728\u8fd9\u6b21\u8be2\u95ee\u4e2d\uff0c\u6211\u4eec\u5c31\u5c06\u8fd9\u4e2a\u5355\u8bcd\u52a0\u5165\u8be2\u95ee\u5217\u8868\u3002 \u6700\u7ec8\uff0c\u6bcf\u4e2a\u91ca\u4e49\u53ef\u4ee5\u6839\u636e\u5728\u8be2\u95ee\u4e2d\u7684\u51fa\u73b0\u60c5\u51b5\uff0c\u4e00\u4e00\u5bf9\u5e94\u5230\u4e00\u4e2a\u5355\u8bcd\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int n ; map < string , int > mp ; void send ( const vector < string > & vec ) { cout << \"? \" << SZ ( vec ); for ( auto & it : vec ) { cout << \" \" << it ; } cout << endl ; cout . flush (); } void got ( int n , int x ) { string s ; for ( int i = 0 ; i < n ; ++ i ) { rd ( s ); int it = mp [ s ]; mp [ s ] = it | ( 1 << x ); } } void run () { rd ( n ); vector < string > vec ( n ); for ( auto & it : vec ) rd ( it ); mp . clear (); for ( int i = 0 ; i < 20 ; ++ i ) { vector < string > query ; for ( int j = 1 ; j <= n ; ++ j ) { if (( j >> i ) & 1 ) { query . push_back ( vec [ j - 1 ]); } } if ( SZ ( query )) { send ( query ); got ( SZ ( query ), i ); } } vector < string > res ( n ); for ( auto & it : mp ) res [ it . se - 1 ] = it . fi ; cout << \"!\" ; for ( auto & it : res ) cout << \" \" << it ; cout << endl ; cout . flush (); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } \u505a\u6cd5\u4e8c \u7b2c\u4e00\u6b21\u8be2\u95ee\u6240\u6709\u7684\u5355\u8bcd\u3002 \u7b2c\u4e8c\u6b21\u5c06\u7b2c\u4e00\u6b21\u8be2\u95ee\u7684\u5355\u8bcd\u5206\u6210\u4e24\u534a\uff0c\u7ee7\u7eed\u8be2\u95ee\uff0c\u8fd9\u4e2a\u65f6\u5019\u53ef\u4ee5\u6839\u636e\u7b2c\u4e00\u6b21\u548c\u7b2c\u4e8c\u6b21\u8be2\u95ee\u7684\u7ed3\u679c\uff0c\u5c06\u5355\u8bcd\u5206\u6210\u4e24\u534a\u3002 \u7ee7\u7eed\u5206\u4e0b\u53bb\u5373\u53ef\u3002 \u548b\u4e00\u60f3\uff0c\u8be2\u95ee\u6b21\u6570\u597d\u50cf\u662f \\mathcal{O}(n \\log n) \\mathcal{O}(n \\log n) \uff0c\u4f46\u662f\u6211\u4eec\u5bf9\u4e8e\u6bcf\u4e00\u5c42\uff0c\u5e76\u4e0d\u9700\u8981\u5206\u5f00\u8be2\u95ee\uff0c\u5b8c\u5168\u53ef\u4ee5\u653e\u5728\u4e00\u8d77\u8be2\u95ee\uff0c\u56e0\u4e3a\u54ea\u4e9b\u91ca\u4e49\u5c5e\u4e8e\u90a3\u4e00\u5806\u90fd\u5df2\u7ecf\u77e5\u9053\u4e86\uff0c\u90a3\u5b8c\u5168\u53ef\u4ee5\u628a\u6bcf\u4e00\u5c42\u7684\u8be2\u95ee\u653e\u5728\u4e00\u4e2a\u8be2\u95ee\u91cc\u3002\u8fd9\u6837\u8be2\u95ee\u7684\u6b21\u6570\u5176\u5b9e\u5c31\u662f\u5c42\u6570\u4e86\uff0c\u90a3\u663e\u7136\u5c31\u662f \\mathcal{O}(\\log n) \\mathcal{O}(\\log n) \u3002 \u4f46\u662f\u540e\u6765\u4e00\u60f3\uff0c\u7b2c 2 2 \u6b21\u8be2\u95ee\u540e\uff0c\u800c\u4e14\u8981\u5206\u5f00\u8be2\u95ee\uff0c\u624d\u80fd\u5c06\u7b2c\u4e00\u6b21\u8be2\u95ee\u7684\u6240\u6709\u91ca\u4e49\u5206\u6210\u4e24\u534a\uff0c\u7b2c 3 3 \u6b21\u8be2\u95ee\u4e5f\u8981\u5206\u5f00\u4e24\u6b21\u624d\u80fd\u5c06\u7b2c 2 2 \u6b21\u7684\u91ca\u4e49\u5206\u6210\u4e24\u90e8\u5206\u3002 \u6240\u4ee5\u6b21\u6570\u597d\u50cf\u8981\u4e58\u4e2a 2 2 \uff0c\u8fd9\u6837\u7684\u8bdd\uff0c 25 25 \u6b21\u8be2\u95ee\u6b21\u6570\uff0c\u5c31\u6709\u70b9\u4e0d\u591f\u4e86\u3002 D. Dup4 and pebble pile \u9898\u610f \u6709\u4e00\u4e9b\u9e45\u5375\u77f3\uff0c\u7f16\u53f7\u4e3a a a \u5230 b b \uff0c\u521a\u5f00\u59cb\u6bcf\u4e2a\u9e45\u5375\u77f3\u5404\u81ea\u5c5e\u4e8e\u4e00\u5806\u3002 \u63a5\u4e0b\u6765\uff0c\u6bcf\u6b21\u53ef\u4ee5\u9009\u62e9\u4e24\u4e2a\u5c5e\u4e8e\u4e0d\u540c\u5806\u7684\u9e45\u5375\u77f3 x x \u548c y y \uff0c\u5982\u679c x x \u548c y y \u6709\u516c\u5171\u8d28\u56e0\u6570 t t \u5e76\u4e14 t \\geq p t \\geq p \uff0c\u90a3\u4e48\u5408\u5e76 x x \u548c y y \u6240\u5728\u7684\u4e24\u5806\u9e45\u5375\u77f3\u3002 \u95ee\u76f4\u5230\u4e0d\u80fd\u518d\u5408\u5e76\u4e3a\u6b62\uff0c\u6700\u7ec8\u6709\u591a\u5c11\u5806\u9e45\u5375\u77f3\u3002 1 \\leq a \\leq b \\leq 10^5, 2 \\leq p \\leq b 1 \\leq a \\leq b \\leq 10^5, 2 \\leq p \\leq b \u3002 \u601d\u8def \u505a\u6cd5\u4e00 \u53ef\u4ee5\u5bf9\u6bcf\u4e2a\u5927\u4e8e\u7b49\u4e8e p p \u7684\u8d28\u56e0\u6570\u5efa\u4e00\u4e2a\u865a\u70b9\uff0c\u7136\u540e a a \u5230 b b \u4e2d\u7684\u6bcf\u4e2a\u9e45\u5375\u77f3\uff0c\u5411\u5b83\u81ea\u5df1\u672c\u8eab\u5927\u4e8e\u7b49\u4e8e p p \u7684\u8d28\u56e0\u6570\u6240\u5bf9\u5e94\u7684\u90a3\u4e2a\u865a\u70b9\u8fde\u8fb9\u5373\u53ef\u3002 \u6700\u7ec8\u7b54\u6848\u662f\u8054\u901a\u5757\u4e2a\u6570\u3002 \u505a\u6cd5\u4e8c \u76f4\u63a5\u679a\u4e3e\u5927\u4e8e\u7b49\u4e8e p p \u7684\u8d28\u56e0\u6570\uff0c\u7136\u540e\u679a\u4e3e\u8d28\u56e0\u6570\u7684\u500d\u6570\uff0c\u8fd9\u4e9b\u8d28\u56e0\u6570\u7684\u500d\u6570\u4e4b\u95f4\u76f8\u90bb\u4e24\u4e2a\u4e4b\u95f4\u8fde\u8fb9\u5373\u53ef\u3002 \u6700\u7ec8\u7b54\u6848\u662f\u8054\u901a\u5757\u4e2a\u6570\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 \\mathcal{O}(n \\alpha(n) \\log n) \\mathcal{O}(n \\alpha(n) \\log n) Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e5 + 10 ; int a , b , p , f [ N ]; struct UFS { int fa [ N ]; void init () { memset ( fa , 0 , sizeof fa ); } int find ( int x ) { return fa [ x ] == 0 ? x : fa [ x ] = find ( fa [ x ]); } void merge ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( fx != fy ) { fa [ fx ] = fy ; } } } ufs ; void run () { rd ( a , b , p ); ufs . init (); memset ( f , 0 , sizeof f ); for ( int i = 2 ; i <= b ; ++ i ) { if ( f [ i ]) continue ; int pre = i ; for ( int j = i ; j <= b ; j += i ) { f [ j ] = 1 ; if ( i >= p && pre >= a ) { ufs . merge ( pre , j ); } pre = j ; } } int res = 0 ; memset ( f , 0 , sizeof f ); for ( int i = a ; i <= b ; ++ i ) { if ( ufs . find ( i ) == i ) ++ res ; } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } E. The King of Sum Xor \u9898\u610f \u957f\u5ea6\u4e3a n n \u7684\u6570\u7ec4\u6ee1\u8db3\u548c\u4e3a S S , \u5f02\u6216\u548c\u4e3a X X \u3002 \u5c06\u6ee1\u8db3\u8fd9\u79cd\u60c5\u51b5\u7684\u6570\u7ec4\u7684\u6700\u5927\u503c\u5b9a\u4e49\u4e3a M M , \u7136\u540e\u5c06\u6240\u6709\u6bcf\u7ec4\u6700\u5927\u503c\u6700\u5c0f\u7684\u6570\u7ec4\u5b9a\u96c6\u5408\u4e49\u4e3a V V , \u95ee V V \u4e2d\u6570\u7ec4\u957f\u5ea6\u6700\u5c0f\u4e3a\u591a\u5c11\u3002 \u601d\u8def \u9996\u5148\u8003\u8651 S, \\; X S, \\; X \u7684\u5173\u7cfb\u53d1\u73b0 S = X + 2A \\& B S = X + 2A \\& B \uff0c\u90a3\u4e48\u5f88\u663e\u7136\u6784\u9020\u51fa\u957f\u5ea6\u4e3a 3 \u7684\u6570\u7ec4\u6ee1\u8db3\u8fd9\u79cd\u5173\u7cfb\uff0c\u4e09\u4e2a\u5143\u7d20\u5206\u522b\u4e3a \\displaystyle X, \\frac{S-X}{2}, \\frac{S-X}{2} \\displaystyle X, \\frac{S-X}{2}, \\frac{S-X}{2} \u540c\u65f6\u8fd9\u65f6\u5019\u53ef\u4ee5\u53d1\u73b0 impossible \u7684\u60c5\u51b5 S < X S < X S - X S - X \u4e3a\u5947\u6570 \u6211\u4eec\u5c06\u8fd9\u4e09\u4e2a\u6570\u6309\u7167\u4e8c\u8fdb\u5236\u5206\u89e3\u5c06\u4f1a\u5f97\u5230\u4e00\u4e2a\u51fa\u4e8b\u60c5\u51b5\u7684 b b \u6570\u7ec4\uff0c b_i b_i \u8868\u793a i i \u4f4d\u6709\u591a\u5c11\u4e2a 1 1 \u4e3a\u4e86\u6ee1\u8db3\u5173\u7cfb\uff0c\u6211\u4eec\u6bcf\u6b21\u6267\u884c\u4ee5\u4e0b\u64cd\u4f5c b_i = b_i-2,b_{i-1}=b_{i-1}+4 b_i = b_i-2,b_{i-1}=b_{i-1}+4 \u63a5\u4e0b\u6765\u8003\u8651\u6700\u5c0f\u7684 M M \uff0c\u53ef\u4ee5\u5f88\u663e\u7136\u7684\u53d1\u73b0\u662f X X \u4e2d\u4e8c\u8fdb\u5236\u4f4d\u6700\u9ad8\u7684\u90a3\u4e00\u4f4d\u6216\u8005\u662f 1 1 \u7136\u540e\u6211\u4eec\u5c31\u53ef\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898 \u9996\u5148\u4e8c\u5206\u4e00\u4e2a n n \uff0c\u7136\u540e\u5c06\u8fd9 n n \u4e2a\u6570\u5b57\u5206\u4e3a\u7b49\u4e8e M M \u548c\u5c0f\u4e8e M M \u7684\u4e24\u79cd\u6570\u5b57\uff0c\u7b49\u4e8e M M \u7684\u6570\u5b57\u5f88\u663e\u7136\u662f\u53ea\u6709\u4e00\u4f4d\u4e3a 1 1 \uff0c\u5c0f\u4e8e M M \u7684\u6570\u5b57\u6bd4 M M \u90a3\u4f4d\u4e8c\u8fdb\u5236\u5c0f\u7684\u4e8c\u8fdb\u5236\u4f4d\u4e0a\u968f\u4fbf\u653e\uff0c\u800c\u5c06\u8fd9 n n \u4e2a\u6570\u5b57\u5206\u4e3a\u7b49\u4e8e M M \u548c\u5c0f\u4e8e M M \u7684\u4e24\u79cd\u6570\u5b57\uff0c\u9700\u8981 O(n) O(n) \u7684\u590d\u6742\u5ea6\uff0c\u4e5f\u5c31\u662f\u8bf4\u6211\u4eec\u73b0\u5728\u7684\u590d\u6742\u5ea6\u4e3a 60 \\cdot O(n) 60 \\cdot O(n) \u3002 \u8003\u8651\u5982\u4f55\u4f18\u5316\u8fd9\u4e2a\u590d\u6742\u5ea6 \u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u521d\u59cb\u72b6\u6001\u4e2d b_i b_i \u6700\u591a\u4e3a 3 3 \uff0c\u800c\u6267\u884c\u4e00\u6b21\u64cd\u4f5c\u5c31\u4f1a\u5bfc\u81f4\u67d0\u4e00\u4f4d 1 1 \u7684\u4e2a\u6570 >=4 >=4 \uff0c\u90a3\u5f88\u663e\u7136\u5c0f\u4e8e M M \u7684\u6570\u5b57\u6211\u4eec\u6700\u591a\u9700\u8981 3 3 \u4e2a\uff0c\u4e5f\u5c31\u662f\u5c0f\u4e8e M M \u90a3\u4e00\u4f4d\u4e8c\u8fdb\u5236\u4f4d\u7684\u6700\u5927 b_i b_i \uff0c\u8fd9\u65f6\u5019\u5c31\u53ef\u4ee5\u4ee5 O(60) O(60) \u7684\u590d\u6742\u5ea6\u8ba1\u7b97\uff0c\u5c31\u53ef\u4ee5\u5f88\u4f18\u7f8e\u7684\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898 PS: \u61d2\u5f97\u6539 std\uff0c\u5c31\u653e\u4e86\u4e2a \\mathcal{O}(\\log n \\cdot \\log (2^{60} - 1)) \\mathcal{O}(\\log n \\cdot \\log (2^{60} - 1)) \u7684\u590d\u6742\u5ea6\u7248\u672c Code #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } #define endl \"\\n\" #define all(A) A.begin(), A.end() using ll = long long ; using db = double ; using pII = pair < int , int > ; const int INF = 0x3f3f3f3f ; const ll INFLL = 0x3f3f3f3f3f3f3f3f ; const int N = 70 ; ll s , x ; int b [ N ]; int high ; // n:limit of high, m limit of low bool ok ( ll n , ll m ) { ll remind = 0 ; for ( int i = 59 ; i >= 0 ; -- i ) { remind <<= 1 ; remind += b [ i ]; if ( i > high ) continue ; ll dec = ( i == high ? n : m ); remind = max ( 0l l , remind - dec ); if ( remind & 1 ) { if ( ! dec ) return false ; remind ++ ; } } return remind == 0 ; } bool check ( ll n ) { for ( int i = 0 ; i <= 5 ; ++ i ) { if ( n - i >= 0 && ok ( n - i , i )) { return true ; } } return false ; } void RUN () { cin >> s >> x ; if ( s < x || ( s - x ) % 2 == 1 ) { cout << -1 << endl ; return ; } if ( s == x && s == 0 ) { cout << 0 << endl ; return ; } memset ( b , 0 , sizeof b ); high = 0 ; for ( int i = 0 ; i < 60 ; ++ i ) { b [ i ] = ( x >> i & 1 ) + (( s - x ) >> i & 2 ); if (( x >> i ) & 1 ) { high = max ( high , i ); } } ll l = 1 , r = s , res = -1 ; while ( r - l >= 0 ) { ll mid = ( l + r ) >> 1 ; if ( check ( mid )) { r = mid - 1 ; res = mid ; } else { l = mid + 1 ; } } cout << res << endl ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ), cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T ; cin >> _T ; while ( _T -- ) { RUN (); } return 0 ; } F. Hsueh- Love Matrix \u9898\u610f \u7ed9\u51fa\u4e00\u4e2a n \\cdot m n \\cdot m \u7684\u77e9\u9635\uff0c\u5176\u4e2d\u77e9\u9635\u5143\u7d20 a_{i, j} = i \\cdot j a_{i, j} = i \\cdot j \u3002\u8be2\u95ee\u77e9\u9635\u4e2d\u7b2c k k \u5927\u7684\u5143\u7d20\u662f\u591a\u5c11\u3002 1 \\leq n, m \\leq 10^9, 1 \\leq k \\leq n \\cdot m 1 \\leq n, m \\leq 10^9, 1 \\leq k \\leq n \\cdot m \u3002 \u601d\u8def \u6c42\u7b2c k k \u5927\u7684\u5143\u7d20\u7b49\u4ef7\u4e8e\u6c42\u7b2c n \\cdot m - k + 1 n \\cdot m - k + 1 \u5c0f\u7684\u5143\u7d20\u3002 \u90a3\u4e48\u6211\u4eec\u4e8c\u5206\u7b54\u6848 x x \uff0c\u7edf\u8ba1\u5c0f\u4e8e\u7b49\u4e8e x x \u7684\u5143\u7d20\u6709\u591a\u5c11\u4e2a\u3002 \u90a3\u4e48\u8fd9\u4e2a\u8ba1\u6570\uff0c\u5176\u5b9e\u7b49\u4ef7\u4e8e\u6c42\uff1a \\sum\\limits_{i = 1}^n \\min(m, \\lfloor \\frac{x}{i} \\rfloor) \\sum\\limits_{i = 1}^n \\min(m, \\lfloor \\frac{x}{i} \\rfloor) \u90a3\u4e48\u8fd9\u4e2a\u4e1c\u897f\u7528\u6570\u8bba\u5206\u5757\uff0c\u5c31\u53ef\u4ee5\u5728 \\mathcal{O}(\\sqrt{x}) \\mathcal{O}(\\sqrt{x}) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e0b\u5b8c\u6210\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head ll n , m , k ; bool ok ( ll x ) { ll tot = 0 ; for ( int i = 1 , j ; i <= min ( n , x ); i = j + 1 ) { j = min ( n , x / ( x / i )); tot += 1l l * ( j - i + 1 ) * min ( m , x / i ); } return tot >= k ; } void run () { rd ( n , m , k ); k = n * m - k + 1 ; if ( n > m ) swap ( n , m ); ll l = 1 , r = min ( n * m , 10000000000l l ), res = r ; // ll l = 1, r = n * m, res = r; while ( r - l >= 0 ) { ll mid = ( l + r ) >> 1 ; if ( ok ( mid )) { r = mid - 1 ; res = mid ; } else { l = mid + 1 ; } } // pt(res); if ( res > 9999999999l l ) pt ( \"Oops\" ); else pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } G. LTS owns large quantities of apples \u9898\u610f \u6709 n n \u4e2a\u82f9\u679c\uff0c m m \u4e2a\u5b69\u5b50\u3002 \u7b2c\u4e00\u4e2a\u5b69\u5b50\u62ff\u5230\u4e86 n n \u4e2a\u82f9\u679c\uff0c\u4ed6\u5403\u6389\u4e86\u4e00\u4e0b\uff0c\u53d1\u73b0\u5269\u4e0b\u7684\u82f9\u679c\u80fd\u6070\u597d\u5206\u6210 x x \u5806\uff0c\u4ed6\u62ff\u8d70\u4e86\u4e00\u5806\uff0c\u5c06\u5269\u4e0b\u7684 (x - 1) (x - 1) \u5806\u7ed9\u7b2c\u4e8c\u4e2a\u5b69\u5b50\u3002 \u7b2c\u4e8c\u4e2a\u5b69\u5b50\u62ff\u5230\u4e86 \\displaystyle \\frac{(n - 1)(x - 1)}{x} \\displaystyle \\frac{(n - 1)(x - 1)}{x} \u4e2a\u82f9\u679c\uff0c\u5403\u6389\u4e86\u4e00\u4e2a\uff0c\u53d1\u73b0\u5269\u4e0b\u7684\u82f9\u679c\u80fd\u6070\u597d\u5206\u6210 x x \u5806\uff0c\u4ed6\u62ff\u8d70\u4e86\u4e00\u5806\uff0c\u5c06\u5269\u4e0b\u7684 (x - 1) (x - 1) \u5806\u7ed9\u7b2c\u4e09\u4e2a\u5b69\u5b50\u3002 \\cdots \\cdots \u7b2c i i \u4e2a\u5b69\u5b50\u62ff\u5230\u4e86\u7b2c (i - 1) (i - 1) \u4e2a\u5b69\u5b50\u7ed9\u4ed6\u7684\u82f9\u679c\uff0c\u5403\u6389\u4e86\u4e00\u4e2a\uff0c\u53d1\u73b0\u5269\u4e0b\u7684\u82f9\u679c\u80fd\u6070\u597d\u5206\u6210 x x \u5806\uff0c\u62ff\u8d70\u4e86\u4e00\u5806\uff0c\u5c06\u5269\u4e0b\u7684 (x - 1) (x - 1) \u5806\u7ed9\u7b2c (i + 1) (i + 1) \u4e2a\u5b69\u5b50\u3002 \\cdots \\cdots \u6700\u540e\u4e00\u4e2a\u5b69\u5b50\u62ff\u5230\u4e86\u5012\u6570\u7b2c\u4e8c\u4e2a\u5b69\u5b50\u7ed9\u4ed6\u7684\u82f9\u679c\uff0c\u5403\u6389\u4e86\u4e00\u4e2a\uff0c\u53d1\u73b0\u5269\u4e0b\u7684\u82f9\u679c\u80fd\u6070\u597d\u5206\u6210 x x \u5806\uff0c\u62ff\u8d70\u4e86\u4e00\u5806\uff0c\u7136\u540e\u7559\u4e0b\u4e86 (x - 1) (x - 1) \u5806\uff0c\u5c31\u79bb\u5f00\u4e86\u3002 \u73b0\u5728\u7ed9\u51fa m(1 \\leq m \\leq 15), x(2 \\leq x \\leq 15) m(1 \\leq m \\leq 15), x(2 \\leq x \\leq 15) \uff0c\u8981\u6c42\u7ed9\u51fa\u4e00\u4e2a\u5c0f\u4e8e\u7b49\u4e8e 10^{18} 10^{18} \u7684\u5408\u6cd5\u7684\u4e00\u4e2a n n \u3002 \u601d\u8def \u4e00\u4e2a\u5408\u6cd5\u7684\u89e3\u662f\uff1a x^m - (x - 1) x^m - (x - 1) \u4f46\u662f x = 2 x = 2 \u7684\u65f6\u5019 \u548c m = 1 m = 1 \u7684\u65f6\u5019\u8981\u7279\u5224\u4e00\u4e0b\u3002 \u6211\u4eec\u8003\u8651 f(i) f(i) \u8868\u793a\u7b2c i i \u4e2a\u5c0f\u670b\u53cb\u62ff\u5230\u7684\u82f9\u679c\u6570\u91cf\uff0c\u90a3\u4e48\u6709\uff1a \\begin{eqnarray*} f(1) &=& x^m - x + 1 = x^m - (x - 1)\\\\ f(2) &=& x^m - x^{m - 1} - (x - 1) = x^{m - 1}(x - 1) - (x - 1)\\\\ f(3) &=& x^m - 2x^{m - 1} + x^{m - 2} - (x - 1) = x^{m - 2}(x - 1)^2 - (x - 1)\\\\ f(4) &=& x^m - 3x^{m - 1} + 3x^{m - 2} - x^{m - 3} - (x - 1) = x^{m - 3}(x - 1)^3 - (x - 1)\\\\ f(5) &=& \\cdots \\end{eqnarray*} \\begin{eqnarray*} f(1) &=& x^m - x + 1 = x^m - (x - 1)\\\\ f(2) &=& x^m - x^{m - 1} - (x - 1) = x^{m - 1}(x - 1) - (x - 1)\\\\ f(3) &=& x^m - 2x^{m - 1} + x^{m - 2} - (x - 1) = x^{m - 2}(x - 1)^2 - (x - 1)\\\\ f(4) &=& x^m - 3x^{m - 1} + 3x^{m - 2} - x^{m - 3} - (x - 1) = x^{m - 3}(x - 1)^3 - (x - 1)\\\\ f(5) &=& \\cdots \\end{eqnarray*} \u53ef\u4ee5\u63a8\u65ad\u51fa\uff1a \\begin{eqnarray*} f(m) &=& x(x - 1)^{m - 1} - (x - 1) \\end{eqnarray*} \\begin{eqnarray*} f(m) &=& x(x - 1)^{m - 1} - (x - 1) \\end{eqnarray*} \u6211\u4eec\u518d\u8003\u8651\u5012\u7740\u63a8\uff1a \\begin{eqnarray*} f(m) &=& x(x - 1)^{m - 1} - (x - 1) \\\\ f(m - 1) &=& x^2(x - 1)^{m - 1} - (x - 1) \\end{eqnarray*} \\begin{eqnarray*} f(m) &=& x(x - 1)^{m - 1} - (x - 1) \\\\ f(m - 1) &=& x^2(x - 1)^{m - 1} - (x - 1) \\end{eqnarray*} \u6211\u4eec\u53d1\u73b0 -(x - 1) -(x - 1) \u975e\u5e38\u5de7\u5999\uff0c\u56e0\u4e3a \\displaystyle -(x - 1) \\cdot \\frac{x}{x - 1} + 1 = -(x - 1) \\displaystyle -(x - 1) \\cdot \\frac{x}{x - 1} + 1 = -(x - 1) \u5b83\u5728\u8fd9\u4e00\u6b65\u64cd\u4f5c\u4e2d\u5e76\u6ca1\u6709\u53d8\u5316\uff0c\u4f46\u662f\u56e0\u4e3a\u5b83\u662f\u8d1f\u6570\uff0c\u6240\u4ee5 f(m) = A - (x - 1) f(m) = A - (x - 1) \uff0c\u6211\u4eec\u9700\u8981\u52a0\u4e0a\u4e00\u4e2a A A \u4f7f\u5f97 f(m) f(m) \u53d8\u6210\u6b63\u6570\u3002 \u6211\u4eec\u518d\u8003\u8651 f(m) f(m) \u8fd8\u6709\u4ec0\u4e48\u9650\u5236\uff1a \\begin{eqnarray*} f(m) &\\equiv& 0 \\bmod x \\\\ f(m) &\\equiv& 0 \\bmod (x - 1)^{m - 1} \\end{eqnarray*} \\begin{eqnarray*} f(m) &\\equiv& 0 \\bmod x \\\\ f(m) &\\equiv& 0 \\bmod (x - 1)^{m - 1} \\end{eqnarray*} \u53c8\u56e0\u4e3a gcd(x, x - 1) = 1 gcd(x, x - 1) = 1 \uff0c\u6240\u4ee5 A = x \\cdot (x - 1)^{m - 1} A = x \\cdot (x - 1)^{m - 1} \u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head int m , x ; ll POW ( ll base , int n ) { ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base ; base = base * base ; n >>= 1 ; } return res ; } void run () { rd ( m , x ); if ( m == 1 ) pt ( x + 1 ); else if ( x == 2 ) { ll res = 1 ; for ( int i = 1 ; i <= m ; ++ i ) { res = res * 2 + 1 ; } pt ( res ); } else { ll res = POW ( x , m ) - ( x - 1 ); pt ( res ); } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } H. Hsueh- and keyboard \u9898\u610f \u6587\u672c\u6846\u91cc\u521a\u5f00\u59cb\u6709\u4e00\u4e2a\u957f\u5ea6\u4e3a x x \u7684\u5b57\u7b26\u4e32\uff0c\u73b0\u5728\u8981\u6c42\u5f97\u5230\u4e00\u4e2a\u957f\u5ea6\u4e3a n n \u7684\u5b57\u7b26\u4e32\u3002 0 \\leq x \\leq 10^6, 1 \\leq n \\leq 10^6 0 \\leq x \\leq 10^6, 1 \\leq n \\leq 10^6 \u3002 \u4f60\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u64cd\u4f5c\u8fbe\u6210\u76ee\u6807\uff1a \u6309\u4e0b\u952e\u76d8\u4e00\u6b21\uff0c\u8f93\u5165\u4e00\u4e2a\u5b57\u7b26\u3002 \u6309\u4e0b\u952e\u76d8\u4e24\u6b21\uff08Ctrl + A), \u9009\u4e2d\u6587\u672c\u6846\u4e2d\u7684\u6240\u6709\u5b57\u7b26\u3002 \u6309\u4e0b\u952e\u76d8\u4e24\u6b21\uff08Ctrl + C), \u590d\u5236\u9009\u4e2d\u7684\u5b57\u7b26\u5230\u526a\u8d34\u677f\u3002 \u6309\u4e0b\u952e\u76d8\u4e24\u6b21\uff08Ctrl + V), \u5c06\u526a\u8d34\u677f\u4e2d\u7684\u5b57\u7b26\u7c98\u8d34\u5230\u6587\u672c\u6846\u3002 \u6309\u4e0b\u952e\u76d8\u4e00\u6b21\uff08Backspace), \u5220\u9664\u6587\u672c\u6846\u4e2d\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\u6216\u8005\u5220\u9664\u9009\u4e2d\u7684\u5b57\u7b26\uff0c\u5982\u679c\u5728\u8fd9\u4e4b\u524d\u4f60\u6309\u4e0b\u4e86\uff08Ctrl + A\uff09\u9009\u4e2d\u4e86\u4e00\u4e9b\u5b57\u7b26\u7684\u8bdd\u3002 \u6b64\u5904\u7684\u64cd\u4f5c\u548c\u4f20\u7edf\u8ba4\u77e5\u6709\u6240\u4e0d\u540c\u7684\u662f\uff0c\u5982\u679c\u4f60\u5148\u6309\u4e0b\u4e86\uff08Ctrl + A\uff09\u9009\u4e2d\u4e86\u6240\u6709\u5b57\u7b26\uff0c\u518d\u8f93\u5165\u4e00\u4e2a\u5b57\u7b26\uff0c\u6216\u8005\u7c98\u8d34\u526a\u8d34\u677f\u4e2d\u7684\u6587\u5b57\u5230\u6587\u672c\u6846\uff0c\u90a3\u4e48\u5b83\u4e0d\u4f1a\u4ea7\u751f\u66ff\u6362\u9009\u4e2d\u6587\u5b57\u7684\u6548\u679c\uff0c\u800c\u662f\u4f1a\u76f4\u63a5\u5f53\u524d\u5b57\u7b26\u4e32\u8ffd\u52a0\u5728\u540e\u9762\u3002 \u6216\u8005\u4f60\u53ef\u4ee5\u8ba4\u4e3a\uff08Ctrl + A\uff09\u53ea\u4f1a\u5bf9\u590d\u5236\u64cd\u4f5c\u6709\u6548\u3002 \u601d\u8def \u4ece x x \u53d8\u5230 n n \uff0c\u6211\u4eec\u5c06\u53d8\u91cf\u6362\u6210 s s \u548c t t \uff0c\u90a3\u4e48\u5c31\u662f\u4ece s s \u5230 t t \uff0c\u8db3\u8db3\u50cf\u4e00\u4e2a\u6700\u77ed\u8def\u5462\u3002 \u663e\u7136\uff0c\u9009\u4e2d\u3001\u590d\u5236\u3001\u7c98\u8d34\u80af\u5b9a\u662f\u8fde\u7740\u7528\uff0c\u4e0d\u4f1a\u51fa\u73b0\u5148\u590d\u5236\uff0c\u7136\u540e\u7c98\u8d34\uff0c\u7136\u540e\u8fdb\u884c\u4e00\u4e9b\u5176\u4ed6\u7684\u64cd\u4f5c\uff0c\u7136\u540e\u518d\u590d\u5236\u3002\u4f46\u662f\u7c98\u8d34\u53ef\u80fd\u4f1a\u7c98\u8d34\u591a\u6b21\u3002 \u9009\u4e2d\u548c\u5220\u9664\u4e5f\u662f\u8fde\u7740\u7528\u3002 \u90a3\u4e48\u76f4\u63a5\u5efa\u56fe\u8fde\u8fb9\u5373\u53ef\uff0c\u6bd4\u5982\uff1a \u7b2c\u4e00\u79cd\u64cd\u4f5c\uff1a\u5c31\u662f i i \u5411 (i + 1) (i + 1) \u8fde\u8fb9\u3002 \u9009\u4e2d\u3001\u590d\u5236\u3001\u7c98\u8d34\uff0c\u5c31\u662f i i \u5230 2i, 3i, \\cdots 2i, 3i, \\cdots \u8fde\u8fb9\u3002 \u5220\u9664\uff0c\u5c31\u662f i i \u5411 (i - 1) (i - 1) \u8fde\u8fb9\uff0c\u6216\u8005 i i \u5411 0 0 \u8fde\u8fb9\u3002 \u6ce8\u610f\u52a0\u4e0a\u8fb9\u6743\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1000000 + 200 ; const int inf = 0x7ffffff ; struct edge { int from , to , w , next ; } e [ N * 20 ]; int head [ N ]; int vis [ N ]; int dist [ N ]; int n , m , t , x ; void add ( int i , int j , int w ) { e [ t ]. from = i ; e [ t ]. to = j ; e [ t ]. w = w ; e [ t ]. next = head [ i ]; head [ i ] = t ++ ; } struct E { int to , w ; E () {} E ( int to , int w ) : to ( to ), w ( w ) {} bool operator < ( const E & other ) const { return w > other . w ; } }; void dijkstra ( int s ) { priority_queue < E > pq ; for ( int i = 0 ; i <= n ; ++ i ) { dist [ i ] = inf ; } dist [ s ] = 0 ; pq . push ( E ( s , 0 )); memset ( vis , 0 , sizeof vis ); while ( ! pq . empty ()) { int u = pq . top (). to ; pq . pop (); if ( u == m ) return ; if ( vis [ u ]) continue ; vis [ u ] = 1 ; for ( int i = head [ u ]; i != -1 ; i = e [ i ]. next ) { int v = e [ i ]. to ; if ( ! vis [ v ] && dist [ v ] > dist [ u ] + e [ i ]. w ) { dist [ v ] = dist [ u ] + e [ i ]. w ; pq . push ( E ( v , dist [ v ])); } } } } int main () { scanf ( \"%d%d\" , & x , & m ); if ( x > m ) n = x + 100 ; else n = m + 100 ; t = 0 ; memset ( head , -1 , sizeof ( head )); for ( int i = 0 ; i < n ; ++ i ) { add ( i , i + 1 , 1 ); add ( i + 1 , i , 1 ); add ( i + 1 , 0 , 3 ); for ( int j = 2 ; i * j <= n && i != 0 ; ++ j ) add ( i , i * j , 2 + 2 * j ); } dijkstra ( x ); // for (int i = 0; i <= n - 100; ++i) printf(\"%d %d\\n\", i, dist[i]); printf ( \"%d \\n \" , dist [ m ]); return 0 ; } I. LTS and rectangular area union \u9898\u610f \u7ed9\u51fa n n \u4e2a\u77e9\u5f62\uff0c\u4ee4 P_i P_i \u8868\u793a\u524d i i \u4e2a\u77e9\u5f62\u7684\u9762\u79ef\u5e76\uff0c\u6c42 (P_1 \\times P_2 \\times P_3 \\times \\cdots \\times P_n) \\bmod 998244353 (P_1 \\times P_2 \\times P_3 \\times \\cdots \\times P_n) \\bmod 998244353 \u3002 \u7ed9\u51fa\u7684\u77e9\u5f62\u7684\u4e0b\u5e95\u8fb9\u4f4d\u4e8e\u540c\u4e00\u6c34\u5e73\u7ebf\u4e0a\u5373\u5de6\u4e0b\u89d2\u4e3a (L_i, 0) (L_i, 0) , \u53f3\u4e0a\u89d2\u4e3a (R_i, H_i) (R_i, H_i) \uff0c\u5e76\u4e14\u9ad8\u5ea6\u975e\u9012\u589e\u3002 1 \\leq n \\leq 10^6 1 \\leq n \\leq 10^6 \u3002 \u601d\u8def \u65e2\u7136\u9ad8\u5ea6\u975e\u9012\u589e\uff0c\u90a3\u4e48\u8bf4\u660e\u7b2c i i \u4e2a\u77e9\u5f62\u7684\u9ad8\u5ea6\u5c0f\u4e8e\u7b49\u4e8e\u524d i i \u4e2a\u77e9\u5f62\u7684\u9ad8\u5ea6\u3002 \u4e5f\u5c31\u662f\u8bf4\u5f53\u5904\u7406\u5230\u7b2c i i \u4e2a\u77e9\u5f62\u7684\u65f6\u5019\uff0c\u9ad8\u5ea6\u5728 H_i H_i \u4ee5\u4e0a\u7684\u9762\u79ef\u4e0d\u7528\u7ba1\uff0c\u5b83\u4eec\u4e0d\u4f1a\u53d1\u751f\u53d8\u5316\u3002 \u4f1a\u53d1\u751f\u53d8\u5316\u7684\u662f\u54ea\u4e00\u90e8\u5206\uff1f\u5176\u5b9e\u5c31\u662f (L_i, R_i) (L_i, R_i) \u8fd9\u4e2d\u95f4\u7684\uff0c\u6ca1\u6709\u88ab\u4e4b\u524d\u4efb\u4f55\u4e00\u4e2a\u77e9\u5f62\u8986\u76d6\u7684\u5730\u65b9\uff0c\u5b83\u5728\u6bcf\u4e00\u4e2a\u5782\u76f4\u65b9\u5411\u90fd\u4f1a\u4ea7\u751f H_i H_i \u7684\u8d21\u732e\u3002 \u90a3\u4e48\u53ef\u4ee5\u7528 set \u7ef4\u62a4\u4e00\u4e2a (l_i, r_i) (l_i, r_i) \uff0c\u4e8c\u5143\u7ec4\uff0c\u8868\u793a\u4e4b\u524d\u66fe\u88ab\u8986\u76d6\u8fc7\u7684\u4e00\u6bb5\u533a\u95f4\uff0c\u5f53\u65b0\u52a0\u5165\u4e00\u4e2a (L_j, R_j) (L_j, R_j) \u65f6\uff0c\u5c06 set \u4e2d\u4e0e (L_j, R_j) (L_j, R_j) \u6709\u5305\u542b\u5173\u7cfb\u6216\u8005\u76f8\u4ea4\u5173\u7cfb\u7684\uff0c\u90fd\u5408\u5e76\u6389\uff0c\u5e76\u4e14\u987a\u4fbf\u7b97\u4e00\u4e0b\u8d21\u732e\u5373\u53ef\u3002 \u663e\u7136\u6bcf\u4e2a\u4e8c\u5143\u7ec4\u53ea\u4f1a\u88ab\u52a0\u5165\u4e00\u6b21\uff0c\u5408\u5e76\u4e00\u6b21\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 \\mathcal{O}(n \\log n) \\mathcal{O}(n \\log n) \u3002 \u4e5f\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u6765\u5b8c\u6210\u8fd9\u4e2a\u64cd\u4f5c\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 998244353 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e6 + 10 ; int n ; struct E { ll l , r , h ; E () {} E ( ll l , ll r , ll h ) : l ( l ), r ( r ), h ( h ) {} bool operator < ( const E & other ) const { return l < other . l ; } } e [ N ]; void run () { rd ( n ); for ( int i = 1 ; i <= n ; ++ i ) rd ( e [ i ]. l , e [ i ]. r , e [ i ]. h ); ll res = 1 ; ll area = 0 ; set < E > se ; for ( int i = 1 ; i <= n ; ++ i ) { ll l = e [ i ]. l , r = e [ i ]. r , h = e [ i ]. h ; if ( se . empty ()) { se . insert ( E ( l , r , h )); chadd ( area , ( r - l ) * h % mod ); } else { auto pos = se . upper_bound ( E ( l , l , 0 )); if ( pos != se . begin ()) pos = prev ( pos ); vector < E > vec ; while ( pos != se . end ()) { auto nx = next ( pos ); if (( pos -> l >= l && pos -> l <= r ) || ( pos -> r >= l && pos -> r <= r ) || ( l >= pos -> l && l <= pos -> r ) || ( r >= pos -> l && r <= pos -> r )) { vec . push_back ( * pos ); se . erase ( pos ); pos = nx ; } else { if ( pos -> l > r ) break ; else pos = nx ; } } if ( vec . empty ()) { se . insert ( E ( l , r , h )); chadd ( area , ( r - l ) * h % mod ); } else { ll _l = l , _r = r ; for ( auto & it : vec ) { chmin ( _l , it . l ); chmax ( _r , it . r ); chadd ( area , mod - ( min ( r , it . r ) - max ( l , it . l )) * h % mod ); } chadd ( area , ( r - l ) * h % mod ); se . insert ( E ( _l , _r , h )); } } res = res * area % mod ; } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( _T -- ) run (); return 0 ; } J. Hsueh- owns large quantities of apples \u9898\u610f \u6709 n n \u4e2a\u82f9\u679c\uff0c m m \u4e2a\u5b69\u5b50\u3002 \u7b2c\u4e00\u4e2a\u5b69\u5b50\u62ff\u5230\u4e86 n n \u4e2a\u82f9\u679c\uff0c\u4ed6\u5403\u6389\u4e86\u4e00\u4e0b\uff0c\u53d1\u73b0\u5269\u4e0b\u7684\u82f9\u679c\u80fd\u6070\u597d\u5206\u6210 x x \u5806\uff0c\u4ed6\u62ff\u8d70\u4e86 (x - 1) (x - 1) \u5806\uff0c\u5c06\u5269\u4e0b\u7684\u4e00\u5806\u7ed9\u7b2c\u4e8c\u4e2a\u5b69\u5b50\u3002 \u7b2c\u4e8c\u4e2a\u5b69\u5b50\u62ff\u5230\u4e86 \\displaystyle \\frac{(n - 1)}{x} \\displaystyle \\frac{(n - 1)}{x} \u4e2a\u82f9\u679c\uff0c\u5403\u6389\u4e86\u4e00\u4e2a\uff0c\u53d1\u73b0\u5269\u4e0b\u7684\u82f9\u679c\u80fd\u6070\u597d\u5206\u6210 x x \u5806\uff0c\u4ed6\u62ff\u8d70\u4e86 (x - 1) (x - 1) \u5806\uff0c\u5c06\u5269\u4e0b\u7684\u4e00\u5806\u7ed9\u7b2c\u4e09\u4e2a\u5b69\u5b50\u3002 \\cdots \\cdots \u7b2c i i \u4e2a\u5b69\u5b50\u62ff\u5230\u4e86\u7b2c (i - 1) (i - 1) \u4e2a\u5b69\u5b50\u7ed9\u4ed6\u7684\u82f9\u679c\uff0c\u5403\u6389\u4e86\u4e00\u4e2a\uff0c\u53d1\u73b0\u5269\u4e0b\u7684\u82f9\u679c\u80fd\u6070\u597d\u5206\u6210 x x \u5806\uff0c\u62ff\u8d70\u4e86 (x - 1) (x - 1) \u5806\uff0c\u5c06\u5269\u4e0b\u7684\u4e00\u5806\u7ed9\u7b2c (i + 1) (i + 1) \u4e2a\u5b69\u5b50\u3002 \\cdots \\cdots \u6700\u540e\u4e00\u4e2a\u5b69\u5b50\u62ff\u5230\u4e86\u5012\u6570\u7b2c\u4e8c\u4e2a\u5b69\u5b50\u7ed9\u4ed6\u7684\u82f9\u679c\uff0c\u5403\u6389\u4e86\u4e00\u4e2a\uff0c\u53d1\u73b0\u5269\u4e0b\u7684\u82f9\u679c\u80fd\u6070\u597d\u5206\u6210 x x \u5806\uff0c\u62ff\u8d70\u4e86 (x - 1) (x - 1) \u5806\uff0c\u7136\u540e\u7559\u4e0b\u4e86\u4e00\u5806\uff0c\u5c31\u79bb\u5f00\u4e86\u3002 1 \\leq m \\leq 10^9, 2 \\leq x \\leq 10^9 1 \\leq m \\leq 10^9, 2 \\leq x \\leq 10^9 , \u6c42\u6700\u5c0f\u7684 n n \u3002 \u601d\u8def \u8003\u8651\u6700\u540e\u4e00\u4e2a\u5b69\u5b50\u4ece\u5012\u6570\u7b2c\u4e8c\u4e2a\u5b69\u5b50\u5f97\u5230\u7684\u82f9\u679c\u6570\u91cf\u4e3a a_m a_m , \u90a3\u4e48\u5012\u6570\u7b2c\u4e8c\u4e2a\u5b69\u5b50\u7684\u62ff\u5230\u7684\u82f9\u679c\u6570\u91cf\u4e3a a_{m - 1} = x \\cdot a_m + 1 a_{m - 1} = x \\cdot a_m + 1 \uff0c\u5012\u6570\u7b2c\u4e09\u4e2a\u5b69\u5b50\u7684\u62ff\u5230\u7684\u82f9\u679c\u6570\u91cf\u4e3a a_{m - 2} = x \\cdot a_{m - 1} + 1 a_{m - 2} = x \\cdot a_{m - 1} + 1 \u3002 \u90a3\u4e48\u53ea\u8981\u8ba9 a_m a_m \u6700\u5c0f\uff0c\u5c31\u53ef\u4ee5\u8ba9 a_1 a_1 \u6700\u5c0f\uff0c\u5373 n n \u6700\u5c0f\u3002 \u663e\u7136 a_m a_m \u6700\u5c0f\u4e3a x + 1 x + 1 , \u7136\u540e\u77e9\u9635\u5feb\u901f\u5e42\u6c42 a_1 a_1 \u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 998244353 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e2 + 10 ; ll m , x ; struct M { int a [ 5 ][ 5 ]; M () { memset ( a , 0 , sizeof a ); } M operator * ( const M & other ) const { M res = M (); for ( int i = 1 ; i <= 2 ; ++ i ) { for ( int j = 1 ; j <= 2 ; ++ j ) { for ( int k = 1 ; k <= 2 ; ++ k ) { chadd ( res . a [ i ][ j ], 1l l * a [ i ][ k ] * other . a [ k ][ j ] % mod ); } } } return res ; } } base , res ; void qpow ( ll n ) { while ( n ) { if ( n & 1 ) res = res * base ; base = base * base ; n >>= 1 ; } pt ( res . a [ 1 ][ 1 ]); } void run () { rd ( m , x ); base = M (); res = M (); base . a [ 1 ][ 1 ] = x ; base . a [ 2 ][ 1 ] = 1 ; base . a [ 2 ][ 2 ] = 1 ; res . a [ 1 ][ 1 ] = 1 ; res . a [ 1 ][ 2 ] = 1 ; qpow ( m ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } \u4f46\u5176\u5b9e\u6572\u4e2a\u77e9\u9635\u5feb\u901f\u5e42\uff0c\u4ee3\u7801\u8fd8\u662f\u6bd4\u8f83\u957f\u7684\u3002 \u6211\u4eec\u56de\u987e\u89e3\u6cd5\uff0c\u62bd\u8c61\u4e00\u4e0b\uff0c\u5176\u5b9e\u5c31\u662f\u6c42\u8fd9\u4e2a\u4e1c\u897f\uff1a \u4ee4 a_0 = 1 a_0 = 1 , \u6709 a_i = x \\cdot a_{i - 1} + 1 a_i = x \\cdot a_{i - 1} + 1 \uff0c\u7136\u540e\u8981\u6c42 a_m a_m \u3002 \u6211\u4eec\u63a8\u4e00\u63a8\u53d1\u73b0\uff1a \\begin{eqnarray*} a_0 &=& 1 \\\\ a_1 &=& x \\cdot a_0 + 1 = x + 1 \\\\ a_2 &=& x \\cdot a_1 + 1 = x^2 + x + 1 \\\\ a_3 &=& x \\cdot a_2 + 1 = x^3 + x^2 + x + 1 \\\\ &\\cdots& \\\\ a_m &=& \\sum\\limits_{i = 0}^{m} x^i \\end{eqnarray*} \\begin{eqnarray*} a_0 &=& 1 \\\\ a_1 &=& x \\cdot a_0 + 1 = x + 1 \\\\ a_2 &=& x \\cdot a_1 + 1 = x^2 + x + 1 \\\\ a_3 &=& x \\cdot a_2 + 1 = x^3 + x^2 + x + 1 \\\\ &\\cdots& \\\\ a_m &=& \\sum\\limits_{i = 0}^{m} x^i \\end{eqnarray*} \u5176\u5b9e\u5c31\u662f\u7b49\u6bd4\u6570\u5217\u6c42\u548c\u3002 K. LTS buy wine \u9898\u610f \u7ed9\u51fa n n \u74f6\u7ea2\u9152\uff0c\u4ece\u5de6\u81f3\u53f3\u4f9d\u6b21\u6392\u5217\uff0c\u6807\u53f7\u4e3a 1 1 \u5230 n n , \u7b2c i i \u74f6\u7ea2\u9152\u7684\u521d\u59cb\u4ef7\u503c\u4e3a v_i v_i \uff0c\u7b2c t t \u5929\u53ef\u4ee5\u4ece\u6700\u5de6\u8fb9\u6216\u8005\u6700\u53f3\u8fb9\u53d6\u4e00\u74f6\u7ea2\u9152\uff0c\u5047\u8bbe\u53d6\u5230\u6807\u53f7\u4e3a j j \u7684\u7ea2\u9152\uff0c\u5f97\u5230\u7684\u4ef7\u503c\u4e3a t \\cdot v_j t \\cdot v_j \u3002\u95ee\u53d6\u5b8c\u6240\u6709\u7ea2\u9152\u540e\uff0c\u5f97\u5230\u7684\u6700\u5927\u603b\u4ef7\u503c\u662f\u591a\u5c11\uff1f \u601d\u8def f_{l, r} f_{l, r} \u8868\u793a\u5df2\u7ecf\u53d6\u5149\u533a\u95f4 [l, r] [l, r] \u8303\u56f4\u5185\u7684\u7ea2\u9152\u7684\u6700\u5927\u4ef7\u503c\u662f\u591a\u5c11\uff0c\u6bcf\u6b21\u53ef\u4ee5\u5f80 f_{l - 1, r} f_{l - 1, r} \u6216\u8005 f_{l, r + 1} f_{l, r + 1} \u8f6c\u79fb\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 2000 + 10 ; ll a [ N ]; ll f [ N ][ N ]; int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld\" , & a [ i ]); f [ i ][ i ] = a [ i ] * n ; } for ( int len = 2 ; len <= n ; ++ len ) for ( int i = 1 ; i <= n - len + 1 ; ++ i ) { int j = i + len - 1 ; ll x = f [ i ][ j - 1 ] + a [ j ] * ( n - ( j - i + 1 ) + 1 ); ll y = f [ i + 1 ][ j ] + a [ i ] * ( n - ( j - i + 1 ) + 1 ); if ( x > y ) f [ i ][ j ] = x ; else f [ i ][ j ] = y ; } printf ( \"%lld \\n \" , f [ 1 ][ n ]); return 0 ; } L. Line problem \u9898\u610f \u95ee\u4e8c\u7ef4\u5e73\u9762\u4e0a\u4e24\u4e2a\u7ebf\u6bb5\u76f8\u4ea4\u957f\u5ea6\uff0c\u76f8\u4ea4\u4e00\u70b9\u5219\u76f8\u4ea4\u957f\u5ea6\u4e3a 0 0 \u3002 \u601d\u8def \u672c\u9898\u5b9a\u4e49\u4e3a\u51e0\u4f55\u7b7e\u5230\u9898 \u9996\u5148\u4e24\u6761\u7ebf\u6bb5\u6240\u5728\u76f4\u7ebf\u9700\u8981\u91cd\u5408\uff0c\u5426\u5219\u8f93\u51fa 0 \u65b9\u6cd5\u4e00 \u5f53\u4e24\u6761\u7ebf\u6bb5\u91cd\u5408\u7684\u65f6\u5019\u5c31\u53ef\u4ee5\u8f6c\u5316\u4e3a\u4e00\u7ef4\u51e0\u4f55\u6765\u89e3\u51b3 \u65b9\u6cd5\u4e8c \u82e5\u7b54\u6848\u5927\u4e8e 0\uff0c\u6c42\u4e24\u6761\u7ebf\u6bb5\u56db\u4e2a\u7aef\u70b9\u7684\u4e24\u4e24\u6700\u957f\u8ddd\u79bb\uff0c\u7136\u540e\u51cf\u53bb\u4e24\u6761\u7ebf\u6bb5\u957f\u5ea6\u5373\u53ef\uff08\u9700\u8981\u6ce8\u610f\u7cbe\u5ea6\uff09 Code #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } #define endl \"\\n\" #define all(A) A.begin(), A.end() using ll = long long ; using db = double ; using pII = pair < int , int > ; const int INF = 0x3f3f3f3f ; const ll INFLL = 0x3f3f3f3f3f3f3f3f ; const int N = 2e5 + 10 ; const db eps = 1e-8 ; int sgn ( db x ) { if ( fabs ( x ) < eps ) return 0 ; else return x > 0 ? 1 : -1 ; } struct Point { db x , y ; Point () {} Point ( db _x , db _y ) { x = _x , y = _y ; } void input () { cin >> x >> y ; } Point operator + ( const Point & b ) const { return Point ( x + b . x , y + b . y ); } Point operator - ( const Point & b ) const { return Point ( x - b . x , y - b . y ); } double operator ^ ( const Point & b ) const { return x * b . y - y * b . x ; } double operator * ( const Point & b ) const { return x * b . x + y * b . y ; } double distance ( Point p ) { return hypot ( x - p . x , y - p . y ); } } dir ; struct Line { Point s , e ; Line () {} Line ( Point _s , Point _e ) { s = _s ; e = _e ; } void input () { s . input (); e . input (); } bool parallel ( Line v ) { return sgn (( e - s ) ^ ( v . e - v . s )) == 0 ; } int relation ( Point p ) { int c = sgn (( p - s ) ^ ( e - s )); if ( c < 0 ) return 1 ; else if ( c > 0 ) return 2 ; else return 3 ; } int linecrossline ( Line v ) { if (( * this ). parallel ( v )) return v . relation ( s ) == 3 ; return 2 ; } } l1 , l2 ; db gao ( Point a , Point b ) { Point d = b - a ; return sgn ( dir * d ) * a . distance ( b ); } void RUN () { l1 . input (); l2 . input (); if ( l1 . linecrossline ( l2 ) != 1 ) { cout << 0 << endl ; return ; } dir = l1 . e - l1 . s ; db a = 0 , b = gao ( l1 . s , l1 . e ), c = gao ( l1 . s , l2 . s ), d = gao ( l1 . s , l2 . e ); if ( a > b ) swap ( a , b ); if ( c > d ) swap ( c , d ); db res = 0 ; if ( sgn ( b - c ) <= 0 ) { res = 0 ; } else if ( sgn ( b - c ) >= 0 && sgn ( b - d ) <= 0 ) { res = min ( b - c , b - a ); } else { if ( sgn ( a - c ) <= 0 ) { res = d - c ; } else if ( sgn ( a - c ) >= 0 && sgn ( a - d ) <= 0 ) { res = d - a ; } } cout << res << endl ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ), cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T ; cin >> _T ; while ( _T -- ) { RUN (); } return 0 ; } M. Rikka with Random Graph \u9898\u610f \u7ed9\u51fa\u4e00\u4e2a n n \u4e2a\u70b9\uff0c m m \u6761\u8fb9\u7684\u6709\u5411\u56fe\uff0c\u6709 q q \u6b21\u8be2\u95ee\uff0c\u6bcf\u6b21\u8be2\u95ee u u \u662f\u5426\u80fd\u591f\u5230\u8fbe v v \u3002 2 \\leq n \\leq 10^5, 1 \\leq m \\leq \\min(10^5, n \\cdot (n - 1)), 1 \\leq q \\leq 10^5 2 \\leq n \\leq 10^5, 1 \\leq m \\leq \\min(10^5, n \\cdot (n - 1)), 1 \\leq q \\leq 10^5 \u3002 \u56fe\u7684\u8fb9\u96c6\u662f\u901a\u8fc7\u4e00\u4e2a\u300c\u968f\u673a\u300d\u7684\u65b9\u6cd5\u751f\u6210\u3002 \u5f3a\u5236\u5728\u7ebf\u3002 \u601d\u8def \u8fd9\u4e2a\u9898\u7684\u505a\u6cd5\uff0c\u5c31\u662f\u5f3a\u8fde\u901a\u7f29\u70b9\u4e4b\u540e\u53d8\u6210 DAG \uff0c\u7136\u540e\u6839\u636e\u62d3\u6251\u5e8f\u4f7f\u7528 bitset \u8fdb\u884c\u8f6c\u79fb\u53ef\u8fbe\u5173\u7cfb\u5373\u53ef\u3002 \u90a3\u7a7a\u95f4\u9700\u8981\u591a\u5927\uff1f \\frac{10^5 \\cdot 10^5 \\cdot 8}{64 \\cdot 1024 \\cdot 1024} \\approx 1192 \\frac{10^5 \\cdot 10^5 \\cdot 8}{64 \\cdot 1024 \\cdot 1024} \\approx 1192 \u9700\u8981 1192M 1192M \u7684\u5185\u5b58\uff0c\u663e\u7136\u9898\u76ee\u6ca1\u6709\u7ed9\u51fa\u90a3\u4e48\u5927\u3002 \u4f46\u5176\u5b9e\u91c7\u7528\u5206\u5757\u7684\u505a\u6cd5\uff0c\u53ef\u4ee5\u964d\u4f4e\u7a7a\u95f4\u590d\u6742\u5ea6\uff0c\u4f46\u662f\u9700\u8981\u79bb\u7ebf\u89e3\u51b3\u8be2\u95ee\u3002 \u90a3\u4e48\u6211\u4eec\u7684\u60f3\u6cd5\u662f\uff0c\u968f\u673a\u56fe\u662f\u5426\u5177\u6709\u6700\u5927\u7684\u5f31\u8fde\u901a\u5206\u91cf\u5927\u5c0f\u8f83\u5c0f\u7684\u6027\u8d28\uff1f \u6211\u4eec\u5728\u968f\u673a\u5f88\u591a\u6b21\u540e\u53d1\u73b0\uff0c\u968f\u673a\u56fe\u597d\u50cf\u6ca1\u6709\u8fd9\u4e2a\u6027\u8d28\uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u60f3\u653e\u5f03\u6211\u4eec\u63d0\u51fa\u7684\u89e3\u6cd5\uff0c\u4e8e\u662f\u624b\u52a8\u6784\u9020\u4e86\u4e00\u4e2a\u300c\u968f\u673a\u56fe\u300d\uff0c\u4f7f\u5f97\u5b83\u6ee1\u8db3\u8fd9\u79cd\u6027\u8d28\u3002 wnext() \u51fd\u6570\u7528\u4e8e\u751f\u6210\u5177\u6709\u504f\u79fb\u671f\u671b\u7684\u968f\u673a\u503c\uff0c\u5f53 t t \u8f83\u5927\u65f6\uff0c\u751f\u6210\u7684\u968f\u673a\u6570\u5728\u533a\u95f4\u8303\u56f4\u5185\u4e5f\u4f1a\u504f\u5927\u3002 \u5e76\u4e14\u6211\u4eec\u63a7\u5236\u4e86\u968f\u673a\u7684\u4e0a\u754c\uff0c\u4f7f\u5f97\u8fd9\u4e2a\u56fe\u7684\u8fde\u8fb9\u4e0d\u4f1a\u5230\u5904\u4ea4\u53c9\u8fde\u8fb9\uff0c\u800c\u662f\u4f1a\u5448\u73b0\u4e00\u4e2a\u5757\u72b6\u3002\u6700\u7ec8\u5f31\u8fde\u901a\u5206\u91cf\u7684\u6700\u5927\u5927\u5c0f\u88ab\u964d\u4f4e\u3002 \u867d\u7136\u6211\u4eec\u4e0d\u4f1a\u8bc1\u660e\uff0c\u4f46\u662f\u671f\u671b\u561b\uff0c\u53ea\u8981\u591a\u8dd1\u51e0\u6b21\u53d6\u5747\u503c\u5c31\u53ef\u4ee5\u770b\u6210\u671f\u671b\u4e86\u5427\uff08\u9003 \u7ecf\u8fc7\u7b80\u5355\u7684\u968f\u673a\u53d1\u73b0\uff0c\u5f53 n = 10^5, m = 10^5 n = 10^5, m = 10^5 \u7684\u65f6\u5019\uff0c\u5f31\u8fde\u901a\u5206\u91cf\u4e2a\u6570\u5927\u6982\u5728 8 \\cdot 10^4 8 \\cdot 10^4 \u5de6\u53f3\uff0c\u5f31\u8fde\u901a\u5206\u91cf\u6700\u5927\u5927\u5c0f\u5927\u6982\u5728 10^4 10^4 \u5de6\u53f3\u3002 \u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u6bcf\u4e2a\u5f31\u8fde\u901a\u5206\u91cf\u91cd\u65b0\u7f16\u53f7\u540e\u5206\u522b\u505a\uff0c\u8fd9\u6837\u9700\u8981\u7684\u7a7a\u95f4\u662f\uff1a \\frac{10^5 \\cdot 10^4 \\cdot 8}{64 \\cdot 1024 \\cdot 1024} \\approx 119 \\frac{10^5 \\cdot 10^4 \\cdot 8}{64 \\cdot 1024 \\cdot 1024} \\approx 119 \u7ef0\u7ef0\u6709\u4f59\u3002 \u90a3\u65e2\u7136\u5f31\u8fde\u901a\u5206\u91cf\u7684 size \u4e0d\u5927\uff0c\u90a3\u4e48\u6211\u5bf9\u6bcf\u6b21\u8be2\u95ee\uff0c\u76f4\u63a5 bfs \u884c\u4e0d\u884c\uff1f \u53ef\u4ee5\u662f\u53ef\u4ee5\uff0c\u800c\u4e14\u5e38\u6570\u5c0f\uff0c\u590d\u6742\u5ea6\u770b\u4e0a\u53bb\u4e5f\u4e0d\u5927\uff0c\u4e5f\u5c31 q q \u6b21\u8be2\u95ee\u4e58\u4e0a\u6700\u5927\u5f31\u8fde\u901a\u5206\u91cf\u5927\u5c0f\uff0c\u597d\u50cf\u4e5f\u5c31 10^9 10^9 \u3002 \u6211\u4e5f\u6ce8\u610f\u5230\u4e86\u8fd9\u79cd\u505a\u6cd5\uff0c\u4f46\u662f\u7528 bitset \u7684\u505a\u6cd5\u6bd4\u8f83\u5feb\uff0c\u6240\u4ee5\u628a\u8fd9\u79cd\u505a\u6cd5\u5361\u6389\u4e86\uff0c\u6240\u4ee5\u65f6\u9650\u53ef\u80fd\u6709\u70b9\u7d27\uff0c\u5927\u6982 2.5 2.5 \u500d\u65f6\u9650\u3002 \u6211\u4eec\u4ee4 \\_n = \\mbox{\u6700\u5927\u5f31\u8fde\u901a\u5206\u91cf\u5927\u5c0f} \\_n = \\mbox{\u6700\u5927\u5f31\u8fde\u901a\u5206\u91cf\u5927\u5c0f} \uff0c\u90a3\u4e48\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\displaystyle \\mathcal{O}(\\frac{(n + q) \\cdot \\_n}{w}) \\displaystyle \\mathcal{O}(\\frac{(n + q) \\cdot \\_n}{w}) \u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head unsigned long long k1 , k2 ; int n , m , q , _u [ 100001 ], _v [ 100001 ]; unsigned long long xorShift128Plus () { unsigned long long k3 = k1 , k4 = k2 ; k1 = k4 ; k3 ^= k3 << 23 ; k2 = k3 ^ k4 ^ ( k3 >> 17 ) ^ ( k4 >> 26 ); return k2 + k4 ; } int wnext ( int l , int r , int t ) { int res = xorShift128Plus () % ( r - l + 1 ) + l ; for ( int i = 1 ; i < t ; ++ i ) { res = max ( res , int ( xorShift128Plus () % ( r - l + 1 ) + l )); } return res ; } void gen () { int S = min ( 1000 , n ); for ( int i = 1 ; i <= m ; ++ i ) { _u [ i ] = wnext ( 1 , min ( n , (( i % S ) + 1 ) * S ), 50 ); _v [ i ] = wnext ( 1 , min ( n , (( i % S ) + 1 ) * S ), 50 ); // dbg(_u[i], _v[i]); } } const int N = 1e5 + 10 ; pII pid [ N ]; struct UFS { int fa [ N ], sze [ N ]; void init ( int n ) { for ( int i = 1 ; i <= n ; ++ i ) { fa [ i ] = 0 ; sze [ i ] = 1 ; } } int find ( int x ) { return fa [ x ] == 0 ? x : fa [ x ] = find ( fa [ x ]); } bool merge ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( fx != fy ) { if ( sze [ fx ] > sze [ fy ]) swap ( fx , fy ); fa [ fx ] = fy ; sze [ fy ] += sze [ fx ]; return true ; } return false ; } } ufs ; struct Bitset { using ull = unsigned long long ; static constexpr int W = 64 ; int n ; vector < ull > bits ; void init ( int _n ) { n = _n + 1 ; bits = vector < ull > ( n / W + 10 , 0 ); } void Or ( const Bitset & t ) { for ( int i = 0 ; i <= n / W ; ++ i ) bits [ i ] |= t . bits [ i ]; } void set ( int x ) { bits [ x / W ] |= 1l lu << ( x % W ); } int ask ( int x ) { return ( bits [ x / W ] >> ( x % W )) & 1 ; } }; struct Sol { vector < vector < int >> G ; vector < Bitset > b ; int n ; vector < int > Low , DFN , sta , Belong ; int cntSCC , cntSta , cntLow ; vector < bool > Insta ; Sol ( int _n ) { n = _n ; G . clear (); G . resize ( n + 5 ); Low = vector < int > ( n + 5 , 0 ); DFN = vector < int > ( n + 5 , 0 ); sta = vector < int > ( n + 5 , 0 ); Belong = vector < int > ( n + 5 , 0 ); Insta = vector < bool > ( n + 5 , false ); cntSCC = cntSta = cntLow = 0 ; } void dfs ( int u ) { Low [ u ] = DFN [ u ] = ++ cntLow ; sta [ ++ cntSta ] = u ; Insta [ u ] = 1 ; for ( auto & v : G [ u ]) { if ( ! DFN [ v ]) { dfs ( v ); Low [ u ] = min ( Low [ u ], Low [ v ]); } else if ( Insta [ v ]) Low [ u ] = min ( Low [ u ], DFN [ v ]); } if ( Low [ u ] == DFN [ u ]) { ++ cntSCC ; int v ; do { v = sta [ cntSta -- ]; Insta [ v ] = 0 ; Belong [ v ] = cntSCC ; } while ( v != u ); } } void gao () { for ( int i = 1 ; i <= n ; ++ i ) if ( ! DFN [ i ]) dfs ( i ); b . resize ( cntSCC + 5 ); for ( int i = 1 ; i <= cntSCC ; ++ i ) b [ i ]. init ( cntSCC + 5 ), b [ i ]. set ( i ); vector < vector < int >> T ; T . clear (); T . resize ( cntSCC + 5 ); for ( int u = 1 ; u <= n ; ++ u ) { for ( auto & v : G [ u ]) { if ( Belong [ u ] == Belong [ v ]) continue ; T [ Belong [ v ]]. push_back ( Belong [ u ]); } } for ( int u = 1 ; u <= cntSCC ; ++ u ) { for ( auto & v : T [ u ]) { b [ v ]. Or ( b [ u ]); } } } int query ( int u , int v ) { if ( Belong [ u ] == Belong [ v ]) return 1 ; // dbg(u, v); return b [ Belong [ u ]]. ask ( Belong [ v ]); } }; vector < Sol > sol ; void numerAS () { sol . clear (); vector < vector < int >> G , vec ; vec . clear (); G . clear (); vec . resize ( n + 1 ); G . resize ( n + 1 ); ufs . init ( n ); for ( int i = 1 ; i <= m ; ++ i ) { int u = _u [ i ], v = _v [ i ]; if ( u != v ) { G [ u ]. push_back ( v ); ufs . merge ( u , v ); // dbg(u, v); } } for ( int i = 1 ; i <= n ; ++ i ) if ( ! G [ i ]. empty ()) { sort ( all ( G [ i ])); G [ i ]. erase ( unique ( all ( G [ i ])), G [ i ]. end ()); } for ( int i = 1 ; i <= n ; ++ i ) { vec [ ufs . find ( i )]. push_back ( i ); } int _pid = -1 ; for ( auto & ve : vec ) if ( ! ve . empty ()) { sol . push_back ( Sol ( SZ ( ve ))); ++ _pid ; int nid = 0 ; for ( auto & it : ve ) { ++ nid ; pid [ it ] = pII ( _pid , nid ); } for ( auto & it : ve ) { for ( auto & v : G [ it ]) { v = pid [ v ]. se ; } sol . back (). G [ pid [ it ]. se ] = G [ it ]; } } } void run () { rd ( n , m , q , k1 , k2 ); gen (); numerAS (); for ( auto & it : sol ) { it . gao (); } for ( int i = 1 , u , v ; i <= q ; ++ i ) { rd ( u , v ); // dbg(pid[u].fi, pid[u].se, pid[v].se); int res = 0 ; if ( pid [ u ]. fi == pid [ v ]. fi ) { res = sol [ pid [ u ]. fi ]. query ( pid [ u ]. se , pid [ v ]. se ); } pt ( res ? \"Yes\" : \"No\" ); cout . flush (); } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"The Hangzhou Normal U Qualification Trials for Zhejiang Provincial Collegiate Programming Contest 2020 Editorial"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#our-sponsor","text":"\u672c\u573a\u6bd4\u8d5b\u7531 DMI\uff08\u6570\u5b57\u5a92\u4f53\u4e0e\u4eba\u673a\u4ea4\u4e92\uff09\u4e2d\u5fc3\u8d5e\u52a9\u3002 DMI \u4e2d\u5fc3\u4e3b\u8981\u7814\u7a76\u65b9\u5411\uff1a \u667a\u80fd\u89c6\u9891\u7f16\u7801\uff1a\u501f\u52a9\u4e8e\u6df1\u5ea6\u5b66\u4e60\u6280\u672f\uff0c\u5c06\u5176\u5e94\u7528\u4e8e\u89c6\u9891\u7f16\u7801\u4e2d\uff0c\u63d0\u9ad8\u538b\u7f29\u6548\u7387\u3002 \u56fe\u50cf\u8d28\u91cf\u589e\u5f3a\uff1a\u501f\u52a9\u4e8e\u673a\u5668\u5b66\u4e60\uff0c\u63d0\u9ad8\u53d7\u635f\u56fe\u50cf\u4e3b\u5ba2\u89c2\u8d28\u91cf\u6216\u5206\u8fa8\u7387\u3002 \u89c6\u9891\u7f16\u7801\u7b97\u6cd5\u4f18\u5316\uff1a\u8bbe\u8ba1\u5feb\u901f\u7b97\u6cd5\uff0c\u5728\u4fdd\u8bc1\u89c6\u9891\u7f16\u7801\u6548\u7387\u7684\u540c\u65f6\u63d0\u9ad8\u7f16\u7801\u901f\u5ea6\u3002 DMI \u4e2d\u5fc3\u62e5\u6709\uff1a 100 \u5e73\u7c73\u7684\u5b9e\u9a8c\u5ba4\u3002 20 \u53f0\u53ef\u8fdb\u884c\u6df1\u5ea6\u5b66\u4e60\u7684\u673a\u5668\uff0c2080TI \u662f\u6807\u914d\u3002 DMI \u4e2d\u5fc3\u8054\u7cfb\u4eba\uff1a \u4e01\u4e39\u4e39\u8001\u5e08\uff0c\u6d59\u6c5f\u5927\u5b66\u535a\u58eb\u5b66\u4f4d\u3002 QQ: 187113186 Email: DandanDing@hznu.edu.cn","title":"Our Sponsor"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#thanks","text":"\u611f\u8c22\u6240\u6709\u9a8c\u9898\u4eba\u7ed9\u6211\u4eec\u63d0\u51fa\u7684\u5b9d\u8d35\u7684\u610f\u89c1\u3002","title":"Thanks"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#talks","text":"\u8fd9\u4e2a\u968f\u673a\u4f1a\u4e0d\u4f1a\u88ab\u4eba\u6253\u6b7b\u3002 \u679c\u7136\u300c\u597d\u9898\u76ee\u662f\u6539\u51fa\u6765\u7684\u300d\uff0c\u5f53\u4f60\u611f\u89c9\u826f\u597d\u7684\u65f6\u5019\uff0c\u603b\u6709\u9a8c\u9898\u4eba\u6765\u7ed9\u4f60\u5f53\u5934\u68d2\u559d\uff0c\u8fd9\u91cc\u7684\u300c\u597d\u300d\u6307\u7684\u662f\u9898\u9762\u9610\u8ff0\u6e05\u695a\uff0c\u6570\u636e\u5065\u58ee\uff0c\u800c\u975e\u300c\u597d\u9898\u300d\uff08\u9003\u3002","title":"Talks"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#materials","text":"PRACTICE LINK account Handle Password Name team2950361 16PGIH HZNU_kindergarten-C5-\u5305\u654f\u3001\u5b59\u5468\u6bc5\u3001\u9b4f\u709c team2950362 4R3PJ9 Fingertip melody-D3-\u8c22\u4f5c\u6770\u3001\u5362\u9716\u7edf\u3001\u6768\u660c\u6797 team2950363 5I1SMD HZNU_Tourists-A3-\u5f20\u51ef\u8389\u3001\u90b1\u9f99\u98ce\u3001\u5f20\u4f20 team2950364 53BJ3G Schroedinger's Pig-C1-\u6731\u6e56\u5065\u3001\u9646\u5bb6\u8f89\u3001\u6881\u6587\u535a team2950365 6AERHL Cabbage-B5-\u65bd\u9a8f\u709c\u3001\u9648\u601d\u6b23\u3001\u6bdb\u6631\u6ee2 team2950366 GVKNB4 Three Fruits-D5-\u6e29\u94ed\u6d69\u3001\u9b4f\u4f9d\u6d0b\u3001\u674e\u6d69\u7136 team2950367 XGFX11 pupil NB-C3-\u4fde\u4f73\u6743\u3001\u738b\u51cc\u8a00\u3001\u949f\u607a team2950368 UJVQEJ washing washing sleeping -D2-\u4f55\u9648\u806a\u3001\u4ed8\u4fca\u3001\u674e\u9a8b team2950369 UZHKAE Kitten Marine Corp-A4-\u5218\u6052\u7fbd\u3001\u53f6\u521d\u822a\u3001\u5468\u5a49\u5a67 team29503610 IDM6ND yingyingying-B4-\u90b5\u94c1\u592b\u3001\u6e29\u58f0\u8363\u3001\u82cf\u6850\u6e24 team29503611 ZEXXUY O(n!) -> O(1)-C4-\u5f20\u67a8\u3001\u9648\u67ef\u6d9b\u3001\u5434\u9648\u5b87 team29503612 YQ2QQH acwork-A2-\u5168\u632f\u5b87\u3001\u5b8b\u535a\u5e06\u3001\u738b\u827a\u84c9 team29503613 GI9PXJ NULL-B1-\u6797\u5cf0\u3001\u6881\u6db5\u6770\u3001\u5f90\u5149\u6cfd team29503614 C82J2C Turing-D4-\u9648\u96e8\u6b23\u3001\u5468\u73c8\u4f0a\u3001\u5f90\u8c6a\u6770 team29503615 2S3CJB play snake-B2-\u674e\u5f66\u5e86\u3001\u6768\u4e91\u9f99\u3001\u6797\u6cd3\u4f7a team29503616 2ZFGJA Fried tomatoes-C2-\u6bdb\u6f5c\u98de\u3001\u65b9\u4e00\u660a\u3001\u53f6\u4fca team29503617 H8ZIP2 dancing lightning-B3-\u5f90\u6d69\u7136\u3001\u6881\u96e8\u6b23\u3001\u6768\u5e06 team29503618 2R6WYC non-prepared guys-A5-\u8521\u6797\u8fbe\u3001\u9ad8\u7b11\u82b8\u3001\u5218\u5174\u677e","title":"Materials"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#solutions","text":"","title":"Solutions"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#a-a-simple-problem","text":"","title":"A. A simple problem"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u9898\u610f","text":"\u7ed9\u51fa 0-n 0-n \u7684\u5168\u6392\u5217\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u6392\u5217\u5c06\u6bcf\u4e2a\u6570\u5b57\u4e32\u8d77\u6765\u7ec4\u6210\u65b0\u7684\u6574\u6570\uff0c\u95ee\u4e0d\u542b\u524d\u5bfc\u96f6\u4e14\u88ab m m \u6574\u9664\u6709\u591a\u5c11\u4e2a\u6570\u5b57","title":"\u9898\u610f"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u601d\u8def","text":"\u770b\u6570\u636e\u8303\u56f4\u7ecf\u5178\u72b6\u538b dp dp , dp[S][i] dp[S][i] \u8868\u793a\u5df2\u7ecf\u7528\u4e86\u7684\u6570\u5b57\u72b6\u6001\u4e3a S S , \u4f59\u6570\u4e3a i i \u7684\u4e2a\u6570\uff0c\u6bcf\u6b21\u679a\u4e3e\u6ca1\u7528\u8fc7\u7684\u6570\u5b57\u5411\u4e0b\u63a8\u5373\u53ef\uff08\u53ef\u53c2\u8003\u5927\u6574\u6570\u53d6\u4f59\uff09\uff0c\u5f53\u7136\u6ce8\u610f 10,11,12,13,14,15 10,11,12,13,14,15 \u90fd\u662f\u4e24\u4f4d\u6570 Code #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } #define endl \"\\n\" #define all(A) A.begin(), A.end() using ll = long long ; using db = double ; using pII = pair < int , int > ; const int INF = 0x3f3f3f3f ; const ll INFLL = 0x3f3f3f3f3f3f3f3f ; const int N = 16 , M = 100 ; int n , m ; ll f [ 1 << N ][ M ]; void RUN () { cin >> n >> m ; ++ n ; f [ 0 ][ 0 ] = 1 ; int limit = 1 << n ; for ( int S = 0 ; S < limit ; ++ S ) { for ( int i = 0 ; i < n ; ++ i ) { if ( S & ( 1 << i )) continue ; if ( S == 0 && i == 0 ) continue ; int nxt = S | ( 1 << i ); for ( int j = 0 ; j < m ; ++ j ) { if ( i >= 10 ) { f [ nxt ][( j * 100 + i ) % m ] += f [ S ][ j ]; } else { f [ nxt ][( j * 10 + i ) % m ] += f [ S ][ j ]; } } } } cout << f [ limit - 1 ][ 0 ] << endl ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ), cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); RUN (); return 0 ; }","title":"\u601d\u8def"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#b-hsueh--play-balls","text":"","title":"B. Hsueh- play balls"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u9898\u610f_1","text":"\u6709 n n \u4e2a\u767d\u7403\u548c m m \u4e2a\u9ed1\u7403\u5728\u76d2\u5b50\u91cc\uff0c\u6bcf\u6b21\u4ece\u4e2d\u53d6\u51fa\u4e00\u4e2a\u7403\u5230\u76d2\u5b50\u5916\uff0c\u95ee\u53d6\u7403\u8fc7\u7a0b\u4e2d\u5c06\u6240\u6709\u7403\u53d6\u51fa\u7684\u8fc7\u7a0b\u4e2d\u76d2\u5b50\u5916\u7684\u7403\u4e2d\uff0c\u767d\u7403\u4e2a\u6570\u548c\u9ed1\u7403\u4e2a\u6570\u81f3\u5c11\u6709\u4e00\u6b21\u76f8\u7b49\u7684\u6982\u7387\u662f\u591a\u5c11\uff1f","title":"\u9898\u610f"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u601d\u8def_1","text":"\u7b54\u6848\u662f\uff1a \\begin{eqnarray*} \\Large \\frac{{n + m \\choose n} - {n + m - 1 \\choose n - 1} - {n + m - 1 \\choose m - 1}}{{n + m \\choose n}} \\end{eqnarray*} \\begin{eqnarray*} \\Large \\frac{{n + m \\choose n} - {n + m - 1 \\choose n - 1} - {n + m - 1 \\choose m - 1}}{{n + m \\choose n}} \\end{eqnarray*} \u8003\u8651\u6b64\u5904\u6982\u7387\u5c31\u662f \\displaystyle \\frac{\\mbox{\u5408\u6cd5\u7684\u65b9\u6848\u6570}}{\\mbox{\u603b\u65b9\u6848\u6570}} \\displaystyle \\frac{\\mbox{\u5408\u6cd5\u7684\u65b9\u6848\u6570}}{\\mbox{\u603b\u65b9\u6848\u6570}} \u3002 \u603b\u65b9\u6848\u6570\u663e\u7136\u662f \\displaystyle {n + m \\choose n} \\displaystyle {n + m \\choose n} \u3002 \u5408\u6cd5\u7684\u65b9\u6848\u6570\u662f\u4ec0\u4e48\uff0c\u5c31\u662f\u53d6\u7403\u8fc7\u7a0b\u4e2d\u767d\u7403\u4e2a\u6570\u548c\u9ed1\u7403\u4e2a\u6570\u81f3\u5c11\u6709\u4e00\u6b21\u76f8\u7b49\u7684\u65b9\u6848\uff0c\u8003\u8651\u53cd\u9762\uff0c\u5c31\u662f \\mbox{\u603b\u65b9\u6848\u6570} - \\mbox{\u53d6\u7403\u8fc7\u7a0b\u4e2d\u767d\u7403\u4e2a\u6570\u548c\u9ed1\u7403\u4e2a\u6570\u4e00\u6b21\u90fd\u4e0d\u76f8\u7b49\u7684\u65b9\u6848} \\mbox{\u603b\u65b9\u6848\u6570} - \\mbox{\u53d6\u7403\u8fc7\u7a0b\u4e2d\u767d\u7403\u4e2a\u6570\u548c\u9ed1\u7403\u4e2a\u6570\u4e00\u6b21\u90fd\u4e0d\u76f8\u7b49\u7684\u65b9\u6848} \u3002 \u6211\u4eec\u4e0d\u59a8\u4ee4 n \\geq m n \\geq m : \u9996\u5148\u6211\u4eec\u9700\u8981\u4e24\u6761\u9884\u5907\u77e5\u8bc6\uff1a \u4ece (0, 0) (0, 0) \u5230 (n, m) (n, m) \u7684\u975e\u964d\u8def\u5f84\u6761\u6570\uff1a \\displaystyle {n + m \\choose n} \\displaystyle {n + m \\choose n} \u4ece (s, t) (s, t) \u5230 (n, m) (n, m) \u7684\u975e\u964d\u8def\u5f84\u6761\u6570\uff1a \\displaystyle {n + m - s - t \\choose n - s} \\displaystyle {n + m - s - t \\choose n - s} \u90a3\u4e48\u6211\u4eec\u8f6c\u5316\u4e00\u4e0b\uff0c\u770b\u6210\u5750\u6807\u7cfb\u4e2d\uff0c\u4ece (0, 0) (0, 0) \u8d70\u5230 (n, m) (n, m) , \u53d6\u767d\u7403\u770b\u6210\u5411\u4e0a\u8d70\uff0c\u53d6\u9ed1\u7403\u770b\u6210\u5411\u53f3\u8d70\uff0c\u90a3\u4e48\u4efb\u610f\u65f6\u523b\u5411\u4e0a\u8d70\u7684\u6b65\u6570\u4e0d\u80fd\u5c0f\u4e8e\u5411\u53f3\u8d70\u7684\u6b65\u6570\uff0c\u5373\u4e0d\u7ecf\u8fc7 y = x y = x \uff08\u4e0d\u5305\u62ec (0, 0) (0, 0) \u8fd9\u4e2a\u70b9\uff09\u3002 \u603b\u7684\u60c5\u51b5\u6570\u4e3a \\displaystyle {n + m \\choose n} \\displaystyle {n + m \\choose n} (0, 0) (0, 0) \u5148\u5411\u4e0a\u8d70\u5230 (0, 1) (0, 1) \uff0c\u90a3\u4e48\u5230\u7ec8\u70b9 (n, m) (n, m) \u4e00\u5b9a\u4f1a\u7ecf\u8fc7 y = x y = x \u8fd9\u6761\u76f4\u7ebf\uff0c\u8fd9\u79cd\u975e\u6cd5\u60c5\u51b5\u4e3a (0, 1) (0, 1) \u5230 (n, m) (n, m) \u7684\u975e\u964d\u8def\u5f84\u6761\u6570 \\displaystyle {n + m - 1 \\choose n} \\displaystyle {n + m - 1 \\choose n} \u4ece (0, 0) (0, 0) \u5411\u53f3\u8d70\u5230 (1, 0) (1, 0) \uff0c\u8fd9\u65f6\u5019\u6709\u4e24\u79cd\u60c5\u51b5\uff0c\u4e00\u79cd\u60c5\u51b5\u662f\u5408\u6cd5\u7684\uff0c\u53e6\u4e00\u79cd\u60c5\u51b5\u8fd8\u662f\u4f1a\u7ecf\u8fc7 y = x y = x \uff0c\u8fd9\u65f6\u5019\u8bb0\u8be5\u8def\u7ebf\u4e00\u6b21\u7ecf\u8fc7 y = x y = x \u7684\u70b9\u4e3a C C \uff0c\u5c06 (1, 0) (1, 0) \u5230\u70b9 C C \u95f4\u7684\u8def\u5f84\u5173\u4e8e y = x y = x \u5bf9\u79f0\uff0c\u53ef\u4ee5\u5f97\u5230\u4e0e\u60c5\u51b5 2 2 \u7684\u4e00\u4e00\u6620\u5c04\uff0c\u5373\u4e0d\u5408\u6cd5\u60c5\u51b5\u7684\u8def\u5f84\u6761\u6570\u4e3a \\displaystyle {n + m - 1 \\choose n} \\displaystyle {n + m - 1 \\choose n} \u6240\u4ee5\u603b\u7684\u6ee1\u8db3\u6761\u4ef6\u7684\u8def\u5f84\u6761\u6570\u4e3a \\displaystyle {n + m \\choose n} - 2{n + m - 1 \\choose n} \\displaystyle {n + m \\choose n} - 2{n + m - 1 \\choose n} \u3002 \u4e5f\u53ef\u4ee5\u76f4\u63a5\u8003\u8651\u5f3a\u5236\u7b2c\u4e00\u6b65\u5f80\u53f3\u8d70\uff0c\u90a3\u4e48\u603b\u7684\u65b9\u6848\u6570\u4e3a \\displaystyle {n + m - 1 \\choose n - 1} \\displaystyle {n + m - 1 \\choose n - 1} \uff0c\u518d\u8003\u8651\u4e0a\u8ff0\u7684\u7b2c\u4e09\u79cd\u60c5\u51b5\u7684\u4e0d\u5408\u6cd5\u65b9\u6848\u6570\uff0c\u90a3\u4e48\u4e0d\u5408\u6cd5\u7684\u6709 \\displaystyle {n + m - 1 \\choose n} \\displaystyle {n + m - 1 \\choose n} \uff0c\u6240\u4ee5\u5408\u6cd5\u65b9\u6848\u6570\u4e3a \\displaystyle {n + m - 1 \\choose n - 1} - {n + m - 1 \\choose n} = {n + m - 1 \\choose n - 1} - {n + m - 1 \\choose m - 1} \\displaystyle {n + m - 1 \\choose n - 1} - {n + m - 1 \\choose n} = {n + m - 1 \\choose n - 1} - {n + m - 1 \\choose m - 1} Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 998244353 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 2e6 + 10 ; int n , m , fac [ N ], inv [ N ]; ll C ( int n , int m ) { if ( n < m ) return 0 ; return 1l l * fac [ n ] * inv [ n - m ] % mod * inv [ m ] % mod ; } void run () { rd ( n , m ); if ( n == m ) return pt ( 1 ); if ( n < m ) swap ( n , m ); ll tot = C ( n + m , n ); ll cur = ( C ( n + m - 1 , n - 1 ) - C ( n + m - 1 , m - 1 ) + mod ) % mod ; ll numerator = ( tot - cur + mod ) % mod ; ll denominator = tot ; // dbg(numerator, denominator); ll res = numerator * qpow ( denominator , mod - 2 ) % mod ; pt ( res ); } int main () { fac [ 0 ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) fac [ i ] = 1l l * fac [ i - 1 ] * i % mod ; inv [ N - 1 ] = qpow ( fac [ N - 1 ], mod - 2 ); for ( int i = N - 1 ; i >= 1 ; -- i ) inv [ i - 1 ] = 1l l * inv [ i ] * i % mod ; ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#c-hoogle-machine-translation","text":"","title":"C. Hoogle Machine Translation"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u9898\u610f_2","text":"\u6709\u4e00\u4e2a\u7ffb\u8bd1\u673a\u5668\uff0c\u6bcf\u6b21\u80fd\u7ffb\u8bd1\u82e5\u5e72\u4e2a\u5355\u8bcd\uff0c\u4f46\u662f\u8fd4\u56de\u7684\u91ca\u4e49\u7684\u987a\u5e8f\u662f\u6df7\u4e71\u7684\uff0c\u73b0\u5728\u8981\u6c42\u5728 25 25 \u6b21\u8be2\u95ee\u5185\uff0c\u5f97\u51fa n(1 \\leq n \\leq 10^5) n(1 \\leq n \\leq 10^5) \u4e2a\u5355\u8bcd\u7684\u91ca\u4e49\u3002","title":"\u9898\u610f"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u601d\u8def_2","text":"","title":"\u601d\u8def"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#d-dup4-and-pebble-pile","text":"","title":"D. Dup4 and pebble pile"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u9898\u610f_3","text":"\u6709\u4e00\u4e9b\u9e45\u5375\u77f3\uff0c\u7f16\u53f7\u4e3a a a \u5230 b b \uff0c\u521a\u5f00\u59cb\u6bcf\u4e2a\u9e45\u5375\u77f3\u5404\u81ea\u5c5e\u4e8e\u4e00\u5806\u3002 \u63a5\u4e0b\u6765\uff0c\u6bcf\u6b21\u53ef\u4ee5\u9009\u62e9\u4e24\u4e2a\u5c5e\u4e8e\u4e0d\u540c\u5806\u7684\u9e45\u5375\u77f3 x x \u548c y y \uff0c\u5982\u679c x x \u548c y y \u6709\u516c\u5171\u8d28\u56e0\u6570 t t \u5e76\u4e14 t \\geq p t \\geq p \uff0c\u90a3\u4e48\u5408\u5e76 x x \u548c y y \u6240\u5728\u7684\u4e24\u5806\u9e45\u5375\u77f3\u3002 \u95ee\u76f4\u5230\u4e0d\u80fd\u518d\u5408\u5e76\u4e3a\u6b62\uff0c\u6700\u7ec8\u6709\u591a\u5c11\u5806\u9e45\u5375\u77f3\u3002 1 \\leq a \\leq b \\leq 10^5, 2 \\leq p \\leq b 1 \\leq a \\leq b \\leq 10^5, 2 \\leq p \\leq b \u3002","title":"\u9898\u610f"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u601d\u8def_3","text":"","title":"\u601d\u8def"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#e-the-king-of-sum-xor","text":"","title":"E. The King of Sum Xor"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u9898\u610f_4","text":"\u957f\u5ea6\u4e3a n n \u7684\u6570\u7ec4\u6ee1\u8db3\u548c\u4e3a S S , \u5f02\u6216\u548c\u4e3a X X \u3002 \u5c06\u6ee1\u8db3\u8fd9\u79cd\u60c5\u51b5\u7684\u6570\u7ec4\u7684\u6700\u5927\u503c\u5b9a\u4e49\u4e3a M M , \u7136\u540e\u5c06\u6240\u6709\u6bcf\u7ec4\u6700\u5927\u503c\u6700\u5c0f\u7684\u6570\u7ec4\u5b9a\u96c6\u5408\u4e49\u4e3a V V , \u95ee V V \u4e2d\u6570\u7ec4\u957f\u5ea6\u6700\u5c0f\u4e3a\u591a\u5c11\u3002","title":"\u9898\u610f"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u601d\u8def_4","text":"\u9996\u5148\u8003\u8651 S, \\; X S, \\; X \u7684\u5173\u7cfb\u53d1\u73b0 S = X + 2A \\& B S = X + 2A \\& B \uff0c\u90a3\u4e48\u5f88\u663e\u7136\u6784\u9020\u51fa\u957f\u5ea6\u4e3a 3 \u7684\u6570\u7ec4\u6ee1\u8db3\u8fd9\u79cd\u5173\u7cfb\uff0c\u4e09\u4e2a\u5143\u7d20\u5206\u522b\u4e3a \\displaystyle X, \\frac{S-X}{2}, \\frac{S-X}{2} \\displaystyle X, \\frac{S-X}{2}, \\frac{S-X}{2} \u540c\u65f6\u8fd9\u65f6\u5019\u53ef\u4ee5\u53d1\u73b0 impossible \u7684\u60c5\u51b5 S < X S < X S - X S - X \u4e3a\u5947\u6570 \u6211\u4eec\u5c06\u8fd9\u4e09\u4e2a\u6570\u6309\u7167\u4e8c\u8fdb\u5236\u5206\u89e3\u5c06\u4f1a\u5f97\u5230\u4e00\u4e2a\u51fa\u4e8b\u60c5\u51b5\u7684 b b \u6570\u7ec4\uff0c b_i b_i \u8868\u793a i i \u4f4d\u6709\u591a\u5c11\u4e2a 1 1 \u4e3a\u4e86\u6ee1\u8db3\u5173\u7cfb\uff0c\u6211\u4eec\u6bcf\u6b21\u6267\u884c\u4ee5\u4e0b\u64cd\u4f5c b_i = b_i-2,b_{i-1}=b_{i-1}+4 b_i = b_i-2,b_{i-1}=b_{i-1}+4 \u63a5\u4e0b\u6765\u8003\u8651\u6700\u5c0f\u7684 M M \uff0c\u53ef\u4ee5\u5f88\u663e\u7136\u7684\u53d1\u73b0\u662f X X \u4e2d\u4e8c\u8fdb\u5236\u4f4d\u6700\u9ad8\u7684\u90a3\u4e00\u4f4d\u6216\u8005\u662f 1 1 \u7136\u540e\u6211\u4eec\u5c31\u53ef\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898 \u9996\u5148\u4e8c\u5206\u4e00\u4e2a n n \uff0c\u7136\u540e\u5c06\u8fd9 n n \u4e2a\u6570\u5b57\u5206\u4e3a\u7b49\u4e8e M M \u548c\u5c0f\u4e8e M M \u7684\u4e24\u79cd\u6570\u5b57\uff0c\u7b49\u4e8e M M \u7684\u6570\u5b57\u5f88\u663e\u7136\u662f\u53ea\u6709\u4e00\u4f4d\u4e3a 1 1 \uff0c\u5c0f\u4e8e M M \u7684\u6570\u5b57\u6bd4 M M \u90a3\u4f4d\u4e8c\u8fdb\u5236\u5c0f\u7684\u4e8c\u8fdb\u5236\u4f4d\u4e0a\u968f\u4fbf\u653e\uff0c\u800c\u5c06\u8fd9 n n \u4e2a\u6570\u5b57\u5206\u4e3a\u7b49\u4e8e M M \u548c\u5c0f\u4e8e M M \u7684\u4e24\u79cd\u6570\u5b57\uff0c\u9700\u8981 O(n) O(n) \u7684\u590d\u6742\u5ea6\uff0c\u4e5f\u5c31\u662f\u8bf4\u6211\u4eec\u73b0\u5728\u7684\u590d\u6742\u5ea6\u4e3a 60 \\cdot O(n) 60 \\cdot O(n) \u3002 \u8003\u8651\u5982\u4f55\u4f18\u5316\u8fd9\u4e2a\u590d\u6742\u5ea6 \u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u521d\u59cb\u72b6\u6001\u4e2d b_i b_i \u6700\u591a\u4e3a 3 3 \uff0c\u800c\u6267\u884c\u4e00\u6b21\u64cd\u4f5c\u5c31\u4f1a\u5bfc\u81f4\u67d0\u4e00\u4f4d 1 1 \u7684\u4e2a\u6570 >=4 >=4 \uff0c\u90a3\u5f88\u663e\u7136\u5c0f\u4e8e M M \u7684\u6570\u5b57\u6211\u4eec\u6700\u591a\u9700\u8981 3 3 \u4e2a\uff0c\u4e5f\u5c31\u662f\u5c0f\u4e8e M M \u90a3\u4e00\u4f4d\u4e8c\u8fdb\u5236\u4f4d\u7684\u6700\u5927 b_i b_i \uff0c\u8fd9\u65f6\u5019\u5c31\u53ef\u4ee5\u4ee5 O(60) O(60) \u7684\u590d\u6742\u5ea6\u8ba1\u7b97\uff0c\u5c31\u53ef\u4ee5\u5f88\u4f18\u7f8e\u7684\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898 PS: \u61d2\u5f97\u6539 std\uff0c\u5c31\u653e\u4e86\u4e2a \\mathcal{O}(\\log n \\cdot \\log (2^{60} - 1)) \\mathcal{O}(\\log n \\cdot \\log (2^{60} - 1)) \u7684\u590d\u6742\u5ea6\u7248\u672c Code #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } #define endl \"\\n\" #define all(A) A.begin(), A.end() using ll = long long ; using db = double ; using pII = pair < int , int > ; const int INF = 0x3f3f3f3f ; const ll INFLL = 0x3f3f3f3f3f3f3f3f ; const int N = 70 ; ll s , x ; int b [ N ]; int high ; // n:limit of high, m limit of low bool ok ( ll n , ll m ) { ll remind = 0 ; for ( int i = 59 ; i >= 0 ; -- i ) { remind <<= 1 ; remind += b [ i ]; if ( i > high ) continue ; ll dec = ( i == high ? n : m ); remind = max ( 0l l , remind - dec ); if ( remind & 1 ) { if ( ! dec ) return false ; remind ++ ; } } return remind == 0 ; } bool check ( ll n ) { for ( int i = 0 ; i <= 5 ; ++ i ) { if ( n - i >= 0 && ok ( n - i , i )) { return true ; } } return false ; } void RUN () { cin >> s >> x ; if ( s < x || ( s - x ) % 2 == 1 ) { cout << -1 << endl ; return ; } if ( s == x && s == 0 ) { cout << 0 << endl ; return ; } memset ( b , 0 , sizeof b ); high = 0 ; for ( int i = 0 ; i < 60 ; ++ i ) { b [ i ] = ( x >> i & 1 ) + (( s - x ) >> i & 2 ); if (( x >> i ) & 1 ) { high = max ( high , i ); } } ll l = 1 , r = s , res = -1 ; while ( r - l >= 0 ) { ll mid = ( l + r ) >> 1 ; if ( check ( mid )) { r = mid - 1 ; res = mid ; } else { l = mid + 1 ; } } cout << res << endl ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ), cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T ; cin >> _T ; while ( _T -- ) { RUN (); } return 0 ; }","title":"\u601d\u8def"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#f-hsueh--love-matrix","text":"","title":"F. Hsueh- Love Matrix"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u9898\u610f_5","text":"\u7ed9\u51fa\u4e00\u4e2a n \\cdot m n \\cdot m \u7684\u77e9\u9635\uff0c\u5176\u4e2d\u77e9\u9635\u5143\u7d20 a_{i, j} = i \\cdot j a_{i, j} = i \\cdot j \u3002\u8be2\u95ee\u77e9\u9635\u4e2d\u7b2c k k \u5927\u7684\u5143\u7d20\u662f\u591a\u5c11\u3002 1 \\leq n, m \\leq 10^9, 1 \\leq k \\leq n \\cdot m 1 \\leq n, m \\leq 10^9, 1 \\leq k \\leq n \\cdot m \u3002","title":"\u9898\u610f"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u601d\u8def_5","text":"\u6c42\u7b2c k k \u5927\u7684\u5143\u7d20\u7b49\u4ef7\u4e8e\u6c42\u7b2c n \\cdot m - k + 1 n \\cdot m - k + 1 \u5c0f\u7684\u5143\u7d20\u3002 \u90a3\u4e48\u6211\u4eec\u4e8c\u5206\u7b54\u6848 x x \uff0c\u7edf\u8ba1\u5c0f\u4e8e\u7b49\u4e8e x x \u7684\u5143\u7d20\u6709\u591a\u5c11\u4e2a\u3002 \u90a3\u4e48\u8fd9\u4e2a\u8ba1\u6570\uff0c\u5176\u5b9e\u7b49\u4ef7\u4e8e\u6c42\uff1a \\sum\\limits_{i = 1}^n \\min(m, \\lfloor \\frac{x}{i} \\rfloor) \\sum\\limits_{i = 1}^n \\min(m, \\lfloor \\frac{x}{i} \\rfloor) \u90a3\u4e48\u8fd9\u4e2a\u4e1c\u897f\u7528\u6570\u8bba\u5206\u5757\uff0c\u5c31\u53ef\u4ee5\u5728 \\mathcal{O}(\\sqrt{x}) \\mathcal{O}(\\sqrt{x}) \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e0b\u5b8c\u6210\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head ll n , m , k ; bool ok ( ll x ) { ll tot = 0 ; for ( int i = 1 , j ; i <= min ( n , x ); i = j + 1 ) { j = min ( n , x / ( x / i )); tot += 1l l * ( j - i + 1 ) * min ( m , x / i ); } return tot >= k ; } void run () { rd ( n , m , k ); k = n * m - k + 1 ; if ( n > m ) swap ( n , m ); ll l = 1 , r = min ( n * m , 10000000000l l ), res = r ; // ll l = 1, r = n * m, res = r; while ( r - l >= 0 ) { ll mid = ( l + r ) >> 1 ; if ( ok ( mid )) { r = mid - 1 ; res = mid ; } else { l = mid + 1 ; } } // pt(res); if ( res > 9999999999l l ) pt ( \"Oops\" ); else pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#g-lts-owns-large-quantities-of-apples","text":"","title":"G. LTS owns large quantities of apples"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u9898\u610f_6","text":"\u6709 n n \u4e2a\u82f9\u679c\uff0c m m \u4e2a\u5b69\u5b50\u3002 \u7b2c\u4e00\u4e2a\u5b69\u5b50\u62ff\u5230\u4e86 n n \u4e2a\u82f9\u679c\uff0c\u4ed6\u5403\u6389\u4e86\u4e00\u4e0b\uff0c\u53d1\u73b0\u5269\u4e0b\u7684\u82f9\u679c\u80fd\u6070\u597d\u5206\u6210 x x \u5806\uff0c\u4ed6\u62ff\u8d70\u4e86\u4e00\u5806\uff0c\u5c06\u5269\u4e0b\u7684 (x - 1) (x - 1) \u5806\u7ed9\u7b2c\u4e8c\u4e2a\u5b69\u5b50\u3002 \u7b2c\u4e8c\u4e2a\u5b69\u5b50\u62ff\u5230\u4e86 \\displaystyle \\frac{(n - 1)(x - 1)}{x} \\displaystyle \\frac{(n - 1)(x - 1)}{x} \u4e2a\u82f9\u679c\uff0c\u5403\u6389\u4e86\u4e00\u4e2a\uff0c\u53d1\u73b0\u5269\u4e0b\u7684\u82f9\u679c\u80fd\u6070\u597d\u5206\u6210 x x \u5806\uff0c\u4ed6\u62ff\u8d70\u4e86\u4e00\u5806\uff0c\u5c06\u5269\u4e0b\u7684 (x - 1) (x - 1) \u5806\u7ed9\u7b2c\u4e09\u4e2a\u5b69\u5b50\u3002 \\cdots \\cdots \u7b2c i i \u4e2a\u5b69\u5b50\u62ff\u5230\u4e86\u7b2c (i - 1) (i - 1) \u4e2a\u5b69\u5b50\u7ed9\u4ed6\u7684\u82f9\u679c\uff0c\u5403\u6389\u4e86\u4e00\u4e2a\uff0c\u53d1\u73b0\u5269\u4e0b\u7684\u82f9\u679c\u80fd\u6070\u597d\u5206\u6210 x x \u5806\uff0c\u62ff\u8d70\u4e86\u4e00\u5806\uff0c\u5c06\u5269\u4e0b\u7684 (x - 1) (x - 1) \u5806\u7ed9\u7b2c (i + 1) (i + 1) \u4e2a\u5b69\u5b50\u3002 \\cdots \\cdots \u6700\u540e\u4e00\u4e2a\u5b69\u5b50\u62ff\u5230\u4e86\u5012\u6570\u7b2c\u4e8c\u4e2a\u5b69\u5b50\u7ed9\u4ed6\u7684\u82f9\u679c\uff0c\u5403\u6389\u4e86\u4e00\u4e2a\uff0c\u53d1\u73b0\u5269\u4e0b\u7684\u82f9\u679c\u80fd\u6070\u597d\u5206\u6210 x x \u5806\uff0c\u62ff\u8d70\u4e86\u4e00\u5806\uff0c\u7136\u540e\u7559\u4e0b\u4e86 (x - 1) (x - 1) \u5806\uff0c\u5c31\u79bb\u5f00\u4e86\u3002 \u73b0\u5728\u7ed9\u51fa m(1 \\leq m \\leq 15), x(2 \\leq x \\leq 15) m(1 \\leq m \\leq 15), x(2 \\leq x \\leq 15) \uff0c\u8981\u6c42\u7ed9\u51fa\u4e00\u4e2a\u5c0f\u4e8e\u7b49\u4e8e 10^{18} 10^{18} \u7684\u5408\u6cd5\u7684\u4e00\u4e2a n n \u3002","title":"\u9898\u610f"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u601d\u8def_6","text":"\u4e00\u4e2a\u5408\u6cd5\u7684\u89e3\u662f\uff1a x^m - (x - 1) x^m - (x - 1) \u4f46\u662f x = 2 x = 2 \u7684\u65f6\u5019 \u548c m = 1 m = 1 \u7684\u65f6\u5019\u8981\u7279\u5224\u4e00\u4e0b\u3002 \u6211\u4eec\u8003\u8651 f(i) f(i) \u8868\u793a\u7b2c i i \u4e2a\u5c0f\u670b\u53cb\u62ff\u5230\u7684\u82f9\u679c\u6570\u91cf\uff0c\u90a3\u4e48\u6709\uff1a \\begin{eqnarray*} f(1) &=& x^m - x + 1 = x^m - (x - 1)\\\\ f(2) &=& x^m - x^{m - 1} - (x - 1) = x^{m - 1}(x - 1) - (x - 1)\\\\ f(3) &=& x^m - 2x^{m - 1} + x^{m - 2} - (x - 1) = x^{m - 2}(x - 1)^2 - (x - 1)\\\\ f(4) &=& x^m - 3x^{m - 1} + 3x^{m - 2} - x^{m - 3} - (x - 1) = x^{m - 3}(x - 1)^3 - (x - 1)\\\\ f(5) &=& \\cdots \\end{eqnarray*} \\begin{eqnarray*} f(1) &=& x^m - x + 1 = x^m - (x - 1)\\\\ f(2) &=& x^m - x^{m - 1} - (x - 1) = x^{m - 1}(x - 1) - (x - 1)\\\\ f(3) &=& x^m - 2x^{m - 1} + x^{m - 2} - (x - 1) = x^{m - 2}(x - 1)^2 - (x - 1)\\\\ f(4) &=& x^m - 3x^{m - 1} + 3x^{m - 2} - x^{m - 3} - (x - 1) = x^{m - 3}(x - 1)^3 - (x - 1)\\\\ f(5) &=& \\cdots \\end{eqnarray*} \u53ef\u4ee5\u63a8\u65ad\u51fa\uff1a \\begin{eqnarray*} f(m) &=& x(x - 1)^{m - 1} - (x - 1) \\end{eqnarray*} \\begin{eqnarray*} f(m) &=& x(x - 1)^{m - 1} - (x - 1) \\end{eqnarray*} \u6211\u4eec\u518d\u8003\u8651\u5012\u7740\u63a8\uff1a \\begin{eqnarray*} f(m) &=& x(x - 1)^{m - 1} - (x - 1) \\\\ f(m - 1) &=& x^2(x - 1)^{m - 1} - (x - 1) \\end{eqnarray*} \\begin{eqnarray*} f(m) &=& x(x - 1)^{m - 1} - (x - 1) \\\\ f(m - 1) &=& x^2(x - 1)^{m - 1} - (x - 1) \\end{eqnarray*} \u6211\u4eec\u53d1\u73b0 -(x - 1) -(x - 1) \u975e\u5e38\u5de7\u5999\uff0c\u56e0\u4e3a \\displaystyle -(x - 1) \\cdot \\frac{x}{x - 1} + 1 = -(x - 1) \\displaystyle -(x - 1) \\cdot \\frac{x}{x - 1} + 1 = -(x - 1) \u5b83\u5728\u8fd9\u4e00\u6b65\u64cd\u4f5c\u4e2d\u5e76\u6ca1\u6709\u53d8\u5316\uff0c\u4f46\u662f\u56e0\u4e3a\u5b83\u662f\u8d1f\u6570\uff0c\u6240\u4ee5 f(m) = A - (x - 1) f(m) = A - (x - 1) \uff0c\u6211\u4eec\u9700\u8981\u52a0\u4e0a\u4e00\u4e2a A A \u4f7f\u5f97 f(m) f(m) \u53d8\u6210\u6b63\u6570\u3002 \u6211\u4eec\u518d\u8003\u8651 f(m) f(m) \u8fd8\u6709\u4ec0\u4e48\u9650\u5236\uff1a \\begin{eqnarray*} f(m) &\\equiv& 0 \\bmod x \\\\ f(m) &\\equiv& 0 \\bmod (x - 1)^{m - 1} \\end{eqnarray*} \\begin{eqnarray*} f(m) &\\equiv& 0 \\bmod x \\\\ f(m) &\\equiv& 0 \\bmod (x - 1)^{m - 1} \\end{eqnarray*} \u53c8\u56e0\u4e3a gcd(x, x - 1) = 1 gcd(x, x - 1) = 1 \uff0c\u6240\u4ee5 A = x \\cdot (x - 1)^{m - 1} A = x \\cdot (x - 1)^{m - 1} \u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head int m , x ; ll POW ( ll base , int n ) { ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base ; base = base * base ; n >>= 1 ; } return res ; } void run () { rd ( m , x ); if ( m == 1 ) pt ( x + 1 ); else if ( x == 2 ) { ll res = 1 ; for ( int i = 1 ; i <= m ; ++ i ) { res = res * 2 + 1 ; } pt ( res ); } else { ll res = POW ( x , m ) - ( x - 1 ); pt ( res ); } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#h-hsueh--and-keyboard","text":"","title":"H. Hsueh- and keyboard"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u9898\u610f_7","text":"\u6587\u672c\u6846\u91cc\u521a\u5f00\u59cb\u6709\u4e00\u4e2a\u957f\u5ea6\u4e3a x x \u7684\u5b57\u7b26\u4e32\uff0c\u73b0\u5728\u8981\u6c42\u5f97\u5230\u4e00\u4e2a\u957f\u5ea6\u4e3a n n \u7684\u5b57\u7b26\u4e32\u3002 0 \\leq x \\leq 10^6, 1 \\leq n \\leq 10^6 0 \\leq x \\leq 10^6, 1 \\leq n \\leq 10^6 \u3002 \u4f60\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u64cd\u4f5c\u8fbe\u6210\u76ee\u6807\uff1a \u6309\u4e0b\u952e\u76d8\u4e00\u6b21\uff0c\u8f93\u5165\u4e00\u4e2a\u5b57\u7b26\u3002 \u6309\u4e0b\u952e\u76d8\u4e24\u6b21\uff08Ctrl + A), \u9009\u4e2d\u6587\u672c\u6846\u4e2d\u7684\u6240\u6709\u5b57\u7b26\u3002 \u6309\u4e0b\u952e\u76d8\u4e24\u6b21\uff08Ctrl + C), \u590d\u5236\u9009\u4e2d\u7684\u5b57\u7b26\u5230\u526a\u8d34\u677f\u3002 \u6309\u4e0b\u952e\u76d8\u4e24\u6b21\uff08Ctrl + V), \u5c06\u526a\u8d34\u677f\u4e2d\u7684\u5b57\u7b26\u7c98\u8d34\u5230\u6587\u672c\u6846\u3002 \u6309\u4e0b\u952e\u76d8\u4e00\u6b21\uff08Backspace), \u5220\u9664\u6587\u672c\u6846\u4e2d\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\u6216\u8005\u5220\u9664\u9009\u4e2d\u7684\u5b57\u7b26\uff0c\u5982\u679c\u5728\u8fd9\u4e4b\u524d\u4f60\u6309\u4e0b\u4e86\uff08Ctrl + A\uff09\u9009\u4e2d\u4e86\u4e00\u4e9b\u5b57\u7b26\u7684\u8bdd\u3002 \u6b64\u5904\u7684\u64cd\u4f5c\u548c\u4f20\u7edf\u8ba4\u77e5\u6709\u6240\u4e0d\u540c\u7684\u662f\uff0c\u5982\u679c\u4f60\u5148\u6309\u4e0b\u4e86\uff08Ctrl + A\uff09\u9009\u4e2d\u4e86\u6240\u6709\u5b57\u7b26\uff0c\u518d\u8f93\u5165\u4e00\u4e2a\u5b57\u7b26\uff0c\u6216\u8005\u7c98\u8d34\u526a\u8d34\u677f\u4e2d\u7684\u6587\u5b57\u5230\u6587\u672c\u6846\uff0c\u90a3\u4e48\u5b83\u4e0d\u4f1a\u4ea7\u751f\u66ff\u6362\u9009\u4e2d\u6587\u5b57\u7684\u6548\u679c\uff0c\u800c\u662f\u4f1a\u76f4\u63a5\u5f53\u524d\u5b57\u7b26\u4e32\u8ffd\u52a0\u5728\u540e\u9762\u3002 \u6216\u8005\u4f60\u53ef\u4ee5\u8ba4\u4e3a\uff08Ctrl + A\uff09\u53ea\u4f1a\u5bf9\u590d\u5236\u64cd\u4f5c\u6709\u6548\u3002","title":"\u9898\u610f"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u601d\u8def_7","text":"\u4ece x x \u53d8\u5230 n n \uff0c\u6211\u4eec\u5c06\u53d8\u91cf\u6362\u6210 s s \u548c t t \uff0c\u90a3\u4e48\u5c31\u662f\u4ece s s \u5230 t t \uff0c\u8db3\u8db3\u50cf\u4e00\u4e2a\u6700\u77ed\u8def\u5462\u3002 \u663e\u7136\uff0c\u9009\u4e2d\u3001\u590d\u5236\u3001\u7c98\u8d34\u80af\u5b9a\u662f\u8fde\u7740\u7528\uff0c\u4e0d\u4f1a\u51fa\u73b0\u5148\u590d\u5236\uff0c\u7136\u540e\u7c98\u8d34\uff0c\u7136\u540e\u8fdb\u884c\u4e00\u4e9b\u5176\u4ed6\u7684\u64cd\u4f5c\uff0c\u7136\u540e\u518d\u590d\u5236\u3002\u4f46\u662f\u7c98\u8d34\u53ef\u80fd\u4f1a\u7c98\u8d34\u591a\u6b21\u3002 \u9009\u4e2d\u548c\u5220\u9664\u4e5f\u662f\u8fde\u7740\u7528\u3002 \u90a3\u4e48\u76f4\u63a5\u5efa\u56fe\u8fde\u8fb9\u5373\u53ef\uff0c\u6bd4\u5982\uff1a \u7b2c\u4e00\u79cd\u64cd\u4f5c\uff1a\u5c31\u662f i i \u5411 (i + 1) (i + 1) \u8fde\u8fb9\u3002 \u9009\u4e2d\u3001\u590d\u5236\u3001\u7c98\u8d34\uff0c\u5c31\u662f i i \u5230 2i, 3i, \\cdots 2i, 3i, \\cdots \u8fde\u8fb9\u3002 \u5220\u9664\uff0c\u5c31\u662f i i \u5411 (i - 1) (i - 1) \u8fde\u8fb9\uff0c\u6216\u8005 i i \u5411 0 0 \u8fde\u8fb9\u3002 \u6ce8\u610f\u52a0\u4e0a\u8fb9\u6743\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1000000 + 200 ; const int inf = 0x7ffffff ; struct edge { int from , to , w , next ; } e [ N * 20 ]; int head [ N ]; int vis [ N ]; int dist [ N ]; int n , m , t , x ; void add ( int i , int j , int w ) { e [ t ]. from = i ; e [ t ]. to = j ; e [ t ]. w = w ; e [ t ]. next = head [ i ]; head [ i ] = t ++ ; } struct E { int to , w ; E () {} E ( int to , int w ) : to ( to ), w ( w ) {} bool operator < ( const E & other ) const { return w > other . w ; } }; void dijkstra ( int s ) { priority_queue < E > pq ; for ( int i = 0 ; i <= n ; ++ i ) { dist [ i ] = inf ; } dist [ s ] = 0 ; pq . push ( E ( s , 0 )); memset ( vis , 0 , sizeof vis ); while ( ! pq . empty ()) { int u = pq . top (). to ; pq . pop (); if ( u == m ) return ; if ( vis [ u ]) continue ; vis [ u ] = 1 ; for ( int i = head [ u ]; i != -1 ; i = e [ i ]. next ) { int v = e [ i ]. to ; if ( ! vis [ v ] && dist [ v ] > dist [ u ] + e [ i ]. w ) { dist [ v ] = dist [ u ] + e [ i ]. w ; pq . push ( E ( v , dist [ v ])); } } } } int main () { scanf ( \"%d%d\" , & x , & m ); if ( x > m ) n = x + 100 ; else n = m + 100 ; t = 0 ; memset ( head , -1 , sizeof ( head )); for ( int i = 0 ; i < n ; ++ i ) { add ( i , i + 1 , 1 ); add ( i + 1 , i , 1 ); add ( i + 1 , 0 , 3 ); for ( int j = 2 ; i * j <= n && i != 0 ; ++ j ) add ( i , i * j , 2 + 2 * j ); } dijkstra ( x ); // for (int i = 0; i <= n - 100; ++i) printf(\"%d %d\\n\", i, dist[i]); printf ( \"%d \\n \" , dist [ m ]); return 0 ; }","title":"\u601d\u8def"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#i-lts-and-rectangular-area-union","text":"","title":"I. LTS and rectangular area union"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u9898\u610f_8","text":"\u7ed9\u51fa n n \u4e2a\u77e9\u5f62\uff0c\u4ee4 P_i P_i \u8868\u793a\u524d i i \u4e2a\u77e9\u5f62\u7684\u9762\u79ef\u5e76\uff0c\u6c42 (P_1 \\times P_2 \\times P_3 \\times \\cdots \\times P_n) \\bmod 998244353 (P_1 \\times P_2 \\times P_3 \\times \\cdots \\times P_n) \\bmod 998244353 \u3002 \u7ed9\u51fa\u7684\u77e9\u5f62\u7684\u4e0b\u5e95\u8fb9\u4f4d\u4e8e\u540c\u4e00\u6c34\u5e73\u7ebf\u4e0a\u5373\u5de6\u4e0b\u89d2\u4e3a (L_i, 0) (L_i, 0) , \u53f3\u4e0a\u89d2\u4e3a (R_i, H_i) (R_i, H_i) \uff0c\u5e76\u4e14\u9ad8\u5ea6\u975e\u9012\u589e\u3002 1 \\leq n \\leq 10^6 1 \\leq n \\leq 10^6 \u3002","title":"\u9898\u610f"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u601d\u8def_8","text":"\u65e2\u7136\u9ad8\u5ea6\u975e\u9012\u589e\uff0c\u90a3\u4e48\u8bf4\u660e\u7b2c i i \u4e2a\u77e9\u5f62\u7684\u9ad8\u5ea6\u5c0f\u4e8e\u7b49\u4e8e\u524d i i \u4e2a\u77e9\u5f62\u7684\u9ad8\u5ea6\u3002 \u4e5f\u5c31\u662f\u8bf4\u5f53\u5904\u7406\u5230\u7b2c i i \u4e2a\u77e9\u5f62\u7684\u65f6\u5019\uff0c\u9ad8\u5ea6\u5728 H_i H_i \u4ee5\u4e0a\u7684\u9762\u79ef\u4e0d\u7528\u7ba1\uff0c\u5b83\u4eec\u4e0d\u4f1a\u53d1\u751f\u53d8\u5316\u3002 \u4f1a\u53d1\u751f\u53d8\u5316\u7684\u662f\u54ea\u4e00\u90e8\u5206\uff1f\u5176\u5b9e\u5c31\u662f (L_i, R_i) (L_i, R_i) \u8fd9\u4e2d\u95f4\u7684\uff0c\u6ca1\u6709\u88ab\u4e4b\u524d\u4efb\u4f55\u4e00\u4e2a\u77e9\u5f62\u8986\u76d6\u7684\u5730\u65b9\uff0c\u5b83\u5728\u6bcf\u4e00\u4e2a\u5782\u76f4\u65b9\u5411\u90fd\u4f1a\u4ea7\u751f H_i H_i \u7684\u8d21\u732e\u3002 \u90a3\u4e48\u53ef\u4ee5\u7528 set \u7ef4\u62a4\u4e00\u4e2a (l_i, r_i) (l_i, r_i) \uff0c\u4e8c\u5143\u7ec4\uff0c\u8868\u793a\u4e4b\u524d\u66fe\u88ab\u8986\u76d6\u8fc7\u7684\u4e00\u6bb5\u533a\u95f4\uff0c\u5f53\u65b0\u52a0\u5165\u4e00\u4e2a (L_j, R_j) (L_j, R_j) \u65f6\uff0c\u5c06 set \u4e2d\u4e0e (L_j, R_j) (L_j, R_j) \u6709\u5305\u542b\u5173\u7cfb\u6216\u8005\u76f8\u4ea4\u5173\u7cfb\u7684\uff0c\u90fd\u5408\u5e76\u6389\uff0c\u5e76\u4e14\u987a\u4fbf\u7b97\u4e00\u4e0b\u8d21\u732e\u5373\u53ef\u3002 \u663e\u7136\u6bcf\u4e2a\u4e8c\u5143\u7ec4\u53ea\u4f1a\u88ab\u52a0\u5165\u4e00\u6b21\uff0c\u5408\u5e76\u4e00\u6b21\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 \\mathcal{O}(n \\log n) \\mathcal{O}(n \\log n) \u3002 \u4e5f\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u6765\u5b8c\u6210\u8fd9\u4e2a\u64cd\u4f5c\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 998244353 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e6 + 10 ; int n ; struct E { ll l , r , h ; E () {} E ( ll l , ll r , ll h ) : l ( l ), r ( r ), h ( h ) {} bool operator < ( const E & other ) const { return l < other . l ; } } e [ N ]; void run () { rd ( n ); for ( int i = 1 ; i <= n ; ++ i ) rd ( e [ i ]. l , e [ i ]. r , e [ i ]. h ); ll res = 1 ; ll area = 0 ; set < E > se ; for ( int i = 1 ; i <= n ; ++ i ) { ll l = e [ i ]. l , r = e [ i ]. r , h = e [ i ]. h ; if ( se . empty ()) { se . insert ( E ( l , r , h )); chadd ( area , ( r - l ) * h % mod ); } else { auto pos = se . upper_bound ( E ( l , l , 0 )); if ( pos != se . begin ()) pos = prev ( pos ); vector < E > vec ; while ( pos != se . end ()) { auto nx = next ( pos ); if (( pos -> l >= l && pos -> l <= r ) || ( pos -> r >= l && pos -> r <= r ) || ( l >= pos -> l && l <= pos -> r ) || ( r >= pos -> l && r <= pos -> r )) { vec . push_back ( * pos ); se . erase ( pos ); pos = nx ; } else { if ( pos -> l > r ) break ; else pos = nx ; } } if ( vec . empty ()) { se . insert ( E ( l , r , h )); chadd ( area , ( r - l ) * h % mod ); } else { ll _l = l , _r = r ; for ( auto & it : vec ) { chmin ( _l , it . l ); chmax ( _r , it . r ); chadd ( area , mod - ( min ( r , it . r ) - max ( l , it . l )) * h % mod ); } chadd ( area , ( r - l ) * h % mod ); se . insert ( E ( _l , _r , h )); } } res = res * area % mod ; } pt ( res ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( _T -- ) run (); return 0 ; }","title":"\u601d\u8def"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#j-hsueh--owns-large-quantities-of-apples","text":"","title":"J. Hsueh- owns large quantities of apples"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u9898\u610f_9","text":"\u6709 n n \u4e2a\u82f9\u679c\uff0c m m \u4e2a\u5b69\u5b50\u3002 \u7b2c\u4e00\u4e2a\u5b69\u5b50\u62ff\u5230\u4e86 n n \u4e2a\u82f9\u679c\uff0c\u4ed6\u5403\u6389\u4e86\u4e00\u4e0b\uff0c\u53d1\u73b0\u5269\u4e0b\u7684\u82f9\u679c\u80fd\u6070\u597d\u5206\u6210 x x \u5806\uff0c\u4ed6\u62ff\u8d70\u4e86 (x - 1) (x - 1) \u5806\uff0c\u5c06\u5269\u4e0b\u7684\u4e00\u5806\u7ed9\u7b2c\u4e8c\u4e2a\u5b69\u5b50\u3002 \u7b2c\u4e8c\u4e2a\u5b69\u5b50\u62ff\u5230\u4e86 \\displaystyle \\frac{(n - 1)}{x} \\displaystyle \\frac{(n - 1)}{x} \u4e2a\u82f9\u679c\uff0c\u5403\u6389\u4e86\u4e00\u4e2a\uff0c\u53d1\u73b0\u5269\u4e0b\u7684\u82f9\u679c\u80fd\u6070\u597d\u5206\u6210 x x \u5806\uff0c\u4ed6\u62ff\u8d70\u4e86 (x - 1) (x - 1) \u5806\uff0c\u5c06\u5269\u4e0b\u7684\u4e00\u5806\u7ed9\u7b2c\u4e09\u4e2a\u5b69\u5b50\u3002 \\cdots \\cdots \u7b2c i i \u4e2a\u5b69\u5b50\u62ff\u5230\u4e86\u7b2c (i - 1) (i - 1) \u4e2a\u5b69\u5b50\u7ed9\u4ed6\u7684\u82f9\u679c\uff0c\u5403\u6389\u4e86\u4e00\u4e2a\uff0c\u53d1\u73b0\u5269\u4e0b\u7684\u82f9\u679c\u80fd\u6070\u597d\u5206\u6210 x x \u5806\uff0c\u62ff\u8d70\u4e86 (x - 1) (x - 1) \u5806\uff0c\u5c06\u5269\u4e0b\u7684\u4e00\u5806\u7ed9\u7b2c (i + 1) (i + 1) \u4e2a\u5b69\u5b50\u3002 \\cdots \\cdots \u6700\u540e\u4e00\u4e2a\u5b69\u5b50\u62ff\u5230\u4e86\u5012\u6570\u7b2c\u4e8c\u4e2a\u5b69\u5b50\u7ed9\u4ed6\u7684\u82f9\u679c\uff0c\u5403\u6389\u4e86\u4e00\u4e2a\uff0c\u53d1\u73b0\u5269\u4e0b\u7684\u82f9\u679c\u80fd\u6070\u597d\u5206\u6210 x x \u5806\uff0c\u62ff\u8d70\u4e86 (x - 1) (x - 1) \u5806\uff0c\u7136\u540e\u7559\u4e0b\u4e86\u4e00\u5806\uff0c\u5c31\u79bb\u5f00\u4e86\u3002 1 \\leq m \\leq 10^9, 2 \\leq x \\leq 10^9 1 \\leq m \\leq 10^9, 2 \\leq x \\leq 10^9 , \u6c42\u6700\u5c0f\u7684 n n \u3002","title":"\u9898\u610f"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u601d\u8def_9","text":"\u8003\u8651\u6700\u540e\u4e00\u4e2a\u5b69\u5b50\u4ece\u5012\u6570\u7b2c\u4e8c\u4e2a\u5b69\u5b50\u5f97\u5230\u7684\u82f9\u679c\u6570\u91cf\u4e3a a_m a_m , \u90a3\u4e48\u5012\u6570\u7b2c\u4e8c\u4e2a\u5b69\u5b50\u7684\u62ff\u5230\u7684\u82f9\u679c\u6570\u91cf\u4e3a a_{m - 1} = x \\cdot a_m + 1 a_{m - 1} = x \\cdot a_m + 1 \uff0c\u5012\u6570\u7b2c\u4e09\u4e2a\u5b69\u5b50\u7684\u62ff\u5230\u7684\u82f9\u679c\u6570\u91cf\u4e3a a_{m - 2} = x \\cdot a_{m - 1} + 1 a_{m - 2} = x \\cdot a_{m - 1} + 1 \u3002 \u90a3\u4e48\u53ea\u8981\u8ba9 a_m a_m \u6700\u5c0f\uff0c\u5c31\u53ef\u4ee5\u8ba9 a_1 a_1 \u6700\u5c0f\uff0c\u5373 n n \u6700\u5c0f\u3002 \u663e\u7136 a_m a_m \u6700\u5c0f\u4e3a x + 1 x + 1 , \u7136\u540e\u77e9\u9635\u5feb\u901f\u5e42\u6c42 a_1 a_1 \u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 998244353 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head constexpr int N = 1e2 + 10 ; ll m , x ; struct M { int a [ 5 ][ 5 ]; M () { memset ( a , 0 , sizeof a ); } M operator * ( const M & other ) const { M res = M (); for ( int i = 1 ; i <= 2 ; ++ i ) { for ( int j = 1 ; j <= 2 ; ++ j ) { for ( int k = 1 ; k <= 2 ; ++ k ) { chadd ( res . a [ i ][ j ], 1l l * a [ i ][ k ] * other . a [ k ][ j ] % mod ); } } } return res ; } } base , res ; void qpow ( ll n ) { while ( n ) { if ( n & 1 ) res = res * base ; base = base * base ; n >>= 1 ; } pt ( res . a [ 1 ][ 1 ]); } void run () { rd ( m , x ); base = M (); res = M (); base . a [ 1 ][ 1 ] = x ; base . a [ 2 ][ 1 ] = 1 ; base . a [ 2 ][ 2 ] = 1 ; res . a [ 1 ][ 1 ] = 1 ; res . a [ 1 ][ 2 ] = 1 ; qpow ( m ); } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = nextInt (); while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; } \u4f46\u5176\u5b9e\u6572\u4e2a\u77e9\u9635\u5feb\u901f\u5e42\uff0c\u4ee3\u7801\u8fd8\u662f\u6bd4\u8f83\u957f\u7684\u3002 \u6211\u4eec\u56de\u987e\u89e3\u6cd5\uff0c\u62bd\u8c61\u4e00\u4e0b\uff0c\u5176\u5b9e\u5c31\u662f\u6c42\u8fd9\u4e2a\u4e1c\u897f\uff1a \u4ee4 a_0 = 1 a_0 = 1 , \u6709 a_i = x \\cdot a_{i - 1} + 1 a_i = x \\cdot a_{i - 1} + 1 \uff0c\u7136\u540e\u8981\u6c42 a_m a_m \u3002 \u6211\u4eec\u63a8\u4e00\u63a8\u53d1\u73b0\uff1a \\begin{eqnarray*} a_0 &=& 1 \\\\ a_1 &=& x \\cdot a_0 + 1 = x + 1 \\\\ a_2 &=& x \\cdot a_1 + 1 = x^2 + x + 1 \\\\ a_3 &=& x \\cdot a_2 + 1 = x^3 + x^2 + x + 1 \\\\ &\\cdots& \\\\ a_m &=& \\sum\\limits_{i = 0}^{m} x^i \\end{eqnarray*} \\begin{eqnarray*} a_0 &=& 1 \\\\ a_1 &=& x \\cdot a_0 + 1 = x + 1 \\\\ a_2 &=& x \\cdot a_1 + 1 = x^2 + x + 1 \\\\ a_3 &=& x \\cdot a_2 + 1 = x^3 + x^2 + x + 1 \\\\ &\\cdots& \\\\ a_m &=& \\sum\\limits_{i = 0}^{m} x^i \\end{eqnarray*} \u5176\u5b9e\u5c31\u662f\u7b49\u6bd4\u6570\u5217\u6c42\u548c\u3002","title":"\u601d\u8def"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#k-lts-buy-wine","text":"","title":"K. LTS buy wine"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u9898\u610f_10","text":"\u7ed9\u51fa n n \u74f6\u7ea2\u9152\uff0c\u4ece\u5de6\u81f3\u53f3\u4f9d\u6b21\u6392\u5217\uff0c\u6807\u53f7\u4e3a 1 1 \u5230 n n , \u7b2c i i \u74f6\u7ea2\u9152\u7684\u521d\u59cb\u4ef7\u503c\u4e3a v_i v_i \uff0c\u7b2c t t \u5929\u53ef\u4ee5\u4ece\u6700\u5de6\u8fb9\u6216\u8005\u6700\u53f3\u8fb9\u53d6\u4e00\u74f6\u7ea2\u9152\uff0c\u5047\u8bbe\u53d6\u5230\u6807\u53f7\u4e3a j j \u7684\u7ea2\u9152\uff0c\u5f97\u5230\u7684\u4ef7\u503c\u4e3a t \\cdot v_j t \\cdot v_j \u3002\u95ee\u53d6\u5b8c\u6240\u6709\u7ea2\u9152\u540e\uff0c\u5f97\u5230\u7684\u6700\u5927\u603b\u4ef7\u503c\u662f\u591a\u5c11\uff1f","title":"\u9898\u610f"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u601d\u8def_10","text":"f_{l, r} f_{l, r} \u8868\u793a\u5df2\u7ecf\u53d6\u5149\u533a\u95f4 [l, r] [l, r] \u8303\u56f4\u5185\u7684\u7ea2\u9152\u7684\u6700\u5927\u4ef7\u503c\u662f\u591a\u5c11\uff0c\u6bcf\u6b21\u53ef\u4ee5\u5f80 f_{l - 1, r} f_{l - 1, r} \u6216\u8005 f_{l, r + 1} f_{l, r + 1} \u8f6c\u79fb\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 2000 + 10 ; ll a [ N ]; ll f [ N ][ N ]; int main () { int n ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld\" , & a [ i ]); f [ i ][ i ] = a [ i ] * n ; } for ( int len = 2 ; len <= n ; ++ len ) for ( int i = 1 ; i <= n - len + 1 ; ++ i ) { int j = i + len - 1 ; ll x = f [ i ][ j - 1 ] + a [ j ] * ( n - ( j - i + 1 ) + 1 ); ll y = f [ i + 1 ][ j ] + a [ i ] * ( n - ( j - i + 1 ) + 1 ); if ( x > y ) f [ i ][ j ] = x ; else f [ i ][ j ] = y ; } printf ( \"%lld \\n \" , f [ 1 ][ n ]); return 0 ; }","title":"\u601d\u8def"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#l-line-problem","text":"","title":"L. Line problem"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u9898\u610f_11","text":"\u95ee\u4e8c\u7ef4\u5e73\u9762\u4e0a\u4e24\u4e2a\u7ebf\u6bb5\u76f8\u4ea4\u957f\u5ea6\uff0c\u76f8\u4ea4\u4e00\u70b9\u5219\u76f8\u4ea4\u957f\u5ea6\u4e3a 0 0 \u3002","title":"\u9898\u610f"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u601d\u8def_11","text":"\u672c\u9898\u5b9a\u4e49\u4e3a\u51e0\u4f55\u7b7e\u5230\u9898 \u9996\u5148\u4e24\u6761\u7ebf\u6bb5\u6240\u5728\u76f4\u7ebf\u9700\u8981\u91cd\u5408\uff0c\u5426\u5219\u8f93\u51fa 0","title":"\u601d\u8def"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#m-rikka-with-random-graph","text":"","title":"M. Rikka with Random Graph"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u9898\u610f_12","text":"\u7ed9\u51fa\u4e00\u4e2a n n \u4e2a\u70b9\uff0c m m \u6761\u8fb9\u7684\u6709\u5411\u56fe\uff0c\u6709 q q \u6b21\u8be2\u95ee\uff0c\u6bcf\u6b21\u8be2\u95ee u u \u662f\u5426\u80fd\u591f\u5230\u8fbe v v \u3002 2 \\leq n \\leq 10^5, 1 \\leq m \\leq \\min(10^5, n \\cdot (n - 1)), 1 \\leq q \\leq 10^5 2 \\leq n \\leq 10^5, 1 \\leq m \\leq \\min(10^5, n \\cdot (n - 1)), 1 \\leq q \\leq 10^5 \u3002 \u56fe\u7684\u8fb9\u96c6\u662f\u901a\u8fc7\u4e00\u4e2a\u300c\u968f\u673a\u300d\u7684\u65b9\u6cd5\u751f\u6210\u3002 \u5f3a\u5236\u5728\u7ebf\u3002","title":"\u9898\u610f"},{"location":"problem-set/The-Hangzhou-Normal-U-Qualification-Trials-for-ZJPSC-2020/Editorial/#\u601d\u8def_12","text":"\u8fd9\u4e2a\u9898\u7684\u505a\u6cd5\uff0c\u5c31\u662f\u5f3a\u8fde\u901a\u7f29\u70b9\u4e4b\u540e\u53d8\u6210 DAG \uff0c\u7136\u540e\u6839\u636e\u62d3\u6251\u5e8f\u4f7f\u7528 bitset \u8fdb\u884c\u8f6c\u79fb\u53ef\u8fbe\u5173\u7cfb\u5373\u53ef\u3002 \u90a3\u7a7a\u95f4\u9700\u8981\u591a\u5927\uff1f \\frac{10^5 \\cdot 10^5 \\cdot 8}{64 \\cdot 1024 \\cdot 1024} \\approx 1192 \\frac{10^5 \\cdot 10^5 \\cdot 8}{64 \\cdot 1024 \\cdot 1024} \\approx 1192 \u9700\u8981 1192M 1192M \u7684\u5185\u5b58\uff0c\u663e\u7136\u9898\u76ee\u6ca1\u6709\u7ed9\u51fa\u90a3\u4e48\u5927\u3002 \u4f46\u5176\u5b9e\u91c7\u7528\u5206\u5757\u7684\u505a\u6cd5\uff0c\u53ef\u4ee5\u964d\u4f4e\u7a7a\u95f4\u590d\u6742\u5ea6\uff0c\u4f46\u662f\u9700\u8981\u79bb\u7ebf\u89e3\u51b3\u8be2\u95ee\u3002 \u90a3\u4e48\u6211\u4eec\u7684\u60f3\u6cd5\u662f\uff0c\u968f\u673a\u56fe\u662f\u5426\u5177\u6709\u6700\u5927\u7684\u5f31\u8fde\u901a\u5206\u91cf\u5927\u5c0f\u8f83\u5c0f\u7684\u6027\u8d28\uff1f \u6211\u4eec\u5728\u968f\u673a\u5f88\u591a\u6b21\u540e\u53d1\u73b0\uff0c\u968f\u673a\u56fe\u597d\u50cf\u6ca1\u6709\u8fd9\u4e2a\u6027\u8d28\uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u60f3\u653e\u5f03\u6211\u4eec\u63d0\u51fa\u7684\u89e3\u6cd5\uff0c\u4e8e\u662f\u624b\u52a8\u6784\u9020\u4e86\u4e00\u4e2a\u300c\u968f\u673a\u56fe\u300d\uff0c\u4f7f\u5f97\u5b83\u6ee1\u8db3\u8fd9\u79cd\u6027\u8d28\u3002 wnext() \u51fd\u6570\u7528\u4e8e\u751f\u6210\u5177\u6709\u504f\u79fb\u671f\u671b\u7684\u968f\u673a\u503c\uff0c\u5f53 t t \u8f83\u5927\u65f6\uff0c\u751f\u6210\u7684\u968f\u673a\u6570\u5728\u533a\u95f4\u8303\u56f4\u5185\u4e5f\u4f1a\u504f\u5927\u3002 \u5e76\u4e14\u6211\u4eec\u63a7\u5236\u4e86\u968f\u673a\u7684\u4e0a\u754c\uff0c\u4f7f\u5f97\u8fd9\u4e2a\u56fe\u7684\u8fde\u8fb9\u4e0d\u4f1a\u5230\u5904\u4ea4\u53c9\u8fde\u8fb9\uff0c\u800c\u662f\u4f1a\u5448\u73b0\u4e00\u4e2a\u5757\u72b6\u3002\u6700\u7ec8\u5f31\u8fde\u901a\u5206\u91cf\u7684\u6700\u5927\u5927\u5c0f\u88ab\u964d\u4f4e\u3002 \u867d\u7136\u6211\u4eec\u4e0d\u4f1a\u8bc1\u660e\uff0c\u4f46\u662f\u671f\u671b\u561b\uff0c\u53ea\u8981\u591a\u8dd1\u51e0\u6b21\u53d6\u5747\u503c\u5c31\u53ef\u4ee5\u770b\u6210\u671f\u671b\u4e86\u5427\uff08\u9003 \u7ecf\u8fc7\u7b80\u5355\u7684\u968f\u673a\u53d1\u73b0\uff0c\u5f53 n = 10^5, m = 10^5 n = 10^5, m = 10^5 \u7684\u65f6\u5019\uff0c\u5f31\u8fde\u901a\u5206\u91cf\u4e2a\u6570\u5927\u6982\u5728 8 \\cdot 10^4 8 \\cdot 10^4 \u5de6\u53f3\uff0c\u5f31\u8fde\u901a\u5206\u91cf\u6700\u5927\u5927\u5c0f\u5927\u6982\u5728 10^4 10^4 \u5de6\u53f3\u3002 \u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u6bcf\u4e2a\u5f31\u8fde\u901a\u5206\u91cf\u91cd\u65b0\u7f16\u53f7\u540e\u5206\u522b\u505a\uff0c\u8fd9\u6837\u9700\u8981\u7684\u7a7a\u95f4\u662f\uff1a \\frac{10^5 \\cdot 10^4 \\cdot 8}{64 \\cdot 1024 \\cdot 1024} \\approx 119 \\frac{10^5 \\cdot 10^4 \\cdot 8}{64 \\cdot 1024 \\cdot 1024} \\approx 119 \u7ef0\u7ef0\u6709\u4f59\u3002 \u90a3\u65e2\u7136\u5f31\u8fde\u901a\u5206\u91cf\u7684 size \u4e0d\u5927\uff0c\u90a3\u4e48\u6211\u5bf9\u6bcf\u6b21\u8be2\u95ee\uff0c\u76f4\u63a5 bfs \u884c\u4e0d\u884c\uff1f \u53ef\u4ee5\u662f\u53ef\u4ee5\uff0c\u800c\u4e14\u5e38\u6570\u5c0f\uff0c\u590d\u6742\u5ea6\u770b\u4e0a\u53bb\u4e5f\u4e0d\u5927\uff0c\u4e5f\u5c31 q q \u6b21\u8be2\u95ee\u4e58\u4e0a\u6700\u5927\u5f31\u8fde\u901a\u5206\u91cf\u5927\u5c0f\uff0c\u597d\u50cf\u4e5f\u5c31 10^9 10^9 \u3002 \u6211\u4e5f\u6ce8\u610f\u5230\u4e86\u8fd9\u79cd\u505a\u6cd5\uff0c\u4f46\u662f\u7528 bitset \u7684\u505a\u6cd5\u6bd4\u8f83\u5feb\uff0c\u6240\u4ee5\u628a\u8fd9\u79cd\u505a\u6cd5\u5361\u6389\u4e86\uff0c\u6240\u4ee5\u65f6\u9650\u53ef\u80fd\u6709\u70b9\u7d27\uff0c\u5927\u6982 2.5 2.5 \u500d\u65f6\u9650\u3002 \u6211\u4eec\u4ee4 \\_n = \\mbox{\u6700\u5927\u5f31\u8fde\u901a\u5206\u91cf\u5927\u5c0f} \\_n = \\mbox{\u6700\u5927\u5f31\u8fde\u901a\u5206\u91cf\u5927\u5c0f} \uff0c\u90a3\u4e48\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a \\displaystyle \\mathcal{O}(\\frac{(n + q) \\cdot \\_n}{w}) \\displaystyle \\mathcal{O}(\\frac{(n + q) \\cdot \\_n}{w}) \u3002 Code #include <bits/stdc++.h> using namespace std ; #define endl \"\\n\" #define fi first #define se second #define SZ(x) ((int)(x).size()) #define mkp make_pair #define all(x) (x).begin(), (x).end() using db = double ; using ll = long long ; using ull = unsigned long long ; using pII = pair < int , int > ; using pLL = pair < ll , ll > ; constexpr int mod = 1e9 + 7 ; template < class T1 , class T2 > inline void chadd ( T1 & x , T2 y , int Mod = mod ) { x += y ; while ( x >= Mod ) x -= Mod ; while ( x < 0 ) x += Mod ; } template < class T1 , class T2 > inline void chmax ( T1 & x , T2 y ) { if ( x < y ) x = y ; } template < class T1 , class T2 > inline void chmin ( T1 & x , T2 y ) { if ( x > y ) x = y ; } inline int nextInt () { int x ; cin >> x ; return x ; } void rd () {} template < class T , class ... Ts > void rd ( T & arg , Ts & ... args ) { cin >> arg ; rd ( args ...); } #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } template < template < typename ... > class T , typename t , typename ... A > void err ( const T < t > & arg , const A & ... args ) { for ( auto & v : arg ) cout << v << ' ' ; err ( args ...); } void ptt () { cout << endl ; } template < class T , class ... Ts > void ptt ( const T & arg , const Ts & ... args ) { cout << ' ' << arg ; ptt ( args ...); } template < class T , class ... Ts > void pt ( const T & arg , const Ts & ... args ) { cout << arg ; ptt ( args ...); } void pt () {} template < template < typename ... > class T , typename t , typename ... A > void pt ( const T < t > & arg , const A & ... args ) { for ( int i = 0 , sze = arg . size (); i < sze ; ++ i ) cout << arg [ i ] << \" \\n \" [ i == sze - 1 ]; pt ( args ...); } inline ll qpow ( ll base , ll n ) { assert ( n >= 0 ); ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } // head unsigned long long k1 , k2 ; int n , m , q , _u [ 100001 ], _v [ 100001 ]; unsigned long long xorShift128Plus () { unsigned long long k3 = k1 , k4 = k2 ; k1 = k4 ; k3 ^= k3 << 23 ; k2 = k3 ^ k4 ^ ( k3 >> 17 ) ^ ( k4 >> 26 ); return k2 + k4 ; } int wnext ( int l , int r , int t ) { int res = xorShift128Plus () % ( r - l + 1 ) + l ; for ( int i = 1 ; i < t ; ++ i ) { res = max ( res , int ( xorShift128Plus () % ( r - l + 1 ) + l )); } return res ; } void gen () { int S = min ( 1000 , n ); for ( int i = 1 ; i <= m ; ++ i ) { _u [ i ] = wnext ( 1 , min ( n , (( i % S ) + 1 ) * S ), 50 ); _v [ i ] = wnext ( 1 , min ( n , (( i % S ) + 1 ) * S ), 50 ); // dbg(_u[i], _v[i]); } } const int N = 1e5 + 10 ; pII pid [ N ]; struct UFS { int fa [ N ], sze [ N ]; void init ( int n ) { for ( int i = 1 ; i <= n ; ++ i ) { fa [ i ] = 0 ; sze [ i ] = 1 ; } } int find ( int x ) { return fa [ x ] == 0 ? x : fa [ x ] = find ( fa [ x ]); } bool merge ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( fx != fy ) { if ( sze [ fx ] > sze [ fy ]) swap ( fx , fy ); fa [ fx ] = fy ; sze [ fy ] += sze [ fx ]; return true ; } return false ; } } ufs ; struct Bitset { using ull = unsigned long long ; static constexpr int W = 64 ; int n ; vector < ull > bits ; void init ( int _n ) { n = _n + 1 ; bits = vector < ull > ( n / W + 10 , 0 ); } void Or ( const Bitset & t ) { for ( int i = 0 ; i <= n / W ; ++ i ) bits [ i ] |= t . bits [ i ]; } void set ( int x ) { bits [ x / W ] |= 1l lu << ( x % W ); } int ask ( int x ) { return ( bits [ x / W ] >> ( x % W )) & 1 ; } }; struct Sol { vector < vector < int >> G ; vector < Bitset > b ; int n ; vector < int > Low , DFN , sta , Belong ; int cntSCC , cntSta , cntLow ; vector < bool > Insta ; Sol ( int _n ) { n = _n ; G . clear (); G . resize ( n + 5 ); Low = vector < int > ( n + 5 , 0 ); DFN = vector < int > ( n + 5 , 0 ); sta = vector < int > ( n + 5 , 0 ); Belong = vector < int > ( n + 5 , 0 ); Insta = vector < bool > ( n + 5 , false ); cntSCC = cntSta = cntLow = 0 ; } void dfs ( int u ) { Low [ u ] = DFN [ u ] = ++ cntLow ; sta [ ++ cntSta ] = u ; Insta [ u ] = 1 ; for ( auto & v : G [ u ]) { if ( ! DFN [ v ]) { dfs ( v ); Low [ u ] = min ( Low [ u ], Low [ v ]); } else if ( Insta [ v ]) Low [ u ] = min ( Low [ u ], DFN [ v ]); } if ( Low [ u ] == DFN [ u ]) { ++ cntSCC ; int v ; do { v = sta [ cntSta -- ]; Insta [ v ] = 0 ; Belong [ v ] = cntSCC ; } while ( v != u ); } } void gao () { for ( int i = 1 ; i <= n ; ++ i ) if ( ! DFN [ i ]) dfs ( i ); b . resize ( cntSCC + 5 ); for ( int i = 1 ; i <= cntSCC ; ++ i ) b [ i ]. init ( cntSCC + 5 ), b [ i ]. set ( i ); vector < vector < int >> T ; T . clear (); T . resize ( cntSCC + 5 ); for ( int u = 1 ; u <= n ; ++ u ) { for ( auto & v : G [ u ]) { if ( Belong [ u ] == Belong [ v ]) continue ; T [ Belong [ v ]]. push_back ( Belong [ u ]); } } for ( int u = 1 ; u <= cntSCC ; ++ u ) { for ( auto & v : T [ u ]) { b [ v ]. Or ( b [ u ]); } } } int query ( int u , int v ) { if ( Belong [ u ] == Belong [ v ]) return 1 ; // dbg(u, v); return b [ Belong [ u ]]. ask ( Belong [ v ]); } }; vector < Sol > sol ; void numerAS () { sol . clear (); vector < vector < int >> G , vec ; vec . clear (); G . clear (); vec . resize ( n + 1 ); G . resize ( n + 1 ); ufs . init ( n ); for ( int i = 1 ; i <= m ; ++ i ) { int u = _u [ i ], v = _v [ i ]; if ( u != v ) { G [ u ]. push_back ( v ); ufs . merge ( u , v ); // dbg(u, v); } } for ( int i = 1 ; i <= n ; ++ i ) if ( ! G [ i ]. empty ()) { sort ( all ( G [ i ])); G [ i ]. erase ( unique ( all ( G [ i ])), G [ i ]. end ()); } for ( int i = 1 ; i <= n ; ++ i ) { vec [ ufs . find ( i )]. push_back ( i ); } int _pid = -1 ; for ( auto & ve : vec ) if ( ! ve . empty ()) { sol . push_back ( Sol ( SZ ( ve ))); ++ _pid ; int nid = 0 ; for ( auto & it : ve ) { ++ nid ; pid [ it ] = pII ( _pid , nid ); } for ( auto & it : ve ) { for ( auto & v : G [ it ]) { v = pid [ v ]. se ; } sol . back (). G [ pid [ it ]. se ] = G [ it ]; } } } void run () { rd ( n , m , q , k1 , k2 ); gen (); numerAS (); for ( auto & it : sol ) { it . gao (); } for ( int i = 1 , u , v ; i <= q ; ++ i ) { rd ( u , v ); // dbg(pid[u].fi, pid[u].se, pid[v].se); int res = 0 ; if ( pid [ u ]. fi == pid [ v ]. fi ) { res = sol [ pid [ u ]. fi ]. query ( pid [ u ]. se , pid [ v ]. se ); } pt ( res ? \"Yes\" : \"No\" ); cout . flush (); } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); cout << fixed << setprecision ( 20 ); int _T = 1 ; while ( _T -- ) run (); // for (int kase = 1; kase <= _T; ++kase) { // cout << \"Case #\" << kase << \": \"; // run(); // } // while (cin >> n) run(); // run(); return 0 ; }","title":"\u601d\u8def"},{"location":"trainings/2018-Multi-University-Trainings/Contest-1/","text":"2018 Multi-University Training Contest 1 Contents A. Maximum Multiple B. Balanced Sequence C. Triangle Partition D. Distinct Values E. Maximum Weighted Matching F. Period Sequence G. Chiaki Sequence Revisited H. RMQ Similar Sequence I. Lyndon Substring J. Turn Off The Light K. Time Zone A. Maximum Multiple \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a n \u627e x, y, z \u4f7f\u5f97 n = x + y +z n = x + y +z \u5e76\u4e14 n \\equiv 0 \\pmod x, n \\equiv 0 \\pmod y, n \\equiv 0 \\pmod z n \\equiv 0 \\pmod x, n \\equiv 0 \\pmod y, n \\equiv 0 \\pmod z \u5e76\u4e14\u4f7f\u5f97 x \\cdot y \\cdot z x \\cdot y \\cdot z \u6700\u5927\u3002 \u601d\u8def\uff1a \u8bbe a = \\frac{n}{x}, b = \\frac{n}{y}, c = \\frac{n}{z} a = \\frac{n}{x}, b = \\frac{n}{y}, c = \\frac{n}{z} \u90a3\u4e48 \\frac{1}{a} + \\frac{1}{b} + \\frac{1}{c} = 1 \\frac{1}{a} + \\frac{1}{b} + \\frac{1}{c} = 1 \u90a3\u4e48\u6211\u4eec\u8003\u8651\u53bb\u51d1 a, b, c\u3002 \u4e24\u79cd\u65b9\u6848 {3, 3, 3} {3, 3, 3} \u6216\u8005 {2, 4, 4} {2, 4, 4} \u53d6 max\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%lld\" , & n ); if ( n % 3 == 0 ) { ll ans = n / 3 ; ans *= n / 3 ; ans *= n / 3 ; printf ( \"%lld \\n \" , ans ); } else if ( n % 4 == 0 ) { ll ans = n / 2 ; ans *= n / 4 ; ans *= n / 4 ; printf ( \"%lld \\n \" , ans ); } else { puts ( \"-1\" ); } } return 0 ; } B. Balanced Sequence \u9898\u610f\uff1a \u6c42\u5982\u4f55\u62fc\u63a5\uff0c\u4f7f\u5f97 balanced Sequence \u6700\u957f\u3002 \u601d\u8def\uff1a \u9996\u5148\u9884\u5904\u7406\uff0c\u4f7f\u5f97\u5269\u4e0b\u7684\u4e32\u90fd\u662f ((( \u6216\u8005 ))) \u6216\u8005 )))((( \u3002 ((( \u8fd9\u79cd\u90fd\u653e\u5de6\u8fb9 ))) \u90fd\u653e\u53f3\u8fb9\u3002 \u76ee\u524d\u7684\u95ee\u9898\u5c31\u662f )))((( \u8fd9\u79cd\u5728\u4e2d\u95f4\u6309\u4ec0\u4e48\u987a\u5e8f\u653e\u4f7f\u5f97\u7b54\u6848\u6700\u5927\u3002 \u6211\u4eec\u5b9a\u4e49 L_1, R_1 L_1, R_1 L_2, R_2 L_2, R_2 \u5206\u522b\u4e3a\u4e24\u4e2a\u4e32\u7684\u5de6\u62ec\u53f7\u6570\u91cf\u548c\u53f3\u62ec\u53f7\u6570\u91cf\uff1a \u5047\u5982 1 1 \u653e\u5728 2 2 \u524d\u9762 \u90a3\u4e48\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u662f min(R_1, L_2) min(R_1, L_2) \u3002 \u5047\u5982 1 1 \u653e\u5728 2 2 \u540e\u9762 \u90a3\u4e48\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u662f min(R_2, L_1) min(R_2, L_1) \u3002 \u6bd4\u8f83\u5bf9\u7b54\u6848\u7684\u8d21\u732e\uff0c\u54ea\u4e2a\u7b54\u6848\u8d21\u732e\u5927\uff0c\u9009\u54ea\u79cd\u653e\u7f6e\u65b9\u5f0f\u3002 \u5982\u679c\u8bfb\u7b54\u6848\u7684\u8d21\u732e\u4e00\u6837\u5927\uff0c\u90a3\u4e48\u6211\u4eec\u8ba9\u5de6\u62ec\u53f7\u591a\u7684\u653e\u524d\u9762\uff0c\u56e0\u4e3a\u8fd9\u6837\u5bf9\u540e\u9762\u7684\u7b54\u6848\u8d21\u732e\u5927\u3002 Dup4's Code #include <bits/stdc++.h> using namespace std ; #define N 100010 struct node { int l , r ; inline node () {} inline node ( int l , int r ) : l ( l ), r ( r ) {} inline bool operator < ( const node & b ) const { int t1 = min ( l , b . r ), t2 = min ( r , b . l ); return t1 > t2 || ( t1 == t2 && ( l > b . l )); } } arr [ N ]; int t , n ; char s [ N ]; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { int L = 0 , R = 0 , ans = 0 , cnt = 0 ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%s\" , s ); int LL = 0 , RR = 0 ; for ( int j = 0 , len = strlen ( s ); j < len ; ++ j ) { if ( s [ j ] == '(' ) ++ LL ; else { if ( LL ) { -- LL ; ans += 2 ; } else ++ RR ; } } if ( LL && RR ) arr [ ++ cnt ] = node ( LL , RR ); else if ( LL ) L += LL ; else R += RR ; } sort ( arr + 1 , arr + 1 + cnt ); for ( int i = 1 ; i <= cnt ; ++ i ) { int LL = arr [ i ]. l , RR = arr [ i ]. r ; ans += min ( L , RR ) * 2 ; L -= min ( L , RR ); L += LL ; } ans += min ( L , R ) * 2 ; printf ( \"%d \\n \" , ans ); } return 0 ; } Hsueh-'s Code #include <bits/stdc++.h> using namespace std ; #define N 100010 struct node { int l , r ; inline node () {} inline node ( int l , int r ) : l ( l ), r ( r ) {} inline bool operator < ( const node & b ) const { if ( l >= r && b . l < b . r ) return true ; if ( l < r && b . l >= b . r ) return false ; if ( l >= r && b . l >= b . r ) return r < b . r ; if ( l < r && b . l < b . r ) return l > b . l ; } } arr [ N ]; int t , n ; char s [ N ]; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { int ans = 0 ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%s\" , s ); int LL = 0 , RR = 0 ; for ( int j = 0 , len = strlen ( s ); j < len ; ++ j ) { if ( s [ j ] == '(' ) ++ LL ; else { if ( LL ) { -- LL ; ans += 2 ; } else ++ RR ; } } arr [ i ] = node ( LL , RR ); } sort ( arr + 1 , arr + 1 + n ); int L = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { int LL = arr [ i ]. l , RR = arr [ i ]. r ; ans += min ( L , RR ) * 2 ; L -= min ( L , RR ); L += LL ; } printf ( \"%d \\n \" , ans ); } return 0 ; } C. Triangle Partition \u6c34\u3002\uff08\u6392\u5e8f\uff09 Code #include <bits/stdc++.h> using namespace std ; const int maxn = 1e3 + 10 ; struct node { int x , y , id ; inline node () {} inline node ( int x , int y , int id ) : x ( x ), y ( y ), id ( id ) {} inline bool operator < ( const node & b ) const { return x == b . x ? y < b . y : x < b . x ; } } P [ maxn << 2 ]; int n ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= 3 * n ; ++ i ) { scanf ( \"%d %d\" , & P [ i ]. x , & P [ i ]. y ); P [ i ]. id = i ; } sort ( P + 1 , P + 1 + 3 * n ); for ( int i = 1 ; i <= 3 * n ; i += 3 ) { printf ( \"%d %d %d \\n \" , P [ i ]. id , P [ i + 1 ]. id , P [ i + 2 ]. id ); } } return 0 ; } D. Distinct Values \u6309\u9898\u610f\u6a21\u62df\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 struct node { int l , r ; inline void scan () { scanf ( \"%d%d\" , & l , & r ); } inline bool operator < ( const node & r ) const { return l < r . l || ( l == r . l && this -> r > r . r ); } } Data [ N ]; int t , n , m ; int ans [ N ]; bool vis [ N ]; int R ; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { memset ( ans , 0 , sizeof ans ); R = 0 ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; ++ i ) Data [ i ]. scan (); sort ( Data + 1 , Data + 1 + m ); for ( int i = 1 ; i <= m ; ++ i ) { int l = Data [ i ]. l , r = Data [ i ]. r ; if ( R >= r ) continue ; if ( R + 1 < l ) for ( int j = R + 1 ; j < l ; ++ j ) ans [ j ] = 1 ; memset ( vis , false , sizeof vis ); for ( int j = l ; j <= R ; ++ j ) vis [ ans [ j ]] = true ; int L = 1 ; for ( int j = max ( R + 1 , l ); j <= r ; ++ j ) { while ( vis [ L ]) ++ L ; ans [ j ] = L ; vis [ L ] = true ; } R = max ( R , r ); } while ( R < n ) { R ++ ; ans [ R ] = 1 ; } for ( int i = 1 ; i <= n ; ++ i ) printf ( \"%d%c\" , ans [ i ], \" \\n \" [ i == n ]); } return 0 ; } E. Maximum Weighted Matching \u7559\u5751\u3002 F. Period Sequence \u7559\u5751\u3002 G. Chiaki Sequence Revisited \u9898\u610f\uff1a \u5b9a\u4e49 a_n a_n \uff0c\u6c42 \\sum_{i = 1} ^ {i = n} a_i \\sum_{i = 1} ^ {i = n} a_i \u3002 \u601d\u8def\uff1a \u5148\u4e0d\u8003\u8651 a_1 a_1 \u3002 \u6211\u4eec\u5bf9\u6bcf\u4e2a\u6700\u540e\u4e00\u4e2a 2 2 \u7684\u5e42\u6b21\u6570\u5904\u7406\u51fa\u5b83\u524d\u9762\u6709\u591a\u5c11\u4e2a\u6570\uff0c\u4ee5\u53ca\u8fd9\u4e9b\u6570\u7684\u524d\u7f00\u548c\u662f\u591a\u5c11\u3002 \u6bd4\u5982\u8bf4\u5904\u7406\u51fa\uff1a 1 2 4 8 16 1 3 7 15 31 1 5 20 76 288 \u7136\u540e\u7ed9\u51fa n n \u8ba1\u7b97\u7684\u65f6\u5019 \u6309\u4e8c\u8fdb\u5236\u62c6\u5206 \u6bd4\u65b9\u8bf4\uff1a 27 = 15 + 7 + 3 + 3 27 = 15 + 7 + 3 + 3 \u5b9a\u4e49 F[i] F[i] \u4e3a \u524d\u9762 i i \u4e2a\u6570\u7684\u524d\u7f00\u548c\u3002 ans[27] = F[15] + F[7] + 7 * 8 + F[3] + 3 * (8 + 2) + F[3] + 3 * (8 + 2 + 2) ans[27] = F[15] + F[7] + 7 * 8 + F[3] + 3 * (8 + 2) + F[3] + 3 * (8 + 2 + 2) \u5bf9\u4e8e\u540e\u9762\uff0c\u76f8\u5f53\u4e8e\u6240\u6709\u6570\u5411\u53f3\u504f\u79fb\u3002 \u6ce8\u610f\u53d6\u6a21\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 64 #define ll long long const ll MOD = ( ll ) 1e9 + 7 ; int t ; ll n ; ll a [ N ], b [ N ], c [ N ]; inline void Init () { a [ 0 ] = 1 ; for ( int i = 1 ; i <= 59 ; ++ i ) a [ i ] = a [ i - 1 ] << 1 ; b [ 0 ] = 1 ; for ( int i = 1 ; i <= 59 ; ++ i ) b [ i ] = ( b [ i - 1 ] << 1 ) + 1 ; c [ 0 ] = 1 ; for ( int i = 1 ; i <= 59 ; ++ i ) c [ i ] = (( c [ i - 1 ] << 1 ) % MOD + ( a [ i - 1 ] % MOD ) * ( b [ i - 1 ] % MOD ) % MOD + a [ i ]) % MOD ; // for (int i = 0; i <= 59; ++i) printf(\"%lld %lld %lld\\n\", a[i], b[i], c[i]); } int main () { Init (); scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%lld\" , & n ); -- n ; ll ans = 1 , tmp = 0 ; for ( int i = 59 ; i >= 0 ; -- i ) { while ( n >= b [ i ]) { ans = ( ans + c [ i ]) % MOD ; ans = ( ans + ( b [ i ] % MOD * tmp ) % MOD ) % MOD ; tmp = ( tmp + a [ i ]) % MOD ; n -= b [ i ]; } } printf ( \"%lld \\n \" , ans ); } return 0 ; } H. RMQ Similar Sequence \u7559\u5751\u3002 I. Lyndon Substring \u7559\u5751\u3002 J. Turn Off The Light \u7559\u5751\u3002 K. Time Zone \u6309\u9898\u610f\u6a21\u62df\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; int t , a , b ; char s [ 10 ]; inline void work1 () { int ans = 0 ; int flag = 1 ; if ( s [ 0 ] == '-' ) flag = -1 ; int len = strlen ( s ); for ( int i = 1 ; i < len ; ++ i ) ans = ans * 10 + s [ i ] - '0' ; ans *= flag ; int gap = ans - 8 ; a = ( a + gap + 24 ) % 24 ; printf ( \"%02d:%02d \\n \" , a , b ); return ; } inline void work2 () { int A = 0 , B = 0 ; int flag = 1 ; if ( s [ 0 ] == '-' ) flag = -1 ; int len = strlen ( s ), i ; for ( i = 1 ; s [ i ] != '.' ; ++ i ) A = A * 10 + s [ i ] - '0' ; for ( ++ i ; i < len ; ++ i ) B = B * 10 + s [ i ] - '0' ; int tot = a * 60 + b ; A *= flag , B = B * 6 * flag ; int tmptot = A * 60 + B - 480 ; tot = ( tot + tmptot + 24 * 60 ) % ( 24 * 60 ); printf ( \"%02d:%02d \\n \" , tot / 60 , tot % 60 ); return ; } int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d UTC%s\" , & a , & b , s ); bool flag = true ; for ( int i = 0 , len = strlen ( s ); i < len ; ++ i ) if ( s [ i ] == '.' ) { flag = false ; break ; } if ( flag ) work1 (); else work2 (); } return 0 ; }","title":"2018 Multi-University Training Contest 1"},{"location":"trainings/2018-Multi-University-Trainings/Contest-1/#a-maximum-multiple","text":"\u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a n \u627e x, y, z \u4f7f\u5f97 n = x + y +z n = x + y +z \u5e76\u4e14 n \\equiv 0 \\pmod x, n \\equiv 0 \\pmod y, n \\equiv 0 \\pmod z n \\equiv 0 \\pmod x, n \\equiv 0 \\pmod y, n \\equiv 0 \\pmod z \u5e76\u4e14\u4f7f\u5f97 x \\cdot y \\cdot z x \\cdot y \\cdot z \u6700\u5927\u3002 \u601d\u8def\uff1a \u8bbe a = \\frac{n}{x}, b = \\frac{n}{y}, c = \\frac{n}{z} a = \\frac{n}{x}, b = \\frac{n}{y}, c = \\frac{n}{z} \u90a3\u4e48 \\frac{1}{a} + \\frac{1}{b} + \\frac{1}{c} = 1 \\frac{1}{a} + \\frac{1}{b} + \\frac{1}{c} = 1 \u90a3\u4e48\u6211\u4eec\u8003\u8651\u53bb\u51d1 a, b, c\u3002 \u4e24\u79cd\u65b9\u6848 {3, 3, 3} {3, 3, 3} \u6216\u8005 {2, 4, 4} {2, 4, 4} \u53d6 max\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll n ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%lld\" , & n ); if ( n % 3 == 0 ) { ll ans = n / 3 ; ans *= n / 3 ; ans *= n / 3 ; printf ( \"%lld \\n \" , ans ); } else if ( n % 4 == 0 ) { ll ans = n / 2 ; ans *= n / 4 ; ans *= n / 4 ; printf ( \"%lld \\n \" , ans ); } else { puts ( \"-1\" ); } } return 0 ; }","title":"A. Maximum Multiple"},{"location":"trainings/2018-Multi-University-Trainings/Contest-1/#b-balanced-sequence","text":"\u9898\u610f\uff1a \u6c42\u5982\u4f55\u62fc\u63a5\uff0c\u4f7f\u5f97 balanced Sequence \u6700\u957f\u3002 \u601d\u8def\uff1a \u9996\u5148\u9884\u5904\u7406\uff0c\u4f7f\u5f97\u5269\u4e0b\u7684\u4e32\u90fd\u662f ((( \u6216\u8005 ))) \u6216\u8005 )))((( \u3002 ((( \u8fd9\u79cd\u90fd\u653e\u5de6\u8fb9 ))) \u90fd\u653e\u53f3\u8fb9\u3002 \u76ee\u524d\u7684\u95ee\u9898\u5c31\u662f )))((( \u8fd9\u79cd\u5728\u4e2d\u95f4\u6309\u4ec0\u4e48\u987a\u5e8f\u653e\u4f7f\u5f97\u7b54\u6848\u6700\u5927\u3002 \u6211\u4eec\u5b9a\u4e49 L_1, R_1 L_1, R_1 L_2, R_2 L_2, R_2 \u5206\u522b\u4e3a\u4e24\u4e2a\u4e32\u7684\u5de6\u62ec\u53f7\u6570\u91cf\u548c\u53f3\u62ec\u53f7\u6570\u91cf\uff1a \u5047\u5982 1 1 \u653e\u5728 2 2 \u524d\u9762 \u90a3\u4e48\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u662f min(R_1, L_2) min(R_1, L_2) \u3002 \u5047\u5982 1 1 \u653e\u5728 2 2 \u540e\u9762 \u90a3\u4e48\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u662f min(R_2, L_1) min(R_2, L_1) \u3002 \u6bd4\u8f83\u5bf9\u7b54\u6848\u7684\u8d21\u732e\uff0c\u54ea\u4e2a\u7b54\u6848\u8d21\u732e\u5927\uff0c\u9009\u54ea\u79cd\u653e\u7f6e\u65b9\u5f0f\u3002 \u5982\u679c\u8bfb\u7b54\u6848\u7684\u8d21\u732e\u4e00\u6837\u5927\uff0c\u90a3\u4e48\u6211\u4eec\u8ba9\u5de6\u62ec\u53f7\u591a\u7684\u653e\u524d\u9762\uff0c\u56e0\u4e3a\u8fd9\u6837\u5bf9\u540e\u9762\u7684\u7b54\u6848\u8d21\u732e\u5927\u3002 Dup4's Code #include <bits/stdc++.h> using namespace std ; #define N 100010 struct node { int l , r ; inline node () {} inline node ( int l , int r ) : l ( l ), r ( r ) {} inline bool operator < ( const node & b ) const { int t1 = min ( l , b . r ), t2 = min ( r , b . l ); return t1 > t2 || ( t1 == t2 && ( l > b . l )); } } arr [ N ]; int t , n ; char s [ N ]; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { int L = 0 , R = 0 , ans = 0 , cnt = 0 ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%s\" , s ); int LL = 0 , RR = 0 ; for ( int j = 0 , len = strlen ( s ); j < len ; ++ j ) { if ( s [ j ] == '(' ) ++ LL ; else { if ( LL ) { -- LL ; ans += 2 ; } else ++ RR ; } } if ( LL && RR ) arr [ ++ cnt ] = node ( LL , RR ); else if ( LL ) L += LL ; else R += RR ; } sort ( arr + 1 , arr + 1 + cnt ); for ( int i = 1 ; i <= cnt ; ++ i ) { int LL = arr [ i ]. l , RR = arr [ i ]. r ; ans += min ( L , RR ) * 2 ; L -= min ( L , RR ); L += LL ; } ans += min ( L , R ) * 2 ; printf ( \"%d \\n \" , ans ); } return 0 ; } Hsueh-'s Code #include <bits/stdc++.h> using namespace std ; #define N 100010 struct node { int l , r ; inline node () {} inline node ( int l , int r ) : l ( l ), r ( r ) {} inline bool operator < ( const node & b ) const { if ( l >= r && b . l < b . r ) return true ; if ( l < r && b . l >= b . r ) return false ; if ( l >= r && b . l >= b . r ) return r < b . r ; if ( l < r && b . l < b . r ) return l > b . l ; } } arr [ N ]; int t , n ; char s [ N ]; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { int ans = 0 ; scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%s\" , s ); int LL = 0 , RR = 0 ; for ( int j = 0 , len = strlen ( s ); j < len ; ++ j ) { if ( s [ j ] == '(' ) ++ LL ; else { if ( LL ) { -- LL ; ans += 2 ; } else ++ RR ; } } arr [ i ] = node ( LL , RR ); } sort ( arr + 1 , arr + 1 + n ); int L = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { int LL = arr [ i ]. l , RR = arr [ i ]. r ; ans += min ( L , RR ) * 2 ; L -= min ( L , RR ); L += LL ; } printf ( \"%d \\n \" , ans ); } return 0 ; }","title":"B. Balanced Sequence"},{"location":"trainings/2018-Multi-University-Trainings/Contest-1/#c-triangle-partition","text":"\u6c34\u3002\uff08\u6392\u5e8f\uff09 Code #include <bits/stdc++.h> using namespace std ; const int maxn = 1e3 + 10 ; struct node { int x , y , id ; inline node () {} inline node ( int x , int y , int id ) : x ( x ), y ( y ), id ( id ) {} inline bool operator < ( const node & b ) const { return x == b . x ? y < b . y : x < b . x ; } } P [ maxn << 2 ]; int n ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= 3 * n ; ++ i ) { scanf ( \"%d %d\" , & P [ i ]. x , & P [ i ]. y ); P [ i ]. id = i ; } sort ( P + 1 , P + 1 + 3 * n ); for ( int i = 1 ; i <= 3 * n ; i += 3 ) { printf ( \"%d %d %d \\n \" , P [ i ]. id , P [ i + 1 ]. id , P [ i + 2 ]. id ); } } return 0 ; }","title":"C. Triangle Partition"},{"location":"trainings/2018-Multi-University-Trainings/Contest-1/#d-distinct-values","text":"\u6309\u9898\u610f\u6a21\u62df\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 struct node { int l , r ; inline void scan () { scanf ( \"%d%d\" , & l , & r ); } inline bool operator < ( const node & r ) const { return l < r . l || ( l == r . l && this -> r > r . r ); } } Data [ N ]; int t , n , m ; int ans [ N ]; bool vis [ N ]; int R ; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { memset ( ans , 0 , sizeof ans ); R = 0 ; scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; ++ i ) Data [ i ]. scan (); sort ( Data + 1 , Data + 1 + m ); for ( int i = 1 ; i <= m ; ++ i ) { int l = Data [ i ]. l , r = Data [ i ]. r ; if ( R >= r ) continue ; if ( R + 1 < l ) for ( int j = R + 1 ; j < l ; ++ j ) ans [ j ] = 1 ; memset ( vis , false , sizeof vis ); for ( int j = l ; j <= R ; ++ j ) vis [ ans [ j ]] = true ; int L = 1 ; for ( int j = max ( R + 1 , l ); j <= r ; ++ j ) { while ( vis [ L ]) ++ L ; ans [ j ] = L ; vis [ L ] = true ; } R = max ( R , r ); } while ( R < n ) { R ++ ; ans [ R ] = 1 ; } for ( int i = 1 ; i <= n ; ++ i ) printf ( \"%d%c\" , ans [ i ], \" \\n \" [ i == n ]); } return 0 ; }","title":"D. Distinct Values"},{"location":"trainings/2018-Multi-University-Trainings/Contest-1/#e-maximum-weighted-matching","text":"\u7559\u5751\u3002","title":"E. Maximum Weighted Matching"},{"location":"trainings/2018-Multi-University-Trainings/Contest-1/#f-period-sequence","text":"\u7559\u5751\u3002","title":"F. Period Sequence"},{"location":"trainings/2018-Multi-University-Trainings/Contest-1/#g-chiaki-sequence-revisited","text":"\u9898\u610f\uff1a \u5b9a\u4e49 a_n a_n \uff0c\u6c42 \\sum_{i = 1} ^ {i = n} a_i \\sum_{i = 1} ^ {i = n} a_i \u3002 \u601d\u8def\uff1a \u5148\u4e0d\u8003\u8651 a_1 a_1 \u3002 \u6211\u4eec\u5bf9\u6bcf\u4e2a\u6700\u540e\u4e00\u4e2a 2 2 \u7684\u5e42\u6b21\u6570\u5904\u7406\u51fa\u5b83\u524d\u9762\u6709\u591a\u5c11\u4e2a\u6570\uff0c\u4ee5\u53ca\u8fd9\u4e9b\u6570\u7684\u524d\u7f00\u548c\u662f\u591a\u5c11\u3002 \u6bd4\u5982\u8bf4\u5904\u7406\u51fa\uff1a 1 2 4 8 16 1 3 7 15 31 1 5 20 76 288 \u7136\u540e\u7ed9\u51fa n n \u8ba1\u7b97\u7684\u65f6\u5019 \u6309\u4e8c\u8fdb\u5236\u62c6\u5206 \u6bd4\u65b9\u8bf4\uff1a 27 = 15 + 7 + 3 + 3 27 = 15 + 7 + 3 + 3 \u5b9a\u4e49 F[i] F[i] \u4e3a \u524d\u9762 i i \u4e2a\u6570\u7684\u524d\u7f00\u548c\u3002 ans[27] = F[15] + F[7] + 7 * 8 + F[3] + 3 * (8 + 2) + F[3] + 3 * (8 + 2 + 2) ans[27] = F[15] + F[7] + 7 * 8 + F[3] + 3 * (8 + 2) + F[3] + 3 * (8 + 2 + 2) \u5bf9\u4e8e\u540e\u9762\uff0c\u76f8\u5f53\u4e8e\u6240\u6709\u6570\u5411\u53f3\u504f\u79fb\u3002 \u6ce8\u610f\u53d6\u6a21\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 64 #define ll long long const ll MOD = ( ll ) 1e9 + 7 ; int t ; ll n ; ll a [ N ], b [ N ], c [ N ]; inline void Init () { a [ 0 ] = 1 ; for ( int i = 1 ; i <= 59 ; ++ i ) a [ i ] = a [ i - 1 ] << 1 ; b [ 0 ] = 1 ; for ( int i = 1 ; i <= 59 ; ++ i ) b [ i ] = ( b [ i - 1 ] << 1 ) + 1 ; c [ 0 ] = 1 ; for ( int i = 1 ; i <= 59 ; ++ i ) c [ i ] = (( c [ i - 1 ] << 1 ) % MOD + ( a [ i - 1 ] % MOD ) * ( b [ i - 1 ] % MOD ) % MOD + a [ i ]) % MOD ; // for (int i = 0; i <= 59; ++i) printf(\"%lld %lld %lld\\n\", a[i], b[i], c[i]); } int main () { Init (); scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%lld\" , & n ); -- n ; ll ans = 1 , tmp = 0 ; for ( int i = 59 ; i >= 0 ; -- i ) { while ( n >= b [ i ]) { ans = ( ans + c [ i ]) % MOD ; ans = ( ans + ( b [ i ] % MOD * tmp ) % MOD ) % MOD ; tmp = ( tmp + a [ i ]) % MOD ; n -= b [ i ]; } } printf ( \"%lld \\n \" , ans ); } return 0 ; }","title":"G. Chiaki Sequence Revisited"},{"location":"trainings/2018-Multi-University-Trainings/Contest-1/#h-rmq-similar-sequence","text":"\u7559\u5751\u3002","title":"H. RMQ Similar Sequence"},{"location":"trainings/2018-Multi-University-Trainings/Contest-1/#i-lyndon-substring","text":"\u7559\u5751\u3002","title":"I. Lyndon Substring"},{"location":"trainings/2018-Multi-University-Trainings/Contest-1/#j-turn-off-the-light","text":"\u7559\u5751\u3002","title":"J. Turn Off The Light"},{"location":"trainings/2018-Multi-University-Trainings/Contest-1/#k-time-zone","text":"\u6309\u9898\u610f\u6a21\u62df\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; int t , a , b ; char s [ 10 ]; inline void work1 () { int ans = 0 ; int flag = 1 ; if ( s [ 0 ] == '-' ) flag = -1 ; int len = strlen ( s ); for ( int i = 1 ; i < len ; ++ i ) ans = ans * 10 + s [ i ] - '0' ; ans *= flag ; int gap = ans - 8 ; a = ( a + gap + 24 ) % 24 ; printf ( \"%02d:%02d \\n \" , a , b ); return ; } inline void work2 () { int A = 0 , B = 0 ; int flag = 1 ; if ( s [ 0 ] == '-' ) flag = -1 ; int len = strlen ( s ), i ; for ( i = 1 ; s [ i ] != '.' ; ++ i ) A = A * 10 + s [ i ] - '0' ; for ( ++ i ; i < len ; ++ i ) B = B * 10 + s [ i ] - '0' ; int tot = a * 60 + b ; A *= flag , B = B * 6 * flag ; int tmptot = A * 60 + B - 480 ; tot = ( tot + tmptot + 24 * 60 ) % ( 24 * 60 ); printf ( \"%02d:%02d \\n \" , tot / 60 , tot % 60 ); return ; } int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d UTC%s\" , & a , & b , s ); bool flag = true ; for ( int i = 0 , len = strlen ( s ); i < len ; ++ i ) if ( s [ i ] == '.' ) { flag = false ; break ; } if ( flag ) work1 (); else work2 (); } return 0 ; }","title":"K. Time Zone"},{"location":"trainings/2018-Multi-University-Trainings/Contest-10/","text":"2018 Multi-University Training Contest 10 Contents Problem A.Alkane Problem B. Beads Problem C. Calculate Problem D. Permutation Problem E. TeaTree Problem F. NewNippori Problem G. Cyclic Problem H. Pow Problem I. Count Problem J. CSGO Problem K. Pow2 Problem L.Videos Problem A.Alkane \u7559\u5751\u3002 Problem B. Beads \u7559\u5751\u3002 Problem C. Calculate \u7559\u5751\u3002 Problem D. Permutation \u7559\u5751\u3002 Problem E. TeaTree \u9898\u610f\uff1a \u6bcf\u4e2a\u70b9\u4f1a\u5b58\u4e0b\u4efb\u610f\u4e24\u4e2a\u4ee5\u4ed6\u4e3a LCA \u7684\u70b9\u5bf9\u7684 GCD\uff0c\u6c42\u6bcf\u4e2a\u70b9\u5b58\u7684 GCD \u7684\u6700\u5927\u503c\u3002 \u601d\u8def\uff1a DSU on tree\u3002 \u7528 set \u7ef4\u62a4\u5b50\u6811\u4e2d\u7684\u56e0\u5b50\uff0c\u5bf9\u4e8e\u91cd\u513f\u5b50\u4e0d\u8981\u5904\u7406\u591a\u6b21\u3002 \u6bcf\u6b21\u67e5\u627e\u7684\u65f6\u5019\uff0c\u679a\u4e3e\u8f7b\u513f\u5b50\u4e2d\u7684\u56e0\u5b50\u3002 \u8fd8\u6709\u4e00\u79cd\u7ebf\u6bb5\u6811\u5408\u5e76\u7684\u5199\u6cd5\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 int n ; vector < int > G [ N ], num [ N ]; set < int > s ; int sz [ N ], son [ N ], cnt [ N ], cnt2 [ N ], arr [ N ], ans [ N ], Max ; bool isbig [ N ]; void Init () { for ( int i = 1 ; i <= 100000 ; ++ i ) { int limit = sqrt ( i ); for ( int j = 1 ; j < limit ; ++ j ) if ( i % j == 0 ) { num [ i ]. push_back ( j ); num [ i ]. push_back ( i / j ); } if ( i % limit == 0 ) { num [ i ]. push_back ( limit ); if ( limit * limit != i ) num [ i ]. push_back ( i / limit ); } } } void DFS ( int u ) { sz [ u ] = 1 ; for ( auto v : G [ u ]) { DFS ( v ); sz [ u ] += sz [ v ]; if ( son [ u ] == -1 || sz [ v ] > sz [ son [ u ]]) son [ u ] = v ; } } void update ( int u ) { for ( auto it : num [ arr [ u ]]) ++ cnt [ it ]; for ( auto v : G [ u ]) if ( ! isbig [ v ]) update ( v ); } void work ( int u , int fa ) { for ( auto it : num [ arr [ u ]]) s . insert ( it ); for ( auto v : G [ u ]) if ( ! isbig [ v ]) work ( v , fa ); } void query ( int u ) { for ( auto v : G [ u ]) if ( ! isbig [ v ]) { s . clear (); work ( v , u ); for ( auto it : s ) if ( cnt [ it ] >= 1 || cnt2 [ it ] >= 1 ) Max = max ( Max , it ); for ( auto it : s ) ++ cnt2 [ it ]; } for ( auto it : num [ arr [ u ]]) if ( cnt [ it ] >= 1 || cnt2 [ it ] >= 1 ) Max = max ( Max , it ); } void clear ( int u ) { for ( auto it : num [ arr [ u ]]) cnt [ it ] = cnt2 [ it ] = 0 ; for ( auto v : G [ u ]) clear ( v ); } void DSU ( int u ) { for ( auto v : G [ u ]) if ( v != son [ u ]) DSU ( v ); if ( son [ u ] != -1 ) { isbig [ son [ u ]] = 1 ; DSU ( son [ u ]); } Max = -1 ; query ( u ); ans [ u ] = Max ; if ( isbig [ u ]) update ( u ); if ( son [ u ] != -1 ) isbig [ son [ u ]] = 0 ; if ( ! isbig [ u ]) clear ( u ); } int main () { Init (); while ( scanf ( \"%d\" , & n ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) G [ i ]. clear (); memset ( son , -1 , sizeof son ); memset ( cnt , 0 , sizeof cnt ); memset ( cnt2 , 0 , sizeof cnt2 ); Max = -1 ; s . clear (); for ( int i = 2 , u ; i <= n ; ++ i ) { scanf ( \"%d\" , & u ); G [ u ]. push_back ( i ); } for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , arr + i ); DFS ( 1 ); DSU ( 1 ); for ( int i = 1 ; i <= n ; ++ i ) printf ( \"%d \\n \" , ans [ i ]); } return 0 ; } Code #include <bits/stdc++.h> using namespace std ; #define N 100010 vector < int > num [ N ], G [ N ]; int n ; int arr [ N ], rt [ N ], ans [ N ]; void Init () { for ( int i = 1 ; i <= 100000 ; ++ i ) for ( int j = i ; j <= 100000 ; j += i ) num [ j ]. push_back ( i ); } struct SEG { #define M N * 400 int lson [ M ], rson [ M ], c [ M ], cnt ; void init () { cnt = 0 ; } void pushup ( int id ) { c [ id ] = max ( c [ lson [ id ]], c [ rson [ id ]]); } void update ( int & x , int l , int r , int pos ) { if ( ! x ) x = ++ cnt ; if ( l == r ) { c [ x ] = pos ; return ; } int mid = ( l + r ) >> 1 ; pos <= mid ? update ( lson [ x ], l , mid , pos ) : update ( rson [ x ], mid + 1 , r , pos ); pushup ( x ); } int merge ( int u , int v , int & sum ) { if ( ! u || ! v ) return u | v ; if ( c [ u ] == c [ v ]) sum = max ( sum , c [ u ]); if ( lson [ u ] | lson [ v ]) lson [ u ] = merge ( lson [ u ], lson [ v ], sum ); if ( rson [ u ] | rson [ v ]) rson [ u ] = merge ( rson [ u ], rson [ v ], sum ); return u ; } } seg ; void DFS ( int u ) { ans [ u ] = -1 ; for ( auto v : G [ u ]) { DFS ( v ); seg . merge ( rt [ u ], rt [ v ], ans [ u ]); } } void Run () { Init (); while ( scanf ( \"%d\" , & n ) != EOF ) { seg . init (); for ( int i = 2 , u ; i <= n ; ++ i ) { scanf ( \"%d\" , & u ); G [ u ]. push_back ( i ); } for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , arr + i ); for ( int i = 1 ; i <= n ; ++ i ) for ( auto it : num [ arr [ i ]]) seg . update ( rt [ i ], 1 , 100000 , it ); DFS ( 1 ); for ( int i = 1 ; i <= n ; ++ i ) printf ( \"%d \\n \" , ans [ i ]); } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; } Problem F. NewNippori \u7559\u5751\u3002 Problem G. Cyclic \u6253\u8868\u627e\u89c4\u5f8b\u5373\u53ef\u3002 F[n] = (n - 2) * F[n - 1] + (n - 1) * F[n - 2] + (i \\& 1 ? 1 : -1) F[n] = (n - 2) * F[n - 1] + (n - 1) * F[n - 2] + (i \\& 1 ? 1 : -1) Code #include <bits/stdc++.h> using namespace std ; #define N 100010 #define ll long long const ll MOD = 998244353 ; ll arr [ N ]; int main () { arr [ 4 ] = 1 , arr [ 5 ] = 8 ; for ( int i = 6 ; i <= 100000 ; ++ i ) arr [ i ] = (( i - 2 ) * arr [ i - 1 ] % MOD + ( i - 1 ) * arr [ i - 2 ] % MOD + (( i & 1 ) ? 1 : -1 ) + MOD ) % MOD ; int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); printf ( \"%lld \\n \" , arr [ n ]); } } Problem H. Pow \u6c34\u3002 Code import java.util.Scanner ; import java.math.* ; public class Main { public static void main ( String [] args ) { Scanner in = new Scanner ( System . in ); int t = in . nextInt (); while ( t -- != 0 ) { int n = in . nextInt (); System . out . println ( BigInteger . valueOf ( 2 ). pow ( n )); } } } Problem I. Count \u9898\u610f\uff1a \u6c42\uff1a \\sum_{i = 1} ^ {i = n} \\sum_{j = 1} ^ {j = i - 1} [gcd(i + j, i - j) == 1] \\sum_{i = 1} ^ {i = n} \\sum_{j = 1} ^ {j = i - 1} [gcd(i + j, i - j) == 1] \u601d\u8def\uff1a \u627e\u89c4\u5f8b\u3002 \u5982\u679c\u662f\u5947\u6570\u5c31\u52a0\u4e0a \\frac {\\varphi(n)}{2} \\frac {\\varphi(n)}{2} \uff0c\u5426\u5219\u52a0\u4e0a \\varphi(n) \\varphi(n) \u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int MAXN = 20000000 ; bool check [ MAXN + 10 ]; ll ans [ MAXN + 10 ]; int phi [ MAXN + 10 ]; int prime [ MAXN + 10 ]; int tot ; void phi_ans_prime_table () { memset ( check , false , sizeof check ); phi [ 1 ] = 1 ; tot = 0 ; for ( int i = 2 ; i <= MAXN ; ++ i ) { if ( ! check [ i ]) { prime [ tot ++ ] = i ; phi [ i ] = i - 1 ; } for ( int j = 0 ; j < tot ; ++ j ) { if ( i * prime [ j ] > MAXN ) break ; check [ i * prime [ j ]] = true ; if ( i % prime [ j ] == 0 ) { phi [ i * prime [ j ]] = phi [ i ] * prime [ j ]; break ; } else { phi [ i * prime [ j ]] = phi [ i ] * ( prime [ j ] - 1 ); } } if ( i & 1 ) ans [ i ] = ans [ i - 1 ] + phi [ i ] / 2 ; else ans [ i ] = ans [ i - 1 ] + phi [ i ]; } } int main () { phi_ans_prime_table (); int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); printf ( \"%lld \\n \" , ans [ n ]); } return 0 ; } Problem J. CSGO \u9898\u610f\uff1a \u6709 n n \u628a\u4e3b\u6b66\u5668\u548c m m \u628a\u526f\u6b66\u5668\uff0c\u6bcf\u628a\u6b66\u5668\u6709 k k \u79cd\u5c5e\u6027\uff0c\u9009\u53d6\u4e00\u628a\u4e3b\u6b66\u5668\u548c\u526f\u6b66\u5668\uff0c\u6c42\u9898\u4e2d\u5f0f\u5b50\u6700\u5927\u503c\u3002 \u601d\u8def\uff1a \u5bf9\u4e8e\u6bcf\u79cd\u5c5e\u6027\u53c8\u6709\u52a0\u51cf\u4e24\u79cd\u72b6\u6001\uff0c\u679a\u4e3e\u6bcf\u628a\u6b66\u5668\u7684\u6bcf\u79cd\u5c5e\u6027\u7684\u52a0\u51cf\u72b6\u6001\uff0c\u6c42\u6700\u5927\u503c\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll INFLL = 0x3f3f3f3f3f3f3f3f ; const int maxn = 1e5 + 10 ; ll arr [ maxn ][ 10 ], brr [ maxn ][ 10 ]; ll crr [ maxn ]; int n , m , k ; void RUN () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d %d\" , & n , & m , & k ); for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 0 ; j <= k ; ++ j ) scanf ( \"%lld\" , & arr [ i ][ j ]); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 0 ; j <= k ; ++ j ) scanf ( \"%lld\" , & brr [ i ][ j ]); memset ( crr , 0 , sizeof crr ); ll ans = 0 ; int limit = ( 1 << k ); for ( int i = 1 ; i <= n ; ++ i ) { for ( int S = 0 ; S < limit ; ++ S ) { ll tmp = arr [ i ][ 0 ]; for ( int j = 0 ; j < k ; ++ j ) { if ( S & ( 1 << j )) { tmp += arr [ i ][ j + 1 ]; } else { tmp -= arr [ i ][ j + 1 ]; } } crr [ S ] = max ( crr [ S ], tmp ); } } for ( int i = 1 ; i <= m ; ++ i ) { for ( int S = 0 ; S < limit ; ++ S ) { ll tmp = brr [ i ][ 0 ]; for ( int j = 0 ; j < k ; ++ j ) { if ( S & ( 1 << j )) { tmp += brr [ i ][ j + 1 ]; } else { tmp -= brr [ i ][ j + 1 ]; } } ans = max ( ans , tmp + crr [ limit - 1 - S ]); } } printf ( \"%lld \\n \" , ans ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE return 0 ; } Code #include <bits/stdc++.h> using namespace std ; #define N 100010 #define ll long long #define INF 0x3f3f3f3f3f3f3f3f int t , n , m , K ; struct node { int x [ 10 ]; void scan ( int vis ) { scanf ( \"%d\" , x + vis ); for ( int i = 2 ; i <= K + 1 ; ++ i ) scanf ( \"%d\" , x + i ); } } a [ N ], b [ N ]; void Run () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d%d\" , & n , & m , & K ); for ( int i = 1 ; i <= n ; ++ i ) a [ i ]. scan ( 0 ); for ( int i = 1 ; i <= m ; ++ i ) b [ i ]. scan ( 1 ); ll res = 0 ; for ( int i = 0 ; i < ( 1 << ( K + 2 )); ++ i ) { bitset < 7 > bit ; bit = i ; ll Max [ 2 ] = { - INF , - INF }; ll Min [ 2 ] = { INF , INF }; for ( int j = 1 ; j <= n ; ++ j ) { ll tmp = 0 ; for ( int k = 0 ; k <= K + 1 ; ++ k ) tmp += a [ j ]. x [ k ] * ( bit [ k ] ? 1 : -1 ); Max [ 0 ] = max ( Max [ 0 ], tmp ); Min [ 0 ] = min ( Min [ 0 ], tmp ); } for ( int j = 1 ; j <= m ; ++ j ) { ll tmp = 0 ; for ( int k = 0 ; k <= K + 1 ; ++ k ) tmp += b [ j ]. x [ k ] * ( bit [ k ] ? 1 : -1 ); Max [ 1 ] = max ( Max [ 1 ], tmp ); Min [ 1 ] = min ( Min [ 1 ], tmp ); } res = max ( res , max ( Max [ 0 ] - Min [ 1 ], Max [ 1 ] - Min [ 0 ])); } printf ( \"%lld \\n \" , res ); } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; } Problem K. Pow2 \u7559\u5751\u3002 Problem L.Videos \u9898\u610f\uff1a \u6bcf\u5929\u6709 n n \u4e2a\u5c0f\u65f6\uff0c\u6709 m m \u90e8\u7535\u5f71\uff0c k k \u4e2a\u4eba\u3002 \u6bcf\u90e8\u7535\u5f71\u53ea\u80fd\u88ab\u4e00\u4e2a\u4eba\u770b\uff0c\u5f97\u5230 w w \u5feb\u4e50\u503c\u3002 \u7535\u5f71\u79cd\u7c7b\u6709 A,B A,B \u4e24\u79cd\uff0c\u540c\u4e00\u4eba\u8fde\u7740\u770b\u540c\u79cd\u7535\u5f71\u8981\u51cf\u53bb W W \u5feb\u4e50\u503c\uff0c\u5982\u4f55\u5b89\u6392\u4f7f\u5f97\u5feb\u4e50\u503c\u6700\u5927\u3002 \u601d\u8def\uff1a \u5c06\u4e00\u90e8\u7535\u5f71\u62c6\u6210\u4e24\u4e2a\u70b9 S S \u548c T T \u6d41\u4e3a 1 1 \uff0c\u8d39\u7528\u4e3a -w -w \u3002 \u7535\u5f71\u4e0e\u7535\u5f71\u4e4b\u95f4\u5982\u679c\u662f\u53ef\u4ee5\u8fde\u7740\u770b\u7684\uff0c\u5c31\u8fde\u8fb9\uff0c\u5982\u679c\u662f\u540c\u79cd\u7c7b\uff0c\u8d39\u7528\u5c31\u662f W W , \u5426\u5219\u5c31\u662f 0 0 \uff0c\u6d41\u4e3a 1 1 \u3002 \u6e90\u70b9\u8fde\u51fa\u6765\u52a0\u4e00\u4e2a\u70b9\uff0c\u6d41\u91cf\u4e3a k k \uff0c\u9650\u5236\u4e3a k k \u4e2a\u4eba\u3002 Code #include <bits/stdc++.h> using namespace std ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 10 ; const int maxm = 1e5 + 10 ; struct Edge { int to , nxt , cap , flow , cost ; } edge [ maxm ]; int head [ maxn ], tot ; int pre [ maxn ], dis [ maxn ]; bool vis [ maxn ]; int N ; void Init ( int n ) { N = n ; tot = 0 ; for ( int i = 0 ; i < n ; ++ i ) head [ i ] = -1 ; } void addedge ( int u , int v , int cap , int cost ) { edge [ tot ]. to = v ; edge [ tot ]. cap = cap ; edge [ tot ]. cost = cost ; edge [ tot ]. flow = 0 ; edge [ tot ]. nxt = head [ u ]; head [ u ] = tot ++ ; edge [ tot ]. to = u ; edge [ tot ]. cap = 0 ; edge [ tot ]. cost = - cost ; edge [ tot ]. flow = 0 ; edge [ tot ]. nxt = head [ v ]; head [ v ] = tot ++ ; } bool SPFA ( int s , int t ) { queue < int > q ; for ( int i = 0 ; i < N ; ++ i ) dis [ i ] = INF , pre [ i ] = -1 , vis [ i ] = false ; dis [ s ] = 0 ; vis [ s ] = true ; q . push ( s ); while ( ! q . empty ()) { int u = q . front (); q . pop (); vis [ u ] = false ; for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { int v = edge [ i ]. to ; if ( edge [ i ]. cap > edge [ i ]. flow && dis [ v ] > dis [ u ] + edge [ i ]. cost ) { dis [ v ] = dis [ u ] + edge [ i ]. cost ; pre [ v ] = i ; if ( ! vis [ v ]) { vis [ v ] = true ; q . push ( v ); } } } } if ( pre [ t ] == -1 ) return false ; else return true ; } int minCostMaxflow ( int s , int t , int & cost ) { int flow = 0 ; cost = 0 ; while ( SPFA ( s , t )) { int Min = INF ; for ( int i = pre [ t ]; ~ i ; i = pre [ edge [ i ^ 1 ]. to ]) { if ( Min > edge [ i ]. cap - edge [ i ]. flow ) { Min = edge [ i ]. cap - edge [ i ]. flow ; } } for ( int i = pre [ t ]; ~ i ; i = pre [ edge [ i ^ 1 ]. to ]) { edge [ i ]. flow += Min ; edge [ i ^ 1 ]. flow -= Min ; cost += edge [ i ]. cost * Min ; } flow += Min ; } return flow ; } struct node { int si , ti , wi , op ; } arr [ maxn ]; int n , m , K , W ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d %d %d\" , & n , & m , & K , & W ); for ( int i = 1 ; i <= m ; ++ i ) scanf ( \"%d %d %d %d\" , & arr [ i ]. si , & arr [ i ]. ti , & arr [ i ]. wi , & arr [ i ]. op ); Init ( 2 * m + 3 ); addedge ( 0 , 2 * m + 1 , K , 0 ); for ( int i = 1 ; i <= m ; ++ i ) addedge ( 2 * m + 1 , 2 * i - 1 , 1 , 0 ); for ( int i = 1 ; i <= m ; ++ i ) addedge ( 2 * i - 1 , 2 * i , 1 , - arr [ i ]. wi ); for ( int i = 1 ; i <= m ; ++ i ) addedge ( 2 * i , 2 * m + 2 , 1 , 0 ); for ( int i = 1 ; i <= m ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( i == j ) continue ; if ( arr [ i ]. ti <= arr [ j ]. si ) { if ( arr [ i ]. op == arr [ j ]. op ) { addedge ( 2 * i , 2 * j - 1 , 1 , W ); } else { addedge ( 2 * i , 2 * j - 1 , 1 , 0 ); } } } } int cost = 0 ; minCostMaxflow ( 0 , 2 * m + 2 , cost ); printf ( \"%d \\n \" , - cost ); } return 0 ; }","title":"2018 Multi-University Training Contest 10"},{"location":"trainings/2018-Multi-University-Trainings/Contest-10/#problem-aalkane","text":"\u7559\u5751\u3002","title":"Problem A.Alkane"},{"location":"trainings/2018-Multi-University-Trainings/Contest-10/#problem-b-beads","text":"\u7559\u5751\u3002","title":"Problem B. Beads"},{"location":"trainings/2018-Multi-University-Trainings/Contest-10/#problem-c-calculate","text":"\u7559\u5751\u3002","title":"Problem C. Calculate"},{"location":"trainings/2018-Multi-University-Trainings/Contest-10/#problem-d-permutation","text":"\u7559\u5751\u3002","title":"Problem D. Permutation"},{"location":"trainings/2018-Multi-University-Trainings/Contest-10/#problem-e-teatree","text":"\u9898\u610f\uff1a \u6bcf\u4e2a\u70b9\u4f1a\u5b58\u4e0b\u4efb\u610f\u4e24\u4e2a\u4ee5\u4ed6\u4e3a LCA \u7684\u70b9\u5bf9\u7684 GCD\uff0c\u6c42\u6bcf\u4e2a\u70b9\u5b58\u7684 GCD \u7684\u6700\u5927\u503c\u3002 \u601d\u8def\uff1a DSU on tree\u3002 \u7528 set \u7ef4\u62a4\u5b50\u6811\u4e2d\u7684\u56e0\u5b50\uff0c\u5bf9\u4e8e\u91cd\u513f\u5b50\u4e0d\u8981\u5904\u7406\u591a\u6b21\u3002 \u6bcf\u6b21\u67e5\u627e\u7684\u65f6\u5019\uff0c\u679a\u4e3e\u8f7b\u513f\u5b50\u4e2d\u7684\u56e0\u5b50\u3002 \u8fd8\u6709\u4e00\u79cd\u7ebf\u6bb5\u6811\u5408\u5e76\u7684\u5199\u6cd5\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 int n ; vector < int > G [ N ], num [ N ]; set < int > s ; int sz [ N ], son [ N ], cnt [ N ], cnt2 [ N ], arr [ N ], ans [ N ], Max ; bool isbig [ N ]; void Init () { for ( int i = 1 ; i <= 100000 ; ++ i ) { int limit = sqrt ( i ); for ( int j = 1 ; j < limit ; ++ j ) if ( i % j == 0 ) { num [ i ]. push_back ( j ); num [ i ]. push_back ( i / j ); } if ( i % limit == 0 ) { num [ i ]. push_back ( limit ); if ( limit * limit != i ) num [ i ]. push_back ( i / limit ); } } } void DFS ( int u ) { sz [ u ] = 1 ; for ( auto v : G [ u ]) { DFS ( v ); sz [ u ] += sz [ v ]; if ( son [ u ] == -1 || sz [ v ] > sz [ son [ u ]]) son [ u ] = v ; } } void update ( int u ) { for ( auto it : num [ arr [ u ]]) ++ cnt [ it ]; for ( auto v : G [ u ]) if ( ! isbig [ v ]) update ( v ); } void work ( int u , int fa ) { for ( auto it : num [ arr [ u ]]) s . insert ( it ); for ( auto v : G [ u ]) if ( ! isbig [ v ]) work ( v , fa ); } void query ( int u ) { for ( auto v : G [ u ]) if ( ! isbig [ v ]) { s . clear (); work ( v , u ); for ( auto it : s ) if ( cnt [ it ] >= 1 || cnt2 [ it ] >= 1 ) Max = max ( Max , it ); for ( auto it : s ) ++ cnt2 [ it ]; } for ( auto it : num [ arr [ u ]]) if ( cnt [ it ] >= 1 || cnt2 [ it ] >= 1 ) Max = max ( Max , it ); } void clear ( int u ) { for ( auto it : num [ arr [ u ]]) cnt [ it ] = cnt2 [ it ] = 0 ; for ( auto v : G [ u ]) clear ( v ); } void DSU ( int u ) { for ( auto v : G [ u ]) if ( v != son [ u ]) DSU ( v ); if ( son [ u ] != -1 ) { isbig [ son [ u ]] = 1 ; DSU ( son [ u ]); } Max = -1 ; query ( u ); ans [ u ] = Max ; if ( isbig [ u ]) update ( u ); if ( son [ u ] != -1 ) isbig [ son [ u ]] = 0 ; if ( ! isbig [ u ]) clear ( u ); } int main () { Init (); while ( scanf ( \"%d\" , & n ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) G [ i ]. clear (); memset ( son , -1 , sizeof son ); memset ( cnt , 0 , sizeof cnt ); memset ( cnt2 , 0 , sizeof cnt2 ); Max = -1 ; s . clear (); for ( int i = 2 , u ; i <= n ; ++ i ) { scanf ( \"%d\" , & u ); G [ u ]. push_back ( i ); } for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , arr + i ); DFS ( 1 ); DSU ( 1 ); for ( int i = 1 ; i <= n ; ++ i ) printf ( \"%d \\n \" , ans [ i ]); } return 0 ; } Code #include <bits/stdc++.h> using namespace std ; #define N 100010 vector < int > num [ N ], G [ N ]; int n ; int arr [ N ], rt [ N ], ans [ N ]; void Init () { for ( int i = 1 ; i <= 100000 ; ++ i ) for ( int j = i ; j <= 100000 ; j += i ) num [ j ]. push_back ( i ); } struct SEG { #define M N * 400 int lson [ M ], rson [ M ], c [ M ], cnt ; void init () { cnt = 0 ; } void pushup ( int id ) { c [ id ] = max ( c [ lson [ id ]], c [ rson [ id ]]); } void update ( int & x , int l , int r , int pos ) { if ( ! x ) x = ++ cnt ; if ( l == r ) { c [ x ] = pos ; return ; } int mid = ( l + r ) >> 1 ; pos <= mid ? update ( lson [ x ], l , mid , pos ) : update ( rson [ x ], mid + 1 , r , pos ); pushup ( x ); } int merge ( int u , int v , int & sum ) { if ( ! u || ! v ) return u | v ; if ( c [ u ] == c [ v ]) sum = max ( sum , c [ u ]); if ( lson [ u ] | lson [ v ]) lson [ u ] = merge ( lson [ u ], lson [ v ], sum ); if ( rson [ u ] | rson [ v ]) rson [ u ] = merge ( rson [ u ], rson [ v ], sum ); return u ; } } seg ; void DFS ( int u ) { ans [ u ] = -1 ; for ( auto v : G [ u ]) { DFS ( v ); seg . merge ( rt [ u ], rt [ v ], ans [ u ]); } } void Run () { Init (); while ( scanf ( \"%d\" , & n ) != EOF ) { seg . init (); for ( int i = 2 , u ; i <= n ; ++ i ) { scanf ( \"%d\" , & u ); G [ u ]. push_back ( i ); } for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , arr + i ); for ( int i = 1 ; i <= n ; ++ i ) for ( auto it : num [ arr [ i ]]) seg . update ( rt [ i ], 1 , 100000 , it ); DFS ( 1 ); for ( int i = 1 ; i <= n ; ++ i ) printf ( \"%d \\n \" , ans [ i ]); } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; }","title":"Problem E. TeaTree"},{"location":"trainings/2018-Multi-University-Trainings/Contest-10/#problem-f-newnippori","text":"\u7559\u5751\u3002","title":"Problem F. NewNippori"},{"location":"trainings/2018-Multi-University-Trainings/Contest-10/#problem-g-cyclic","text":"\u6253\u8868\u627e\u89c4\u5f8b\u5373\u53ef\u3002 F[n] = (n - 2) * F[n - 1] + (n - 1) * F[n - 2] + (i \\& 1 ? 1 : -1) F[n] = (n - 2) * F[n - 1] + (n - 1) * F[n - 2] + (i \\& 1 ? 1 : -1) Code #include <bits/stdc++.h> using namespace std ; #define N 100010 #define ll long long const ll MOD = 998244353 ; ll arr [ N ]; int main () { arr [ 4 ] = 1 , arr [ 5 ] = 8 ; for ( int i = 6 ; i <= 100000 ; ++ i ) arr [ i ] = (( i - 2 ) * arr [ i - 1 ] % MOD + ( i - 1 ) * arr [ i - 2 ] % MOD + (( i & 1 ) ? 1 : -1 ) + MOD ) % MOD ; int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); printf ( \"%lld \\n \" , arr [ n ]); } }","title":"Problem G. Cyclic"},{"location":"trainings/2018-Multi-University-Trainings/Contest-10/#problem-h-pow","text":"\u6c34\u3002 Code import java.util.Scanner ; import java.math.* ; public class Main { public static void main ( String [] args ) { Scanner in = new Scanner ( System . in ); int t = in . nextInt (); while ( t -- != 0 ) { int n = in . nextInt (); System . out . println ( BigInteger . valueOf ( 2 ). pow ( n )); } } }","title":"Problem H. Pow"},{"location":"trainings/2018-Multi-University-Trainings/Contest-10/#problem-i-count","text":"\u9898\u610f\uff1a \u6c42\uff1a \\sum_{i = 1} ^ {i = n} \\sum_{j = 1} ^ {j = i - 1} [gcd(i + j, i - j) == 1] \\sum_{i = 1} ^ {i = n} \\sum_{j = 1} ^ {j = i - 1} [gcd(i + j, i - j) == 1] \u601d\u8def\uff1a \u627e\u89c4\u5f8b\u3002 \u5982\u679c\u662f\u5947\u6570\u5c31\u52a0\u4e0a \\frac {\\varphi(n)}{2} \\frac {\\varphi(n)}{2} \uff0c\u5426\u5219\u52a0\u4e0a \\varphi(n) \\varphi(n) \u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int MAXN = 20000000 ; bool check [ MAXN + 10 ]; ll ans [ MAXN + 10 ]; int phi [ MAXN + 10 ]; int prime [ MAXN + 10 ]; int tot ; void phi_ans_prime_table () { memset ( check , false , sizeof check ); phi [ 1 ] = 1 ; tot = 0 ; for ( int i = 2 ; i <= MAXN ; ++ i ) { if ( ! check [ i ]) { prime [ tot ++ ] = i ; phi [ i ] = i - 1 ; } for ( int j = 0 ; j < tot ; ++ j ) { if ( i * prime [ j ] > MAXN ) break ; check [ i * prime [ j ]] = true ; if ( i % prime [ j ] == 0 ) { phi [ i * prime [ j ]] = phi [ i ] * prime [ j ]; break ; } else { phi [ i * prime [ j ]] = phi [ i ] * ( prime [ j ] - 1 ); } } if ( i & 1 ) ans [ i ] = ans [ i - 1 ] + phi [ i ] / 2 ; else ans [ i ] = ans [ i - 1 ] + phi [ i ]; } } int main () { phi_ans_prime_table (); int t ; scanf ( \"%d\" , & t ); while ( t -- ) { int n ; scanf ( \"%d\" , & n ); printf ( \"%lld \\n \" , ans [ n ]); } return 0 ; }","title":"Problem I. Count"},{"location":"trainings/2018-Multi-University-Trainings/Contest-10/#problem-j-csgo","text":"\u9898\u610f\uff1a \u6709 n n \u628a\u4e3b\u6b66\u5668\u548c m m \u628a\u526f\u6b66\u5668\uff0c\u6bcf\u628a\u6b66\u5668\u6709 k k \u79cd\u5c5e\u6027\uff0c\u9009\u53d6\u4e00\u628a\u4e3b\u6b66\u5668\u548c\u526f\u6b66\u5668\uff0c\u6c42\u9898\u4e2d\u5f0f\u5b50\u6700\u5927\u503c\u3002 \u601d\u8def\uff1a \u5bf9\u4e8e\u6bcf\u79cd\u5c5e\u6027\u53c8\u6709\u52a0\u51cf\u4e24\u79cd\u72b6\u6001\uff0c\u679a\u4e3e\u6bcf\u628a\u6b66\u5668\u7684\u6bcf\u79cd\u5c5e\u6027\u7684\u52a0\u51cf\u72b6\u6001\uff0c\u6c42\u6700\u5927\u503c\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll INFLL = 0x3f3f3f3f3f3f3f3f ; const int maxn = 1e5 + 10 ; ll arr [ maxn ][ 10 ], brr [ maxn ][ 10 ]; ll crr [ maxn ]; int n , m , k ; void RUN () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d %d\" , & n , & m , & k ); for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 0 ; j <= k ; ++ j ) scanf ( \"%lld\" , & arr [ i ][ j ]); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 0 ; j <= k ; ++ j ) scanf ( \"%lld\" , & brr [ i ][ j ]); memset ( crr , 0 , sizeof crr ); ll ans = 0 ; int limit = ( 1 << k ); for ( int i = 1 ; i <= n ; ++ i ) { for ( int S = 0 ; S < limit ; ++ S ) { ll tmp = arr [ i ][ 0 ]; for ( int j = 0 ; j < k ; ++ j ) { if ( S & ( 1 << j )) { tmp += arr [ i ][ j + 1 ]; } else { tmp -= arr [ i ][ j + 1 ]; } } crr [ S ] = max ( crr [ S ], tmp ); } } for ( int i = 1 ; i <= m ; ++ i ) { for ( int S = 0 ; S < limit ; ++ S ) { ll tmp = brr [ i ][ 0 ]; for ( int j = 0 ; j < k ; ++ j ) { if ( S & ( 1 << j )) { tmp += brr [ i ][ j + 1 ]; } else { tmp -= brr [ i ][ j + 1 ]; } } ans = max ( ans , tmp + crr [ limit - 1 - S ]); } } printf ( \"%lld \\n \" , ans ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE return 0 ; } Code #include <bits/stdc++.h> using namespace std ; #define N 100010 #define ll long long #define INF 0x3f3f3f3f3f3f3f3f int t , n , m , K ; struct node { int x [ 10 ]; void scan ( int vis ) { scanf ( \"%d\" , x + vis ); for ( int i = 2 ; i <= K + 1 ; ++ i ) scanf ( \"%d\" , x + i ); } } a [ N ], b [ N ]; void Run () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d%d\" , & n , & m , & K ); for ( int i = 1 ; i <= n ; ++ i ) a [ i ]. scan ( 0 ); for ( int i = 1 ; i <= m ; ++ i ) b [ i ]. scan ( 1 ); ll res = 0 ; for ( int i = 0 ; i < ( 1 << ( K + 2 )); ++ i ) { bitset < 7 > bit ; bit = i ; ll Max [ 2 ] = { - INF , - INF }; ll Min [ 2 ] = { INF , INF }; for ( int j = 1 ; j <= n ; ++ j ) { ll tmp = 0 ; for ( int k = 0 ; k <= K + 1 ; ++ k ) tmp += a [ j ]. x [ k ] * ( bit [ k ] ? 1 : -1 ); Max [ 0 ] = max ( Max [ 0 ], tmp ); Min [ 0 ] = min ( Min [ 0 ], tmp ); } for ( int j = 1 ; j <= m ; ++ j ) { ll tmp = 0 ; for ( int k = 0 ; k <= K + 1 ; ++ k ) tmp += b [ j ]. x [ k ] * ( bit [ k ] ? 1 : -1 ); Max [ 1 ] = max ( Max [ 1 ], tmp ); Min [ 1 ] = min ( Min [ 1 ], tmp ); } res = max ( res , max ( Max [ 0 ] - Min [ 1 ], Max [ 1 ] - Min [ 0 ])); } printf ( \"%lld \\n \" , res ); } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; }","title":"Problem J. CSGO"},{"location":"trainings/2018-Multi-University-Trainings/Contest-10/#problem-k-pow2","text":"\u7559\u5751\u3002","title":"Problem K. Pow2"},{"location":"trainings/2018-Multi-University-Trainings/Contest-10/#problem-lvideos","text":"\u9898\u610f\uff1a \u6bcf\u5929\u6709 n n \u4e2a\u5c0f\u65f6\uff0c\u6709 m m \u90e8\u7535\u5f71\uff0c k k \u4e2a\u4eba\u3002 \u6bcf\u90e8\u7535\u5f71\u53ea\u80fd\u88ab\u4e00\u4e2a\u4eba\u770b\uff0c\u5f97\u5230 w w \u5feb\u4e50\u503c\u3002 \u7535\u5f71\u79cd\u7c7b\u6709 A,B A,B \u4e24\u79cd\uff0c\u540c\u4e00\u4eba\u8fde\u7740\u770b\u540c\u79cd\u7535\u5f71\u8981\u51cf\u53bb W W \u5feb\u4e50\u503c\uff0c\u5982\u4f55\u5b89\u6392\u4f7f\u5f97\u5feb\u4e50\u503c\u6700\u5927\u3002 \u601d\u8def\uff1a \u5c06\u4e00\u90e8\u7535\u5f71\u62c6\u6210\u4e24\u4e2a\u70b9 S S \u548c T T \u6d41\u4e3a 1 1 \uff0c\u8d39\u7528\u4e3a -w -w \u3002 \u7535\u5f71\u4e0e\u7535\u5f71\u4e4b\u95f4\u5982\u679c\u662f\u53ef\u4ee5\u8fde\u7740\u770b\u7684\uff0c\u5c31\u8fde\u8fb9\uff0c\u5982\u679c\u662f\u540c\u79cd\u7c7b\uff0c\u8d39\u7528\u5c31\u662f W W , \u5426\u5219\u5c31\u662f 0 0 \uff0c\u6d41\u4e3a 1 1 \u3002 \u6e90\u70b9\u8fde\u51fa\u6765\u52a0\u4e00\u4e2a\u70b9\uff0c\u6d41\u91cf\u4e3a k k \uff0c\u9650\u5236\u4e3a k k \u4e2a\u4eba\u3002 Code #include <bits/stdc++.h> using namespace std ; const int INF = 0x3f3f3f3f ; const int maxn = 1e4 + 10 ; const int maxm = 1e5 + 10 ; struct Edge { int to , nxt , cap , flow , cost ; } edge [ maxm ]; int head [ maxn ], tot ; int pre [ maxn ], dis [ maxn ]; bool vis [ maxn ]; int N ; void Init ( int n ) { N = n ; tot = 0 ; for ( int i = 0 ; i < n ; ++ i ) head [ i ] = -1 ; } void addedge ( int u , int v , int cap , int cost ) { edge [ tot ]. to = v ; edge [ tot ]. cap = cap ; edge [ tot ]. cost = cost ; edge [ tot ]. flow = 0 ; edge [ tot ]. nxt = head [ u ]; head [ u ] = tot ++ ; edge [ tot ]. to = u ; edge [ tot ]. cap = 0 ; edge [ tot ]. cost = - cost ; edge [ tot ]. flow = 0 ; edge [ tot ]. nxt = head [ v ]; head [ v ] = tot ++ ; } bool SPFA ( int s , int t ) { queue < int > q ; for ( int i = 0 ; i < N ; ++ i ) dis [ i ] = INF , pre [ i ] = -1 , vis [ i ] = false ; dis [ s ] = 0 ; vis [ s ] = true ; q . push ( s ); while ( ! q . empty ()) { int u = q . front (); q . pop (); vis [ u ] = false ; for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { int v = edge [ i ]. to ; if ( edge [ i ]. cap > edge [ i ]. flow && dis [ v ] > dis [ u ] + edge [ i ]. cost ) { dis [ v ] = dis [ u ] + edge [ i ]. cost ; pre [ v ] = i ; if ( ! vis [ v ]) { vis [ v ] = true ; q . push ( v ); } } } } if ( pre [ t ] == -1 ) return false ; else return true ; } int minCostMaxflow ( int s , int t , int & cost ) { int flow = 0 ; cost = 0 ; while ( SPFA ( s , t )) { int Min = INF ; for ( int i = pre [ t ]; ~ i ; i = pre [ edge [ i ^ 1 ]. to ]) { if ( Min > edge [ i ]. cap - edge [ i ]. flow ) { Min = edge [ i ]. cap - edge [ i ]. flow ; } } for ( int i = pre [ t ]; ~ i ; i = pre [ edge [ i ^ 1 ]. to ]) { edge [ i ]. flow += Min ; edge [ i ^ 1 ]. flow -= Min ; cost += edge [ i ]. cost * Min ; } flow += Min ; } return flow ; } struct node { int si , ti , wi , op ; } arr [ maxn ]; int n , m , K , W ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d %d %d\" , & n , & m , & K , & W ); for ( int i = 1 ; i <= m ; ++ i ) scanf ( \"%d %d %d %d\" , & arr [ i ]. si , & arr [ i ]. ti , & arr [ i ]. wi , & arr [ i ]. op ); Init ( 2 * m + 3 ); addedge ( 0 , 2 * m + 1 , K , 0 ); for ( int i = 1 ; i <= m ; ++ i ) addedge ( 2 * m + 1 , 2 * i - 1 , 1 , 0 ); for ( int i = 1 ; i <= m ; ++ i ) addedge ( 2 * i - 1 , 2 * i , 1 , - arr [ i ]. wi ); for ( int i = 1 ; i <= m ; ++ i ) addedge ( 2 * i , 2 * m + 2 , 1 , 0 ); for ( int i = 1 ; i <= m ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( i == j ) continue ; if ( arr [ i ]. ti <= arr [ j ]. si ) { if ( arr [ i ]. op == arr [ j ]. op ) { addedge ( 2 * i , 2 * j - 1 , 1 , W ); } else { addedge ( 2 * i , 2 * j - 1 , 1 , 0 ); } } } } int cost = 0 ; minCostMaxflow ( 0 , 2 * m + 2 , cost ); printf ( \"%d \\n \" , - cost ); } return 0 ; }","title":"Problem L.Videos"},{"location":"trainings/2018-Multi-University-Trainings/Contest-2/","text":"2018 Multi-University Training Contest 2 Contents A. Absolute B. Counting Permutations C. Cover D. Game E. Hack It F. Matrix G. Naive Operations H. Odd Shops I. Segment J. Swaps and Inversions A. Absolute \u7559\u5751\u3002 B. Counting Permutations \u7559\u5751\u3002 C. Cover \u7559\u5751\u3002 D. Game puts(\"Yes\") \u3002 Code #include <bits/stdc++.h> using namespace std ; int n ; int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { puts ( \"Yes\" ); } return 0 ; } E. Hack It \u7559\u5751\u3002 F. Matrix \u7559\u5751\u3002 G. Naive Operations \u9898\u610f\uff1a \u7ed9\u51fa b[] b[] \u6570\u7ec4\uff0c\u91cc\u9762\u662f 1-n 1-n \u7684\u5168\u6392\u5217\u3002 \u4e24\u79cd\u64cd\u4f5c\uff1a \u533a\u95f4 +1 +1 \u3002 \u533a\u95f4\u6c42 \\displaystyle \\sum_{i = l} ^ {i = r} \\lfloor \\frac{a_i}{b_i} \\rfloor \\displaystyle \\sum_{i = l} ^ {i = r} \\lfloor \\frac{a_i}{b_i} \\rfloor \u3002 \u601d\u8def\uff1a \u7ef4\u62a4\u4e00\u4e2a Min \u8868\u793a\u8fd9\u4e2a\u533a\u95f4\u5185\u9700\u8981\u7684\u6700\u5c11\u7684\u8fdb\u4f4d\uff0c\u5982\u679c\u6709\u8fdb\u4f4d\uff0c\u5c31\u66f4\u65b0\u5230\u5e95\uff0c\u5982\u679c\u6ca1\u6709\u8fdb\u4f4d\u5c31\u533a\u95f4\u66f4\u65b0\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 #define ll long long ll arr [ N ]; struct node { int l , r ; ll Min , lazy , sum , v ; inline node () {} inline node ( int _l , int _r ) { l = _l ; r = _r ; Min = 0 , lazy = 0 , sum = 0 , v = 0 ; } } tree [ N << 2 ]; inline void pushup ( int id ) { tree [ id ]. Min = min ( tree [ id << 1 ]. Min , tree [ id << 1 | 1 ]. Min ); tree [ id ]. sum = tree [ id << 1 ]. sum + tree [ id << 1 | 1 ]. sum ; } inline void pushdown ( int id ) { if ( tree [ id ]. l >= tree [ id ]. r ) return ; if ( tree [ id ]. lazy ) { tree [ id << 1 ]. lazy += tree [ id ]. lazy ; tree [ id << 1 | 1 ]. lazy += tree [ id ]. lazy ; tree [ id << 1 ]. Min -= tree [ id ]. lazy ; tree [ id << 1 | 1 ]. Min -= tree [ id ]. lazy ; tree [ id ]. lazy = 0 ; } } inline void build ( int id , int l , int r ) { tree [ id ] = node ( l , r ); if ( l == r ) { tree [ id ]. v = arr [ l ]; tree [ id ]. Min = arr [ l ]; return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); pushup ( id ); } inline void update ( int id , int l , int r ) { if ( tree [ id ]. l == l && tree [ id ]. r == r && tree [ id ]. Min > 1 ) { tree [ id ]. lazy ++ ; tree [ id ]. Min -- ; return ; } if ( tree [ id ]. l == tree [ id ]. r && tree [ id ]. Min == 1 ) { tree [ id ]. Min = tree [ id ]. v ; tree [ id ]. sum ++ ; return ; } pushdown ( id ); int mid = ( tree [ id ]. l + tree [ id ]. r ) >> 1 ; if ( r <= mid ) update ( id << 1 , l , r ); else if ( l > mid ) update ( id << 1 | 1 , l , r ); else { update ( id << 1 , l , mid ); update ( id << 1 | 1 , mid + 1 , r ); } pushup ( id ); } ll anssum ; inline void query ( int id , int l , int r ) { if ( tree [ id ]. l >= l && tree [ id ]. r <= r ) { anssum += tree [ id ]. sum ; return ; } pushdown ( id ); int mid = ( tree [ id ]. l + tree [ id ]. r ) >> 1 ; if ( l <= mid ) query ( id << 1 , l , r ); if ( r > mid ) query ( id << 1 | 1 , l , r ); pushup ( id ); } int n , m ; char str [ 100 ]; int l , r ; int main () { while ( ~ scanf ( \"%d %d\" , & n , & m )) { for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%lld\" , arr + i ); build ( 1 , 1 , n ); for ( int i = 1 ; i <= m ; ++ i ) { scanf ( \"%s\" , str ); if ( str [ 0 ] == 'a' ) { scanf ( \"%d %d\" , & l , & r ); update ( 1 , l , r ); } else { scanf ( \"%d %d\" , & l , & r ); anssum = 0 ; query ( 1 , l , r ); printf ( \"%lld \\n \" , anssum ); } } } return 0 ; } H. Odd Shops \u7559\u5751\u3002 I. Segment \u7559\u5751\u3002 J. Swaps and Inversions \u6c34\u3002 \u9006\u5e8f\u5bf9\u7684\u610f\u4e49\u5c31\u662f\u6bcf\u6b21\u53ea\u80fd\u4ea4\u6362\u76f8\u90bb\u4e24\u4e2a\uff0c\u6700\u5c11\u7684\u4ea4\u6362\u6b21\u6570\u3002 Code #include <bits/stdc++.h> using namespace std ; #define ll long long #define N 100010 int n , m ; ll x , y ; int arr [ N ], brr [ N ]; int a [ N ]; inline void Init () { for ( int i = 1 ; i <= n ; ++ i ) brr [ i ] = arr [ i ]; sort ( brr + 1 , brr + 1 + n ); m = unique ( brr + 1 , brr + 1 + n ) - brr - 1 ; } inline int Get ( int x ) { return lower_bound ( brr + 1 , brr + 1 + m , x ) - brr ; } inline int lowbit ( int x ) { return x & ( - x ); } inline void update ( int x , int val ) { for ( int i = x ; i <= n ; i += lowbit ( i )) a [ i ] += val ; } inline int query ( int x ) { int res = 0 ; for ( int i = x ; i > 0 ; i -= lowbit ( i )) res += a [ i ]; return res ; } int main () { while ( scanf ( \"%d%lld%lld\" , & n , & x , & y ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , arr + i ); Init (); memset ( a , 0 , sizeof a ); for ( int i = 1 ; i <= n ; ++ i ) arr [ i ] = Get ( arr [ i ]); ll ans = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { // ans += i - 1 - query(arr[i] - 1); // printf(\"%d %d\\n\", arr[i], query(arr[i] - 1)); update ( arr [ i ], 1 ); ans += i - query ( arr [ i ]); // cout << arr[i] << \" \" << query(arr[i]) << endl; } printf ( \"%lld \\n \" , min ( ans * x , ans * y )); } return 0 ; }","title":"2018 Multi-University Training Contest 2"},{"location":"trainings/2018-Multi-University-Trainings/Contest-2/#a-absolute","text":"\u7559\u5751\u3002","title":"A. Absolute"},{"location":"trainings/2018-Multi-University-Trainings/Contest-2/#b-counting-permutations","text":"\u7559\u5751\u3002","title":"B. Counting Permutations"},{"location":"trainings/2018-Multi-University-Trainings/Contest-2/#c-cover","text":"\u7559\u5751\u3002","title":"C. Cover"},{"location":"trainings/2018-Multi-University-Trainings/Contest-2/#d-game","text":"puts(\"Yes\") \u3002 Code #include <bits/stdc++.h> using namespace std ; int n ; int main () { while ( scanf ( \"%d\" , & n ) != EOF ) { puts ( \"Yes\" ); } return 0 ; }","title":"D. Game"},{"location":"trainings/2018-Multi-University-Trainings/Contest-2/#e-hack-it","text":"\u7559\u5751\u3002","title":"E. Hack It"},{"location":"trainings/2018-Multi-University-Trainings/Contest-2/#f-matrix","text":"\u7559\u5751\u3002","title":"F. Matrix"},{"location":"trainings/2018-Multi-University-Trainings/Contest-2/#g-naive-operations","text":"\u9898\u610f\uff1a \u7ed9\u51fa b[] b[] \u6570\u7ec4\uff0c\u91cc\u9762\u662f 1-n 1-n \u7684\u5168\u6392\u5217\u3002 \u4e24\u79cd\u64cd\u4f5c\uff1a \u533a\u95f4 +1 +1 \u3002 \u533a\u95f4\u6c42 \\displaystyle \\sum_{i = l} ^ {i = r} \\lfloor \\frac{a_i}{b_i} \\rfloor \\displaystyle \\sum_{i = l} ^ {i = r} \\lfloor \\frac{a_i}{b_i} \\rfloor \u3002 \u601d\u8def\uff1a \u7ef4\u62a4\u4e00\u4e2a Min \u8868\u793a\u8fd9\u4e2a\u533a\u95f4\u5185\u9700\u8981\u7684\u6700\u5c11\u7684\u8fdb\u4f4d\uff0c\u5982\u679c\u6709\u8fdb\u4f4d\uff0c\u5c31\u66f4\u65b0\u5230\u5e95\uff0c\u5982\u679c\u6ca1\u6709\u8fdb\u4f4d\u5c31\u533a\u95f4\u66f4\u65b0\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 #define ll long long ll arr [ N ]; struct node { int l , r ; ll Min , lazy , sum , v ; inline node () {} inline node ( int _l , int _r ) { l = _l ; r = _r ; Min = 0 , lazy = 0 , sum = 0 , v = 0 ; } } tree [ N << 2 ]; inline void pushup ( int id ) { tree [ id ]. Min = min ( tree [ id << 1 ]. Min , tree [ id << 1 | 1 ]. Min ); tree [ id ]. sum = tree [ id << 1 ]. sum + tree [ id << 1 | 1 ]. sum ; } inline void pushdown ( int id ) { if ( tree [ id ]. l >= tree [ id ]. r ) return ; if ( tree [ id ]. lazy ) { tree [ id << 1 ]. lazy += tree [ id ]. lazy ; tree [ id << 1 | 1 ]. lazy += tree [ id ]. lazy ; tree [ id << 1 ]. Min -= tree [ id ]. lazy ; tree [ id << 1 | 1 ]. Min -= tree [ id ]. lazy ; tree [ id ]. lazy = 0 ; } } inline void build ( int id , int l , int r ) { tree [ id ] = node ( l , r ); if ( l == r ) { tree [ id ]. v = arr [ l ]; tree [ id ]. Min = arr [ l ]; return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); pushup ( id ); } inline void update ( int id , int l , int r ) { if ( tree [ id ]. l == l && tree [ id ]. r == r && tree [ id ]. Min > 1 ) { tree [ id ]. lazy ++ ; tree [ id ]. Min -- ; return ; } if ( tree [ id ]. l == tree [ id ]. r && tree [ id ]. Min == 1 ) { tree [ id ]. Min = tree [ id ]. v ; tree [ id ]. sum ++ ; return ; } pushdown ( id ); int mid = ( tree [ id ]. l + tree [ id ]. r ) >> 1 ; if ( r <= mid ) update ( id << 1 , l , r ); else if ( l > mid ) update ( id << 1 | 1 , l , r ); else { update ( id << 1 , l , mid ); update ( id << 1 | 1 , mid + 1 , r ); } pushup ( id ); } ll anssum ; inline void query ( int id , int l , int r ) { if ( tree [ id ]. l >= l && tree [ id ]. r <= r ) { anssum += tree [ id ]. sum ; return ; } pushdown ( id ); int mid = ( tree [ id ]. l + tree [ id ]. r ) >> 1 ; if ( l <= mid ) query ( id << 1 , l , r ); if ( r > mid ) query ( id << 1 | 1 , l , r ); pushup ( id ); } int n , m ; char str [ 100 ]; int l , r ; int main () { while ( ~ scanf ( \"%d %d\" , & n , & m )) { for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%lld\" , arr + i ); build ( 1 , 1 , n ); for ( int i = 1 ; i <= m ; ++ i ) { scanf ( \"%s\" , str ); if ( str [ 0 ] == 'a' ) { scanf ( \"%d %d\" , & l , & r ); update ( 1 , l , r ); } else { scanf ( \"%d %d\" , & l , & r ); anssum = 0 ; query ( 1 , l , r ); printf ( \"%lld \\n \" , anssum ); } } } return 0 ; }","title":"G. Naive Operations"},{"location":"trainings/2018-Multi-University-Trainings/Contest-2/#h-odd-shops","text":"\u7559\u5751\u3002","title":"H. Odd Shops"},{"location":"trainings/2018-Multi-University-Trainings/Contest-2/#i-segment","text":"\u7559\u5751\u3002","title":"I. Segment"},{"location":"trainings/2018-Multi-University-Trainings/Contest-2/#j-swaps-and-inversions","text":"\u6c34\u3002 \u9006\u5e8f\u5bf9\u7684\u610f\u4e49\u5c31\u662f\u6bcf\u6b21\u53ea\u80fd\u4ea4\u6362\u76f8\u90bb\u4e24\u4e2a\uff0c\u6700\u5c11\u7684\u4ea4\u6362\u6b21\u6570\u3002 Code #include <bits/stdc++.h> using namespace std ; #define ll long long #define N 100010 int n , m ; ll x , y ; int arr [ N ], brr [ N ]; int a [ N ]; inline void Init () { for ( int i = 1 ; i <= n ; ++ i ) brr [ i ] = arr [ i ]; sort ( brr + 1 , brr + 1 + n ); m = unique ( brr + 1 , brr + 1 + n ) - brr - 1 ; } inline int Get ( int x ) { return lower_bound ( brr + 1 , brr + 1 + m , x ) - brr ; } inline int lowbit ( int x ) { return x & ( - x ); } inline void update ( int x , int val ) { for ( int i = x ; i <= n ; i += lowbit ( i )) a [ i ] += val ; } inline int query ( int x ) { int res = 0 ; for ( int i = x ; i > 0 ; i -= lowbit ( i )) res += a [ i ]; return res ; } int main () { while ( scanf ( \"%d%lld%lld\" , & n , & x , & y ) != EOF ) { for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , arr + i ); Init (); memset ( a , 0 , sizeof a ); for ( int i = 1 ; i <= n ; ++ i ) arr [ i ] = Get ( arr [ i ]); ll ans = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { // ans += i - 1 - query(arr[i] - 1); // printf(\"%d %d\\n\", arr[i], query(arr[i] - 1)); update ( arr [ i ], 1 ); ans += i - query ( arr [ i ]); // cout << arr[i] << \" \" << query(arr[i]) << endl; } printf ( \"%lld \\n \" , min ( ans * x , ans * y )); } return 0 ; }","title":"J. Swaps and Inversions"},{"location":"trainings/2018-Multi-University-Trainings/Contest-3/","text":"2018 Multi-University Training Contest 3 Contents Problem A. Ascending Rating Problem B. Cut The String Problem C. Dynamic Graph Matching Problem D. Euler Function Problem E. Find The Submatrix Problem F. Grab The Tree Problem G. Interstellar Travel Problem H. Monster Hunter Problem I. Random Sequence Problem J. Rectangle Radar Scanner Problem K. Transport Construction Problem L. Visual Cube Problem M. Walking Plan Problem A. Ascending Rating \u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u6570\uff0c\u7ed9\u51fa\u533a\u95f4\u957f\u5ea6 m m \u3002\u5bf9\u4e8e\u6bcf\u4e2a\u533a\u95f4\uff0c\u521d\u59cb\u503c\u7684 max max \u4e3a 0 0 \uff0c cnt cnt \u4e3a 0 0 . \u9047\u5230\u4e00\u4e2a a[i] > ans a[i] > ans , \u66f4\u65b0 ans ans \u5e76\u4e14 cnt++ cnt++ \u3002 \u8ba1\u7b97 \\begin{eqnarray*} A &=& \\sum_{i = 1}^{i = n - m +1} (max \\oplus i) \\\\ B &=& \\sum_{i = 1}^{i = n - m +1} (cnt \\oplus i) \\end{eqnarray*} \\begin{eqnarray*} A &=& \\sum_{i = 1}^{i = n - m +1} (max \\oplus i) \\\\ B &=& \\sum_{i = 1}^{i = n - m +1} (cnt \\oplus i) \\end{eqnarray*} \u601d\u8def\uff1a \u5355\u8c03\u961f\u5217\uff0c\u5012\u7740\u626b\u4e00\u904d\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u533a\u95f4\u7684 cnt cnt \u5c31\u662f\u961f\u5217\u7684\u957f\u5ea6\uff0c\u626b\u4e00\u904d\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; const int maxn = 1e7 + 10 ; typedef long long ll ; int t ; int n , m , k ; ll p , q , r , mod ; ll arr [ maxn ]; ll brr [ maxn ]; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d %d %lld %lld %lld %lld\" , & n , & m , & k , & p , & q , & r , & mod ); for ( int i = 1 ; i <= n ; ++ i ) { if ( i <= k ) scanf ( \"%lld\" , arr + i ); else arr [ i ] = ( p * arr [ i - 1 ] + q * i + r ) % mod ; } ll A = 0 , B = 0 ; int head = 0 , tail = -1 ; for ( int i = n ; i > ( n - m + 1 ); -- i ) { while ( head <= tail && arr [ i ] >= arr [ brr [ tail ]]) tail -- ; brr [ ++ tail ] = i ; } for ( int i = n - m + 1 ; i >= 1 ; -- i ) { while ( head <= tail && arr [ i ] >= arr [ brr [ tail ]]) tail -- ; brr [ ++ tail ] = i ; while ( brr [ head ] - i >= m ) head ++ ; A += arr [ brr [ head ]] ^ i ; B += ( tail - head + 1 ) ^ i ; } printf ( \"%lld %lld \\n \" , A , B ); } return 0 ; } Problem B. Cut The String \u7559\u5751\u3002 Problem C. Dynamic Graph Matching \u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u70b9\u3002 \u4e24\u79cd\u64cd\u4f5c\uff0c\u4e00\u79cd\u662f\u52a0\u8fb9\uff0c\u4e00\u79cd\u662f\u51cf\u8fb9\uff0c\u6bcf\u6b21\u52a0\u4e00\u6761\u6216\u8005\u51cf\u4e00\u6761\u3002 \u6bcf\u6b21\u64cd\u4f5c\u540e\u8f93\u51fa 1, 2, \\cdots, \\frac{n}{2} 1, 2, \\cdots, \\frac{n}{2} \u8868\u793a\u5bf9\u5e94\u7684\u6570\u91cf\u7684\u8fb9\u3002 \u95ee\u6709\u51e0\u79cd\u53d6\u6cd5\uff0c\u5e76\u4e14\u4efb\u610f\u4e24\u4e2a\u8fb9\u4e0d\u80fd\u76f8\u90bb\u3002 \u601d\u8def\uff1a \u6bcf\u52a0\u4e00\u6761\u8fb9\uff0c\u90fd\u53ef\u4ee5\u8f6c\u79fb\u72b6\u6001 \u6bd4\u5982\u8bf4 110100 \u5230 111110 \u5c31\u662f dp[111110] += dp[110100] \u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int maxn = 1 << 10 ; const int MOD = 1e9 + 7 ; int t , n , m ; ll dp [ maxn ]; ll ans [ 12 ]; inline int cal ( int x ) { int cnt = 0 ; while ( x ) { if ( x & 1 ) cnt ++ ; x >>= 1 ; } return cnt ; } int main () { scanf ( \"%d\" , & t ); while ( t -- ) { memset ( ans , 0 , sizeof ans ); memset ( dp , 0 , sizeof dp ); dp [ 0 ] = 1 ; scanf ( \"%d %d\" , & n , & m ); while ( m -- ) { char op [ 10 ]; int u , v ; scanf ( \"%s %d %d\" , op , & u , & v ); -- u , -- v ; for ( int s = 0 ; s < ( 1 << n ); ++ s ) { if (( s & ( 1 << u )) || ( s & ( 1 << v ))) continue ; int S = s | ( 1 << u ); S |= ( 1 << v ); if ( op [ 0 ] == '+' ) { dp [ S ] = ( dp [ S ] + dp [ s ]) % MOD ; ans [ cal ( S )] = ( ans [ cal ( S )] + dp [ s ]) % MOD ; } else if ( op [ 0 ] == '-' ) { dp [ S ] = ( dp [ S ] - dp [ s ] + MOD ) % MOD ; ans [ cal ( S )] = ( ans [ cal ( S )] - dp [ s ] + MOD ) % MOD ; } } for ( int i = 2 ; i <= n ; i += 2 ) { printf ( \"%lld%c\" , ans [ i ], \" \\n \" [ i == n ]); } } } return 0 ; } Problem D. Euler Function \u6253\u8868\u627e\u89c4\u5f8b\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 inline int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ); } inline void Init () { for ( int i = 1 ; i <= 100 ; ++ i ) { int res = 0 ; for ( int j = 1 ; j < i ; ++ j ) res += ( gcd ( i , j ) == 1 ); printf ( \"%d %d \\n \" , i , res ); } } int t , n ; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); if ( n == 1 ) puts ( \"5\" ); else printf ( \"%d \\n \" , n + 5 ); } return 0 ; } Problem E. Find The Submatrix \u7559\u5751\u3002 Problem F. Grab The Tree \u9898\u610f\uff1a \u4e00\u68f5\u6811\uff0c\u6bcf\u4e2a\u70b9\u6709\u70b9\u6743\uff0c\u5c0f Q \u53ef\u4ee5\u9009\u62e9\u82e5\u5e72\u4e2a\u70b9\uff0c\u5e76\u4e14\u4efb\u610f\u4e24\u4e2a\u70b9\u4e4b\u95f4\u6ca1\u6709\u8fb9\uff0c\u5c0f T \u5c31\u662f\u5269\u4e0b\u7684\u6240\u6709\u70b9\uff0c\u7136\u540e\u4e24\u4e2a\u4eba\u7684\u503c\u5c31\u662f\u62e5\u6709\u7684\u70b9\u5f02\u6216\u8d77\u6765\uff0c\u6c42\u5c0f Q \u8d62\u8fd8\u662f\u8f93\u8fd8\u662f\u5e73\u5c40\u3002 \u601d\u8def\uff1a \u663e\u7136\uff0c\u53ea\u6709\u8d62\u6216\u8005\u5e73\u5c40\u7684\u60c5\u51b5\uff0c\u53ea\u8981\u8003\u8651\u662f\u5426\u6709\u5e73\u5c40\u60c5\u51b5\u5c31\u53ef\u4ee5\uff0c\u5f53\u6240\u6709\u70b9\u5f02\u6216\u8d77\u6765\u4e3a 0 0 \u4fbf\u662f\u5e73\u5c40\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 int t , n ; int arr [ N ]; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , arr + i ); res ^= arr [ i ]; } for ( int i = 1 , u , v ; i < n ; ++ i ) scanf ( \"%d%d\" , & u , & v ); if ( res == 0 ) { puts ( \"D\" ); continue ; } puts ( \"Q\" ); } return 0 ; } Problem G. Interstellar Travel \u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u70b9\u3002 \u8981\u4ece i -> j i -> j \u5f53\u4e14\u4ec5\u5f53 x_i < x_j x_i < x_j \u82b1\u8d39\u4e3a x_i \\cdot y_j - x_j \\cdot y_i x_i \\cdot y_j - x_j \\cdot y_i \u3002 \u6c42\u4ece 1 -> n 1 -> n \u7684\u6743\u503c\u6700\u5c0f\u3002 \u5982\u679c\u591a\u89e3\u8f93\u51fa\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u89e3\u3002 \u601d\u8def\uff1a \u53ef\u4ee5\u53d1\u73b0\u6743\u503c\u5c31\u662f\u53c9\u79ef\u3002 \u6c42\u4e2a\u51f8\u5305\u3002 \u7136\u540e\u8003\u8651\u5728\u4e00\u6761\u7ebf\u4e0a\u7684\u60c5\u51b5\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 200010 const double eps = 1e-8 ; inline int sgn ( double x ) { if ( fabs ( x ) < eps ) return 0 ; if ( x < 0 ) return -1 ; else return 1 ; } struct Point { double x , y ; int id ; inline Point () {} inline Point ( double x , double y ) : x ( x ), y ( y ) {} inline void scan ( int _id ) { id = _id ; scanf ( \"%lf%lf\" , & x , & y ); } inline bool operator == ( const Point & r ) const { return sgn ( x - r . x ) == 0 && sgn ( y - r . y ) == 0 ; } inline bool operator < ( const Point & r ) const { return x < r . x || x == r . x && y < r . y || x == r . x && y == r . y && id < r . id ; } inline Point operator + ( const Point & r ) const { return Point ( x + r . x , y + r . y ); } inline Point operator - ( const Point & r ) const { return Point ( x - r . x , y - r . y ); } inline double operator ^ ( const Point & r ) const { return x * r . y - y * r . x ; } inline double distance ( const Point & r ) const { return hypot ( x - r . x , y - r . y ); } }; struct Polygon { int n ; Point p [ N ]; struct cmp { Point p ; inline cmp ( const Point & p0 ) { p = p0 ; } inline bool operator ()( const Point & aa , const Point & bb ) { Point a = aa , b = bb ; int d = sgn (( a - p ) ^ ( b - p )); if ( d == 0 ) { return sgn ( a . distance ( p ) - b . distance ( p )) < 0 ; } return d < 0 ; } }; inline void norm () { Point mi = p [ 0 ]; for ( int i = 1 ; i < n ; ++ i ) mi = min ( mi , p [ i ]); sort ( p , p + n , cmp ( mi )); } inline void Graham ( Polygon & convex ) { sort ( p + 1 , p + n - 1 ); int cnt = 1 ; for ( int i = 1 ; i < n ; ++ i ) { if ( ! ( p [ i ] == p [ i - 1 ])) p [ cnt ++ ] = p [ i ]; } n = cnt ; norm (); int & top = convex . n ; top = 0 ; if ( n == 2 ) { top = 2 ; convex . p [ 0 ] = p [ 0 ]; convex . p [ 1 ] = p [ 1 ]; return ; } if ( n == 3 ) { top = 3 ; convex . p [ 0 ] = p [ 0 ]; convex . p [ 1 ] = p [ 1 ]; convex . p [ 2 ] = p [ 2 ]; return ; } convex . p [ 0 ] = p [ 0 ]; convex . p [ 1 ] = p [ 1 ]; top = 2 ; for ( int i = 2 ; i < n ; ++ i ) { while ( top > 1 && sgn (( convex . p [ top - 1 ] - convex . p [ top - 2 ]) ^ ( p [ i ] - convex . p [ top - 2 ])) >= 0 ) { if ( sgn (( convex . p [ top - 1 ] - convex . p [ top - 2 ]) ^ ( p [ i ] - convex . p [ top - 2 ])) == 0 ) { if ( p [ i ]. id < convex . p [ top - 1 ]. id ) -- top ; else break ; } else { -- top ; } } convex . p [ top ++ ] = p [ i ]; } if ( convex . n == 2 && ( convex . p [ 0 ] == convex . p [ 1 ])) -- convex . n ; } } arr , ans ; int t , n ; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); arr . n = n ; // cout << n << endl; for ( int i = 0 ; i < n ; ++ i ) arr . p [ i ]. scan ( i + 1 ); arr . Graham ( ans ); for ( int i = 0 ; i < ans . n ; ++ i ) printf ( \"%d%c\" , ans . p [ i ]. id , \" \\n \" [ i == ans . n - 1 ]); } return 0 ; } Problem H. Monster Hunter \u7559\u5751\u3002 Problem I. Random Sequence \u7559\u5751\u3002 Problem J. Rectangle Radar Scanner \u7559\u5751\u3002 Problem K. Transport Construction \u7559\u5751\u3002 Problem L. Visual Cube \u6309\u9898\u610f\u6a21\u62df\u5373\u53ef\uff0c\u5206\u5757\u89e3\u51b3\u3002 Code #include <bits/stdc++.h> using namespace std ; int t , a , b , c , n , m ; char ans [ 200 ][ 200 ]; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { memset ( ans , 0 , sizeof ans ); scanf ( \"%d%d%d\" , & a , & b , & c ); n = ( b + c ) * 2 + 1 ; m = ( a + b ) * 2 + 1 ; for ( int i = n , cnt = 1 ; cnt <= c ; ++ cnt , i -= 2 ) { for ( int j = 1 ; j <= 2 * a ; j += 2 ) ans [ i ][ j ] = '+' , ans [ i ][ j + 1 ] = '-' ; } for ( int i = n - 1 , cnt = 1 ; cnt <= c ; ++ cnt , i -= 2 ) { for ( int j = 1 ; j <= 2 * a ; j += 2 ) ans [ i ][ j ] = '|' ; } for ( int i = 2 * b + 1 , tmp = 0 , cnt = 1 ; cnt <= b + 1 ; ++ cnt , i -= 2 , tmp += 2 ) { for ( int j = 1 + tmp , cntt = 1 ; cntt <= a ; ++ cntt , j += 2 ) ans [ i ][ j ] = '+' , ans [ i ][ j + 1 ] = '-' ; } for ( int i = 2 * b , tmp = 1 , cnt = 1 ; cnt <= b ; ++ cnt , tmp += 2 , i -= 2 ) { for ( int j = 1 + tmp , cntt = 1 ; cntt <= a ; ++ cntt , j += 2 ) ans [ i ][ j ] = '/' ; } for ( int j = m , cntt = 1 , tmp = 0 ; cntt <= b + 1 ; ++ cntt , j -= 2 , tmp += 2 ) { for ( int i = 1 + tmp , cnt = 1 ; cnt <= c + 1 ; ++ cnt , i += 2 ) { ans [ i ][ j ] = '+' ; if ( cnt <= c ) ans [ i + 1 ][ j ] = '|' ; } } for ( int j = m - 1 , tmp = 1 , cntt = 1 ; cntt <= b ; ++ cntt , tmp += 2 , j -= 2 ) { for ( int i = 1 + tmp , cnt = 1 ; cnt <= c + 1 ; ++ cnt , i += 2 ) ans [ i ][ j ] = '/' ; } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) if ( ! ans [ i ][ j ]) ans [ i ][ j ] = '.' ; ans [ i ][ m + 1 ] = 0 ; printf ( \"%s \\n \" , ans [ i ] + 1 ); } } return 0 ; } Problem M. Walking Plan \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u5f20\u56fe\uff0c\u8be2\u95ee\u4ece u -> v u -> v \u81f3\u5c11\u7ecf\u8fc7 k k \u6761\u8def\u7684\u6700\u5c11\u82b1\u8d39\u3002 \u601d\u8def\uff1a \u56e0\u4e3a k <= 10000 k <= 10000 \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u62c6\u6210 k = x * 100 + y k = x * 100 + y \u7136\u540e\u8003\u8651\u5206\u5757 G[k][i][j] G[k][i][j] \u8868\u793a i -> j i -> j \u81f3\u5c11\u7ecf\u8fc7 k k \u6761\u8def\u3002 dp[k][i][j] dp[k][i][j] \u8868\u793a i -> j i -> j \u81f3\u5c11\u7ecf\u8fc7 k \\cdot 100 k \\cdot 100 \u6761\u8def\u3002 \u7136\u540e\u67e5\u8be2\u7684\u65f6\u5019\u679a\u4e3e\u4e2d\u95f4\u70b9\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 210 #define INFLL 0x3f3f3f3f3f3f3f3f #define ll long long int t , n , m , q ; ll G [ N ][ 55 ][ 55 ], dp [ N ][ 55 ][ 55 ]; inline void Init () { memset ( G , 0x3f , sizeof G ); memset ( dp , 0x3f , sizeof dp ); } inline void Floyd () { for ( int l = 2 ; l <= 200 ; ++ l ) for ( int k = 1 ; k <= n ; ++ k ) for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) G [ l ][ i ][ j ] = min ( G [ l ][ i ][ j ], G [ l - 1 ][ i ][ k ] + G [ 1 ][ k ][ j ]); for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) for ( int l = 199 ; l >= 0 ; -- l ) G [ l ][ i ][ j ] = min ( G [ l ][ i ][ j ], G [ l + 1 ][ i ][ j ]); // at least K roads; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ 1 ][ i ][ j ] = G [ 100 ][ i ][ j ]; for ( int l = 2 ; l <= 100 ; ++ l ) for ( int k = 1 ; k <= n ; ++ k ) for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ l ][ i ][ j ] = min ( dp [ l ][ i ][ j ], dp [ l - 1 ][ i ][ k ] + dp [ 1 ][ k ][ j ]); } inline void Run () { scanf ( \"%d\" , & t ); while ( Init (), t -- ) { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 , u , v , w ; i <= m ; ++ i ) { scanf ( \"%d%d%d\" , & u , & v , & w ); G [ 1 ][ u ][ v ] = min ( G [ 1 ][ u ][ v ], ( ll ) w ); } Floyd (); scanf ( \"%d\" , & q ); for ( int i = 1 , u , v , k ; i <= q ; ++ i ) { scanf ( \"%d%d%d\" , & u , & v , & k ); int unit = floor ( k * 1.0 / 100 ), remind = k - unit * 100 ; ll ans = INFLL ; if ( k <= 100 ) ans = G [ k ][ u ][ v ]; else { for ( int j = 1 ; j <= n ; ++ j ) ans = min ( ans , dp [ unit ][ u ][ j ] + G [ remind ][ j ][ v ]); } if ( k > 100 && remind == 0 ) ans = min ( ans , dp [ unit ][ u ][ v ]); printf ( \"%lld \\n \" , ans >= INFLL ? -1 : ans ); } } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; }","title":"2018 Multi-University Training Contest 3"},{"location":"trainings/2018-Multi-University-Trainings/Contest-3/#problem-a-ascending-rating","text":"\u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u6570\uff0c\u7ed9\u51fa\u533a\u95f4\u957f\u5ea6 m m \u3002\u5bf9\u4e8e\u6bcf\u4e2a\u533a\u95f4\uff0c\u521d\u59cb\u503c\u7684 max max \u4e3a 0 0 \uff0c cnt cnt \u4e3a 0 0 . \u9047\u5230\u4e00\u4e2a a[i] > ans a[i] > ans , \u66f4\u65b0 ans ans \u5e76\u4e14 cnt++ cnt++ \u3002 \u8ba1\u7b97 \\begin{eqnarray*} A &=& \\sum_{i = 1}^{i = n - m +1} (max \\oplus i) \\\\ B &=& \\sum_{i = 1}^{i = n - m +1} (cnt \\oplus i) \\end{eqnarray*} \\begin{eqnarray*} A &=& \\sum_{i = 1}^{i = n - m +1} (max \\oplus i) \\\\ B &=& \\sum_{i = 1}^{i = n - m +1} (cnt \\oplus i) \\end{eqnarray*} \u601d\u8def\uff1a \u5355\u8c03\u961f\u5217\uff0c\u5012\u7740\u626b\u4e00\u904d\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u533a\u95f4\u7684 cnt cnt \u5c31\u662f\u961f\u5217\u7684\u957f\u5ea6\uff0c\u626b\u4e00\u904d\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; const int maxn = 1e7 + 10 ; typedef long long ll ; int t ; int n , m , k ; ll p , q , r , mod ; ll arr [ maxn ]; ll brr [ maxn ]; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d %d %lld %lld %lld %lld\" , & n , & m , & k , & p , & q , & r , & mod ); for ( int i = 1 ; i <= n ; ++ i ) { if ( i <= k ) scanf ( \"%lld\" , arr + i ); else arr [ i ] = ( p * arr [ i - 1 ] + q * i + r ) % mod ; } ll A = 0 , B = 0 ; int head = 0 , tail = -1 ; for ( int i = n ; i > ( n - m + 1 ); -- i ) { while ( head <= tail && arr [ i ] >= arr [ brr [ tail ]]) tail -- ; brr [ ++ tail ] = i ; } for ( int i = n - m + 1 ; i >= 1 ; -- i ) { while ( head <= tail && arr [ i ] >= arr [ brr [ tail ]]) tail -- ; brr [ ++ tail ] = i ; while ( brr [ head ] - i >= m ) head ++ ; A += arr [ brr [ head ]] ^ i ; B += ( tail - head + 1 ) ^ i ; } printf ( \"%lld %lld \\n \" , A , B ); } return 0 ; }","title":"Problem A. Ascending Rating"},{"location":"trainings/2018-Multi-University-Trainings/Contest-3/#problem-b-cut-the-string","text":"\u7559\u5751\u3002","title":"Problem B. Cut The String"},{"location":"trainings/2018-Multi-University-Trainings/Contest-3/#problem-c-dynamic-graph-matching","text":"\u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u70b9\u3002 \u4e24\u79cd\u64cd\u4f5c\uff0c\u4e00\u79cd\u662f\u52a0\u8fb9\uff0c\u4e00\u79cd\u662f\u51cf\u8fb9\uff0c\u6bcf\u6b21\u52a0\u4e00\u6761\u6216\u8005\u51cf\u4e00\u6761\u3002 \u6bcf\u6b21\u64cd\u4f5c\u540e\u8f93\u51fa 1, 2, \\cdots, \\frac{n}{2} 1, 2, \\cdots, \\frac{n}{2} \u8868\u793a\u5bf9\u5e94\u7684\u6570\u91cf\u7684\u8fb9\u3002 \u95ee\u6709\u51e0\u79cd\u53d6\u6cd5\uff0c\u5e76\u4e14\u4efb\u610f\u4e24\u4e2a\u8fb9\u4e0d\u80fd\u76f8\u90bb\u3002 \u601d\u8def\uff1a \u6bcf\u52a0\u4e00\u6761\u8fb9\uff0c\u90fd\u53ef\u4ee5\u8f6c\u79fb\u72b6\u6001 \u6bd4\u5982\u8bf4 110100 \u5230 111110 \u5c31\u662f dp[111110] += dp[110100] \u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int maxn = 1 << 10 ; const int MOD = 1e9 + 7 ; int t , n , m ; ll dp [ maxn ]; ll ans [ 12 ]; inline int cal ( int x ) { int cnt = 0 ; while ( x ) { if ( x & 1 ) cnt ++ ; x >>= 1 ; } return cnt ; } int main () { scanf ( \"%d\" , & t ); while ( t -- ) { memset ( ans , 0 , sizeof ans ); memset ( dp , 0 , sizeof dp ); dp [ 0 ] = 1 ; scanf ( \"%d %d\" , & n , & m ); while ( m -- ) { char op [ 10 ]; int u , v ; scanf ( \"%s %d %d\" , op , & u , & v ); -- u , -- v ; for ( int s = 0 ; s < ( 1 << n ); ++ s ) { if (( s & ( 1 << u )) || ( s & ( 1 << v ))) continue ; int S = s | ( 1 << u ); S |= ( 1 << v ); if ( op [ 0 ] == '+' ) { dp [ S ] = ( dp [ S ] + dp [ s ]) % MOD ; ans [ cal ( S )] = ( ans [ cal ( S )] + dp [ s ]) % MOD ; } else if ( op [ 0 ] == '-' ) { dp [ S ] = ( dp [ S ] - dp [ s ] + MOD ) % MOD ; ans [ cal ( S )] = ( ans [ cal ( S )] - dp [ s ] + MOD ) % MOD ; } } for ( int i = 2 ; i <= n ; i += 2 ) { printf ( \"%lld%c\" , ans [ i ], \" \\n \" [ i == n ]); } } } return 0 ; }","title":"Problem C. Dynamic Graph Matching"},{"location":"trainings/2018-Multi-University-Trainings/Contest-3/#problem-d-euler-function","text":"\u6253\u8868\u627e\u89c4\u5f8b\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 inline int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ); } inline void Init () { for ( int i = 1 ; i <= 100 ; ++ i ) { int res = 0 ; for ( int j = 1 ; j < i ; ++ j ) res += ( gcd ( i , j ) == 1 ); printf ( \"%d %d \\n \" , i , res ); } } int t , n ; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); if ( n == 1 ) puts ( \"5\" ); else printf ( \"%d \\n \" , n + 5 ); } return 0 ; }","title":"Problem D. Euler Function"},{"location":"trainings/2018-Multi-University-Trainings/Contest-3/#problem-e-find-the-submatrix","text":"\u7559\u5751\u3002","title":"Problem E. Find The Submatrix"},{"location":"trainings/2018-Multi-University-Trainings/Contest-3/#problem-f-grab-the-tree","text":"\u9898\u610f\uff1a \u4e00\u68f5\u6811\uff0c\u6bcf\u4e2a\u70b9\u6709\u70b9\u6743\uff0c\u5c0f Q \u53ef\u4ee5\u9009\u62e9\u82e5\u5e72\u4e2a\u70b9\uff0c\u5e76\u4e14\u4efb\u610f\u4e24\u4e2a\u70b9\u4e4b\u95f4\u6ca1\u6709\u8fb9\uff0c\u5c0f T \u5c31\u662f\u5269\u4e0b\u7684\u6240\u6709\u70b9\uff0c\u7136\u540e\u4e24\u4e2a\u4eba\u7684\u503c\u5c31\u662f\u62e5\u6709\u7684\u70b9\u5f02\u6216\u8d77\u6765\uff0c\u6c42\u5c0f Q \u8d62\u8fd8\u662f\u8f93\u8fd8\u662f\u5e73\u5c40\u3002 \u601d\u8def\uff1a \u663e\u7136\uff0c\u53ea\u6709\u8d62\u6216\u8005\u5e73\u5c40\u7684\u60c5\u51b5\uff0c\u53ea\u8981\u8003\u8651\u662f\u5426\u6709\u5e73\u5c40\u60c5\u51b5\u5c31\u53ef\u4ee5\uff0c\u5f53\u6240\u6709\u70b9\u5f02\u6216\u8d77\u6765\u4e3a 0 0 \u4fbf\u662f\u5e73\u5c40\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 int t , n ; int arr [ N ]; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , arr + i ); res ^= arr [ i ]; } for ( int i = 1 , u , v ; i < n ; ++ i ) scanf ( \"%d%d\" , & u , & v ); if ( res == 0 ) { puts ( \"D\" ); continue ; } puts ( \"Q\" ); } return 0 ; }","title":"Problem F. Grab The Tree"},{"location":"trainings/2018-Multi-University-Trainings/Contest-3/#problem-g-interstellar-travel","text":"\u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u70b9\u3002 \u8981\u4ece i -> j i -> j \u5f53\u4e14\u4ec5\u5f53 x_i < x_j x_i < x_j \u82b1\u8d39\u4e3a x_i \\cdot y_j - x_j \\cdot y_i x_i \\cdot y_j - x_j \\cdot y_i \u3002 \u6c42\u4ece 1 -> n 1 -> n \u7684\u6743\u503c\u6700\u5c0f\u3002 \u5982\u679c\u591a\u89e3\u8f93\u51fa\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u89e3\u3002 \u601d\u8def\uff1a \u53ef\u4ee5\u53d1\u73b0\u6743\u503c\u5c31\u662f\u53c9\u79ef\u3002 \u6c42\u4e2a\u51f8\u5305\u3002 \u7136\u540e\u8003\u8651\u5728\u4e00\u6761\u7ebf\u4e0a\u7684\u60c5\u51b5\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 200010 const double eps = 1e-8 ; inline int sgn ( double x ) { if ( fabs ( x ) < eps ) return 0 ; if ( x < 0 ) return -1 ; else return 1 ; } struct Point { double x , y ; int id ; inline Point () {} inline Point ( double x , double y ) : x ( x ), y ( y ) {} inline void scan ( int _id ) { id = _id ; scanf ( \"%lf%lf\" , & x , & y ); } inline bool operator == ( const Point & r ) const { return sgn ( x - r . x ) == 0 && sgn ( y - r . y ) == 0 ; } inline bool operator < ( const Point & r ) const { return x < r . x || x == r . x && y < r . y || x == r . x && y == r . y && id < r . id ; } inline Point operator + ( const Point & r ) const { return Point ( x + r . x , y + r . y ); } inline Point operator - ( const Point & r ) const { return Point ( x - r . x , y - r . y ); } inline double operator ^ ( const Point & r ) const { return x * r . y - y * r . x ; } inline double distance ( const Point & r ) const { return hypot ( x - r . x , y - r . y ); } }; struct Polygon { int n ; Point p [ N ]; struct cmp { Point p ; inline cmp ( const Point & p0 ) { p = p0 ; } inline bool operator ()( const Point & aa , const Point & bb ) { Point a = aa , b = bb ; int d = sgn (( a - p ) ^ ( b - p )); if ( d == 0 ) { return sgn ( a . distance ( p ) - b . distance ( p )) < 0 ; } return d < 0 ; } }; inline void norm () { Point mi = p [ 0 ]; for ( int i = 1 ; i < n ; ++ i ) mi = min ( mi , p [ i ]); sort ( p , p + n , cmp ( mi )); } inline void Graham ( Polygon & convex ) { sort ( p + 1 , p + n - 1 ); int cnt = 1 ; for ( int i = 1 ; i < n ; ++ i ) { if ( ! ( p [ i ] == p [ i - 1 ])) p [ cnt ++ ] = p [ i ]; } n = cnt ; norm (); int & top = convex . n ; top = 0 ; if ( n == 2 ) { top = 2 ; convex . p [ 0 ] = p [ 0 ]; convex . p [ 1 ] = p [ 1 ]; return ; } if ( n == 3 ) { top = 3 ; convex . p [ 0 ] = p [ 0 ]; convex . p [ 1 ] = p [ 1 ]; convex . p [ 2 ] = p [ 2 ]; return ; } convex . p [ 0 ] = p [ 0 ]; convex . p [ 1 ] = p [ 1 ]; top = 2 ; for ( int i = 2 ; i < n ; ++ i ) { while ( top > 1 && sgn (( convex . p [ top - 1 ] - convex . p [ top - 2 ]) ^ ( p [ i ] - convex . p [ top - 2 ])) >= 0 ) { if ( sgn (( convex . p [ top - 1 ] - convex . p [ top - 2 ]) ^ ( p [ i ] - convex . p [ top - 2 ])) == 0 ) { if ( p [ i ]. id < convex . p [ top - 1 ]. id ) -- top ; else break ; } else { -- top ; } } convex . p [ top ++ ] = p [ i ]; } if ( convex . n == 2 && ( convex . p [ 0 ] == convex . p [ 1 ])) -- convex . n ; } } arr , ans ; int t , n ; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); arr . n = n ; // cout << n << endl; for ( int i = 0 ; i < n ; ++ i ) arr . p [ i ]. scan ( i + 1 ); arr . Graham ( ans ); for ( int i = 0 ; i < ans . n ; ++ i ) printf ( \"%d%c\" , ans . p [ i ]. id , \" \\n \" [ i == ans . n - 1 ]); } return 0 ; }","title":"Problem G. Interstellar Travel"},{"location":"trainings/2018-Multi-University-Trainings/Contest-3/#problem-h-monster-hunter","text":"\u7559\u5751\u3002","title":"Problem H. Monster Hunter"},{"location":"trainings/2018-Multi-University-Trainings/Contest-3/#problem-i-random-sequence","text":"\u7559\u5751\u3002","title":"Problem I. Random Sequence"},{"location":"trainings/2018-Multi-University-Trainings/Contest-3/#problem-j-rectangle-radar-scanner","text":"\u7559\u5751\u3002","title":"Problem J. Rectangle Radar Scanner"},{"location":"trainings/2018-Multi-University-Trainings/Contest-3/#problem-k-transport-construction","text":"\u7559\u5751\u3002","title":"Problem K. Transport Construction"},{"location":"trainings/2018-Multi-University-Trainings/Contest-3/#problem-l-visual-cube","text":"\u6309\u9898\u610f\u6a21\u62df\u5373\u53ef\uff0c\u5206\u5757\u89e3\u51b3\u3002 Code #include <bits/stdc++.h> using namespace std ; int t , a , b , c , n , m ; char ans [ 200 ][ 200 ]; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { memset ( ans , 0 , sizeof ans ); scanf ( \"%d%d%d\" , & a , & b , & c ); n = ( b + c ) * 2 + 1 ; m = ( a + b ) * 2 + 1 ; for ( int i = n , cnt = 1 ; cnt <= c ; ++ cnt , i -= 2 ) { for ( int j = 1 ; j <= 2 * a ; j += 2 ) ans [ i ][ j ] = '+' , ans [ i ][ j + 1 ] = '-' ; } for ( int i = n - 1 , cnt = 1 ; cnt <= c ; ++ cnt , i -= 2 ) { for ( int j = 1 ; j <= 2 * a ; j += 2 ) ans [ i ][ j ] = '|' ; } for ( int i = 2 * b + 1 , tmp = 0 , cnt = 1 ; cnt <= b + 1 ; ++ cnt , i -= 2 , tmp += 2 ) { for ( int j = 1 + tmp , cntt = 1 ; cntt <= a ; ++ cntt , j += 2 ) ans [ i ][ j ] = '+' , ans [ i ][ j + 1 ] = '-' ; } for ( int i = 2 * b , tmp = 1 , cnt = 1 ; cnt <= b ; ++ cnt , tmp += 2 , i -= 2 ) { for ( int j = 1 + tmp , cntt = 1 ; cntt <= a ; ++ cntt , j += 2 ) ans [ i ][ j ] = '/' ; } for ( int j = m , cntt = 1 , tmp = 0 ; cntt <= b + 1 ; ++ cntt , j -= 2 , tmp += 2 ) { for ( int i = 1 + tmp , cnt = 1 ; cnt <= c + 1 ; ++ cnt , i += 2 ) { ans [ i ][ j ] = '+' ; if ( cnt <= c ) ans [ i + 1 ][ j ] = '|' ; } } for ( int j = m - 1 , tmp = 1 , cntt = 1 ; cntt <= b ; ++ cntt , tmp += 2 , j -= 2 ) { for ( int i = 1 + tmp , cnt = 1 ; cnt <= c + 1 ; ++ cnt , i += 2 ) ans [ i ][ j ] = '/' ; } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) if ( ! ans [ i ][ j ]) ans [ i ][ j ] = '.' ; ans [ i ][ m + 1 ] = 0 ; printf ( \"%s \\n \" , ans [ i ] + 1 ); } } return 0 ; }","title":"Problem L. Visual Cube"},{"location":"trainings/2018-Multi-University-Trainings/Contest-3/#problem-m-walking-plan","text":"\u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u5f20\u56fe\uff0c\u8be2\u95ee\u4ece u -> v u -> v \u81f3\u5c11\u7ecf\u8fc7 k k \u6761\u8def\u7684\u6700\u5c11\u82b1\u8d39\u3002 \u601d\u8def\uff1a \u56e0\u4e3a k <= 10000 k <= 10000 \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u62c6\u6210 k = x * 100 + y k = x * 100 + y \u7136\u540e\u8003\u8651\u5206\u5757 G[k][i][j] G[k][i][j] \u8868\u793a i -> j i -> j \u81f3\u5c11\u7ecf\u8fc7 k k \u6761\u8def\u3002 dp[k][i][j] dp[k][i][j] \u8868\u793a i -> j i -> j \u81f3\u5c11\u7ecf\u8fc7 k \\cdot 100 k \\cdot 100 \u6761\u8def\u3002 \u7136\u540e\u67e5\u8be2\u7684\u65f6\u5019\u679a\u4e3e\u4e2d\u95f4\u70b9\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 210 #define INFLL 0x3f3f3f3f3f3f3f3f #define ll long long int t , n , m , q ; ll G [ N ][ 55 ][ 55 ], dp [ N ][ 55 ][ 55 ]; inline void Init () { memset ( G , 0x3f , sizeof G ); memset ( dp , 0x3f , sizeof dp ); } inline void Floyd () { for ( int l = 2 ; l <= 200 ; ++ l ) for ( int k = 1 ; k <= n ; ++ k ) for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) G [ l ][ i ][ j ] = min ( G [ l ][ i ][ j ], G [ l - 1 ][ i ][ k ] + G [ 1 ][ k ][ j ]); for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) for ( int l = 199 ; l >= 0 ; -- l ) G [ l ][ i ][ j ] = min ( G [ l ][ i ][ j ], G [ l + 1 ][ i ][ j ]); // at least K roads; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ 1 ][ i ][ j ] = G [ 100 ][ i ][ j ]; for ( int l = 2 ; l <= 100 ; ++ l ) for ( int k = 1 ; k <= n ; ++ k ) for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ l ][ i ][ j ] = min ( dp [ l ][ i ][ j ], dp [ l - 1 ][ i ][ k ] + dp [ 1 ][ k ][ j ]); } inline void Run () { scanf ( \"%d\" , & t ); while ( Init (), t -- ) { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 , u , v , w ; i <= m ; ++ i ) { scanf ( \"%d%d%d\" , & u , & v , & w ); G [ 1 ][ u ][ v ] = min ( G [ 1 ][ u ][ v ], ( ll ) w ); } Floyd (); scanf ( \"%d\" , & q ); for ( int i = 1 , u , v , k ; i <= q ; ++ i ) { scanf ( \"%d%d%d\" , & u , & v , & k ); int unit = floor ( k * 1.0 / 100 ), remind = k - unit * 100 ; ll ans = INFLL ; if ( k <= 100 ) ans = G [ k ][ u ][ v ]; else { for ( int j = 1 ; j <= n ; ++ j ) ans = min ( ans , dp [ unit ][ u ][ j ] + G [ remind ][ j ][ v ]); } if ( k > 100 && remind == 0 ) ans = min ( ans , dp [ unit ][ u ][ v ]); printf ( \"%lld \\n \" , ans >= INFLL ? -1 : ans ); } } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; }","title":"Problem M. Walking Plan"},{"location":"trainings/2018-Multi-University-Trainings/Contest-4/","text":"2018 Multi-University Training Contest 4 Contents Problem A. Integers Exhibition Problem B. Harvest of Apples Problem C. Problems on a Tree Problem D. Nothing is Impossible Problem E. Matrix from Arrays Problem F. Travel Through Time Problem G. Depth-First Search Problem H. Eat Cards, Have Fun Problem I. Delightful Formulas Problem J. Let Sudoku Rotate Problem K. Expression in Memories Problem L. Graph Theory Homework Problem A. Integers Exhibition \u7559\u5751\u3002 Problem B. Harvest of Apples \u9898\u610f\uff1a \u8ba1\u7b97 \\sum_{i = 0}^{i = m}C(n, i) \\sum_{i = 0}^{i = m}C(n, i) \u3002 \u601d\u8def\uff1a \u7531 sum_{i = 0}^{i = m}C(n,i) sum_{i = 0}^{i = m}C(n,i) \u53ef\u4ee5\u5f97\u5230 sum_{i = 0}^{i = m + 1}C(n,i) sum_{i = 0}^{i = m + 1}C(n,i) \u4ee5\u53ca sum_{i = 0}^{i = m}C(n + 1,i) sum_{i = 0}^{i = m}C(n + 1,i) \u7136\u540e\u7528\u83ab\u5bf9\u7b97\u6cd5\u6c42\u89e3\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll MOD = 1e9 + 7 ; const int maxn = 1e5 + 10 ; int unit ; ll inv [ maxn ]; ll invfac [ maxn ]; ll fac [ maxn ]; ll ans [ maxn ]; int n , m ; struct node { int l , r , id ; inline node () {} inline node ( int l , int r , int id ) : l ( l ), r ( r ), id ( id ) {} inline bool operator < ( const node & b ) const { if ( l / unit != b . l / unit ) return l / unit < b . l / unit ; else return r < b . r ; } } arr [ maxn ]; inline void Init () { fac [ 0 ] = invfac [ 0 ] = 1 ; fac [ 1 ] = inv [ 1 ] = invfac [ 1 ] = 1 ; for ( int i = 2 ; i < maxn ; ++ i ) { fac [ i ] = fac [ i - 1 ] * i % MOD ; inv [ i ] = inv [ MOD % i ] * ( MOD - MOD / i ) % MOD ; invfac [ i ] = invfac [ i - 1 ] * inv [ i ] % MOD ; } } inline ll cal ( int a , int b ) { ll res = fac [ a ] * invfac [ b ] % MOD * invfac [ a - b ] % MOD ; return res ; } inline void work () { ll tmp = 0 ; for ( int i = 0 ; i <= arr [ 1 ]. r ; ++ i ) { tmp = ( tmp + cal ( arr [ 1 ]. l , i )) % MOD ; } ans [ arr [ 1 ]. id ] = tmp ; int L = arr [ 1 ]. l , R = arr [ 1 ]. r ; for ( int i = 2 ; i <= n ; ++ i ) { while ( L < arr [ i ]. l ) { tmp = ( tmp * 2 % MOD - cal ( L ++ , R ) + MOD ) % MOD ; } while ( L > arr [ i ]. l ) { tmp = ( tmp + cal ( -- L , R ) + MOD ) % MOD * inv [ 2 ] % MOD ; } while ( R < arr [ i ]. r ) { tmp = ( tmp + cal ( L , ++ R )) % MOD ; } while ( R > arr [ i ]. r ) { tmp = ( tmp - cal ( L , R -- ) + MOD ) % MOD ; } ans [ arr [ i ]. id ] = tmp ; } } int main () { Init (); scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d %d\" , & arr [ i ]. l , & arr [ i ]. r ); arr [ i ]. id = i ; } unit = ( int ) sqrt ( n ); sort ( arr + 1 , arr + 1 + n ); work (); for ( int i = 1 ; i <= n ; ++ i ) { printf ( \"%lld \\n \" , ans [ i ]); } return 0 ; } Problem C. Problems on a Tree \u7559\u5751\u3002 Problem D. Nothing is Impossible \u9898\u610f\uff1a \u7ed9\u51fa n n \u9053\u9898\u76ee\uff0c\u6bcf\u9053\u9898\u76ee\u6709 a_i a_i \u79cd\u6b63\u786e\u9009\u62e9\uff0c b_i b_i \u79cd\u9519\u8bef\u9009\u62e9\u3002 \u4e00\u5171\u6709 m m \u4e2a\u4eba\uff0c\u6240\u6709\u4eba\u90fd\u8981\u9009\u62e9\u4e00\u4e2a\u9898\u76ee\u96c6\u5408\u53bb\u505a\uff0c\u76f8\u5f53\u4e8e\u53bb\u8bd5\u7b54\u6848\uff0c\u95ee\u6700\u591a\u80fd\u8bd5\u51fa\u591a\u5c11\u9053\u9898\u76ee\u7b54\u6848\u3002 \u601d\u8def\uff1a \u6392\u5e8f\uff0c\u524d\u7f00\u79ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 110 #define ll long long struct node { int a , b , sum ; inline void scan () { scanf ( \"%d%d\" , & a , & b ); sum = a + b ; } inline bool operator < ( const node & r ) const { return sum < r . sum ; } } arr [ N ]; int t , n , m ; ll sum ; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; ++ i ) arr [ i ]. scan (); sort ( arr + 1 , arr + 1 + n ); int ans = 0 ; sum = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { sum *= arr [ i ]. sum ; if ( sum > m ) break ; ans = i ; } printf ( \"%d \\n \" , ans ); } return 0 ; } Problem E. Matrix from Arrays \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u79cd\u6784\u9020\u4e8c\u7ef4\u6570\u7ec4\u7684\u6784\u9020\u65b9\u5f0f\uff0c\u7136\u540e\u7ed9\u51fa\u4e00\u4e2a\u5de6\u4e0a\u89d2\uff0c\u4e00\u4e2a\u53f3\u4e0b\u89d2\uff0c\u6c42\u8fd9\u4e2a\u77e9\u5f62\u5185\u7684\u6570\u548c\u3002 \u601d\u8def\uff1a \u6253\u8868\u627e\u89c4\u5f8b\u53d1\u73b0\uff0c\u5927\u77e9\u9635\u662f\u7531\u82e5\u5e72\u4e2a 2L \\cdot 2L 2L \\cdot 2L \u4e2a\u5c0f\u77e9\u9635\u6784\u6210\u7684\uff0c\u90a3\u4e48\u628a\u7ed9\u51fa\u7684\u77e9\u9635\u5206\u6210\u56db\u5757\uff0c\u6574\u5757\u6574\u5757\u7684\u5904\u7406\uff0c\u8fb9\u8fb9\u89d2\u89d2\u7684\u5904\u7406\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 110 typedef long long ll ; int n ; int x [ 2 ], y [ 2 ]; ll arr [ N ]; ll G [ N ][ N ]; inline ll cal ( int x , int y ) { if ( x < 0 || y < 0 ) return 0l l ; ll res = G [ n - 1 ][ n - 1 ] * ( x / n ) * ( y / n ) + G [ n - 1 ][ y % n ] * ( x / n ) + G [ x % n ][ n - 1 ] * ( y / n ) + G [ x % n ][ y % n ]; return res ; } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; ++ i ) { scanf ( \"%lld\" , arr + i ); } for ( int i = 0 , cnt = 0 ; i < ( n << 2 ); ++ i ) { for ( int j = 0 ; j <= i ; ++ j ) { G [ j ][ i - j ] = arr [ cnt ]; cnt = ( cnt + 1 ) % n ; } } n <<= 1 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { G [ i ][ j ] += ( i ? G [ i - 1 ][ j ] : 0 ); G [ i ][ j ] += ( j ? G [ i ][ j - 1 ] : 0 ); G [ i ][ j ] -= (( i && j ) ? G [ i - 1 ][ j - 1 ] : 0 ); } } int q ; scanf ( \"%d\" , & q ); while ( q -- ) { scanf ( \"%d %d %d %d\" , & x [ 0 ], & y [ 0 ], & x [ 1 ], & y [ 1 ]); ll ans = cal ( x [ 1 ], y [ 1 ]) - cal ( x [ 0 ] - 1 , y [ 1 ]) - cal ( x [ 1 ], y [ 0 ] - 1 ) + cal ( x [ 0 ] - 1 , y [ 0 ] - 1 ); printf ( \"%lld \\n \" , ans ); } } return 0 ; } Code #include <bits/stdc++.h> using namespace std ; #define N 1100 #define ll long long int t , n , q , x [ 2 ], y [ 2 ]; ll arr [ N ]; ll G [ N ][ N ]; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%lld\" , arr + i ); memset ( G , 0 , sizeof G ); for ( int i = 0 , cnt = 0 ; i <= ( n << 2 ); ++ i ) { for ( int j = 0 ; j <= i ; ++ j ) { G [ j ][ i - j ] = arr [ cnt + 1 ]; cnt = ( cnt + 1 ) % n ; } } n <<= 1 ; ll base = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) base += G [ i ][ j ]; scanf ( \"%d\" , & q ); while ( q -- ) { scanf ( \"%d%d%d%d\" , & x [ 0 ], & y [ 0 ], & x [ 1 ], & y [ 1 ]); ll ans = 0 , tmp ; // compute Big ll xl = ( x [ 1 ] - x [ 0 ] + 1 ) / n , yl = ( y [ 1 ] - y [ 0 ] + 1 ) / n ; ans += ( base * xl * yl ); // compute lower_left corner tmp = 0 ; for ( int i = x [ 0 ] + xl * n ; i <= x [ 1 ]; ++ i ) { for ( int j = y [ 0 ], cnt = 1 ; cnt <= n ; ++ cnt , ++ j ) tmp += G [ i % n ][ j % n ]; } // compute upper_right corner ans += tmp * yl ; tmp = 0 ; for ( int i = x [ 0 ], cnt = 1 ; cnt <= n ; ++ cnt , ++ i ) { for ( int j = y [ 0 ] + yl * n ; j <= y [ 1 ]; ++ j ) tmp += G [ i % n ][ j % n ]; } // compute lower_right corner ans += tmp * xl ; tmp = 0 ; for ( int i = x [ 0 ] + xl * n ; i <= x [ 1 ]; ++ i ) { for ( int j = y [ 0 ] + yl * n ; j <= y [ 1 ]; ++ j ) ans += G [ i % n ][ j % n ]; } printf ( \"%lld \\n \" , ans ); } } return 0 ; } Problem F. Travel Through Time \u7559\u5751\u3002 Problem G. Depth-First Search \u7559\u5751\u3002 Problem H. Eat Cards, Have Fun \u7559\u5751\u3002 Problem I. Delightful Formulas \u7559\u5751\u3002 Problem J. Let Sudoku Rotate \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a 16 \\times 16 16 \\times 16 \u7684\u6570\u72ec\uff0c\u6709\u4e00\u4e9b 4 \\times 4 4 \\times 4 \u7684\u77e9\u9635\u88ab\u9006\u65f6\u9488\u65cb\u8f6c\u8fc7\uff0c\u7136\u540e\u6c42\u6062\u590d\u6700\u5c11\u9700\u8981\u65cb\u8f6c\u591a\u5c11\u6b21\u3002 \u601d\u8def\uff1a \u7206\u641c\uff0c\u4e24\u6761\u526a\u679d\uff0c\u4e00\u4e2a\u662f\u5224\u65ad\u662f\u5426\u6709\u51b2\u7a81\uff0c\u4e00\u4e2a\u662f\u5224\u65ad\u5f53\u524d\u6b65\u6570\u662f\u5426\u6bd4\u5df2\u6709\u7b54\u6848\u5927\u3002 Code #include <bits/stdc++.h> using namespace std ; const int maxn = 1e2 + 10 ; int ans ; bool vis [ 20 ]; char s [ 20 ]; int G [ maxn ][ maxn ]; inline bool judge ( int x , int y ) { for ( int i = x * 4 - 3 ; i <= x * 4 ; ++ i ) { memset ( vis , false , sizeof vis ); for ( int j = 1 ; j <= y * 4 ; ++ j ) { if ( vis [ G [ i ][ j ]]) return false ; vis [ G [ i ][ j ]] = true ; } } for ( int i = y * 4 - 3 ; i <= y * 4 ; ++ i ) { memset ( vis , false , sizeof vis ); for ( int j = 1 ; j <= x * 4 ; ++ j ) { if ( vis [ G [ j ][ i ]]) return false ; vis [ G [ j ][ i ]] = true ; } } return true ; } inline void fun ( int x , int y ) { int tmp [ 10 ][ 10 ]; for ( int i = 1 ; i <= 4 ; ++ i ) { for ( int j = 1 ; j <= 4 ; ++ j ) { tmp [ j ][ 4 - i + 1 ] = G [( x - 1 ) * 4 + i ][( y - 1 ) * 4 + j ]; } } for ( int i = 1 ; i <= 4 ; ++ i ) { for ( int j = 1 ; j <= 4 ; ++ j ) { G [( x - 1 ) * 4 + i ][( y - 1 ) * 4 + j ] = tmp [ i ][ j ]; } } } inline void DFS ( int x , int y , int res ) { if ( res >= ans ) return ; if ( y > 4 ) { DFS ( x + 1 , 1 , res ); return ; } if ( x == 5 ) { ans = min ( ans , res ); return ; } for ( int i = 0 ; i < 4 ; ++ i ) { if ( i ) { fun ( x , y ); /* if(x == 3 && y == 1 && i == 1) { for(int i = x * 4 - 3; i <= x * 4; ++i) { for(int j = y * 4 - 3; j <= y * 4; ++j) { printf(\"%d%c\", G[i][j], \" \\n\"[j == y * 4]); } } }*/ } if ( judge ( x , y )) { DFS ( x , y + 1 , res + i ); } } fun ( x , y ); } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { ans = 1 << 16 ; for ( int i = 1 ; i <= 16 ; ++ i ) { scanf ( \"%s\" , s + 1 ); for ( int j = 1 ; j <= 16 ; ++ j ) { if ( s [ j ] >= '0' && s [ j ] <= '9' ) { G [ i ][ j ] = s [ j ] - '0' ; } else if ( s [ j ] >= 'A' && s [ j ] <= 'F' ) { G [ i ][ j ] = ( s [ j ] - 'A' ) + 10 ; } } } // fun(1, 1); DFS ( 1 , 1 , 0 ); printf ( \"%d \\n \" , ans ); } return 0 ; } Problem K. Expression in Memories \u6309\u9898\u610f\u6a21\u62df\u5373\u53ef Code #include <bits/stdc++.h> using namespace std ; #define N 100010 int t ; char s [ N ]; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%s\" , s ); bool flag = true ; int len = strlen ( s ); for ( int i = 0 ; i < len ; ++ i ) { if ( s [ i ] == '*' || s [ i ] == '+' ) { if ( i == 0 || i == len - 1 ) { flag = false ; break ; } else if ( s [ i + 1 ] == '*' || s [ i + 1 ] == '+' ) { flag = false ; break ; } } else if ( s [ i ] == '0' ) { if ( i == 0 || s [ i - 1 ] == '*' || s [ i - 1 ] == '+' ) { if ( i + 1 < len && s [ i + 1 ] >= '0' && s [ i + 1 ] <= '9' ) { flag = false ; break ; } else if ( s [ i + 1 ] == '?' ) s [ i + 1 ] = '+' ; } } else if ( s [ i ] == '?' ) { s [ i ] = '1' ; } } if ( flag ) { printf ( \"%s \\n \" , s ); } else { printf ( \"IMPOSSIBLE \\n \" ); } } return 0 ; } Problem L. Graph Theory Homework \u6c34\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 int t , n ; int arr [ N ]; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , arr + i ); int ans = ( int ) floor ( sqrt ( abs ( arr [ 1 ] - arr [ n ]))); printf ( \"%d \\n \" , ans ); } return 0 ; }","title":"2018 Multi-University Training Contest 4"},{"location":"trainings/2018-Multi-University-Trainings/Contest-4/#problem-a-integers-exhibition","text":"\u7559\u5751\u3002","title":"Problem A. Integers Exhibition"},{"location":"trainings/2018-Multi-University-Trainings/Contest-4/#problem-b-harvest-of-apples","text":"\u9898\u610f\uff1a \u8ba1\u7b97 \\sum_{i = 0}^{i = m}C(n, i) \\sum_{i = 0}^{i = m}C(n, i) \u3002 \u601d\u8def\uff1a \u7531 sum_{i = 0}^{i = m}C(n,i) sum_{i = 0}^{i = m}C(n,i) \u53ef\u4ee5\u5f97\u5230 sum_{i = 0}^{i = m + 1}C(n,i) sum_{i = 0}^{i = m + 1}C(n,i) \u4ee5\u53ca sum_{i = 0}^{i = m}C(n + 1,i) sum_{i = 0}^{i = m}C(n + 1,i) \u7136\u540e\u7528\u83ab\u5bf9\u7b97\u6cd5\u6c42\u89e3\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const ll MOD = 1e9 + 7 ; const int maxn = 1e5 + 10 ; int unit ; ll inv [ maxn ]; ll invfac [ maxn ]; ll fac [ maxn ]; ll ans [ maxn ]; int n , m ; struct node { int l , r , id ; inline node () {} inline node ( int l , int r , int id ) : l ( l ), r ( r ), id ( id ) {} inline bool operator < ( const node & b ) const { if ( l / unit != b . l / unit ) return l / unit < b . l / unit ; else return r < b . r ; } } arr [ maxn ]; inline void Init () { fac [ 0 ] = invfac [ 0 ] = 1 ; fac [ 1 ] = inv [ 1 ] = invfac [ 1 ] = 1 ; for ( int i = 2 ; i < maxn ; ++ i ) { fac [ i ] = fac [ i - 1 ] * i % MOD ; inv [ i ] = inv [ MOD % i ] * ( MOD - MOD / i ) % MOD ; invfac [ i ] = invfac [ i - 1 ] * inv [ i ] % MOD ; } } inline ll cal ( int a , int b ) { ll res = fac [ a ] * invfac [ b ] % MOD * invfac [ a - b ] % MOD ; return res ; } inline void work () { ll tmp = 0 ; for ( int i = 0 ; i <= arr [ 1 ]. r ; ++ i ) { tmp = ( tmp + cal ( arr [ 1 ]. l , i )) % MOD ; } ans [ arr [ 1 ]. id ] = tmp ; int L = arr [ 1 ]. l , R = arr [ 1 ]. r ; for ( int i = 2 ; i <= n ; ++ i ) { while ( L < arr [ i ]. l ) { tmp = ( tmp * 2 % MOD - cal ( L ++ , R ) + MOD ) % MOD ; } while ( L > arr [ i ]. l ) { tmp = ( tmp + cal ( -- L , R ) + MOD ) % MOD * inv [ 2 ] % MOD ; } while ( R < arr [ i ]. r ) { tmp = ( tmp + cal ( L , ++ R )) % MOD ; } while ( R > arr [ i ]. r ) { tmp = ( tmp - cal ( L , R -- ) + MOD ) % MOD ; } ans [ arr [ i ]. id ] = tmp ; } } int main () { Init (); scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d %d\" , & arr [ i ]. l , & arr [ i ]. r ); arr [ i ]. id = i ; } unit = ( int ) sqrt ( n ); sort ( arr + 1 , arr + 1 + n ); work (); for ( int i = 1 ; i <= n ; ++ i ) { printf ( \"%lld \\n \" , ans [ i ]); } return 0 ; }","title":"Problem B. Harvest of Apples"},{"location":"trainings/2018-Multi-University-Trainings/Contest-4/#problem-c-problems-on-a-tree","text":"\u7559\u5751\u3002","title":"Problem C. Problems on a Tree"},{"location":"trainings/2018-Multi-University-Trainings/Contest-4/#problem-d-nothing-is-impossible","text":"\u9898\u610f\uff1a \u7ed9\u51fa n n \u9053\u9898\u76ee\uff0c\u6bcf\u9053\u9898\u76ee\u6709 a_i a_i \u79cd\u6b63\u786e\u9009\u62e9\uff0c b_i b_i \u79cd\u9519\u8bef\u9009\u62e9\u3002 \u4e00\u5171\u6709 m m \u4e2a\u4eba\uff0c\u6240\u6709\u4eba\u90fd\u8981\u9009\u62e9\u4e00\u4e2a\u9898\u76ee\u96c6\u5408\u53bb\u505a\uff0c\u76f8\u5f53\u4e8e\u53bb\u8bd5\u7b54\u6848\uff0c\u95ee\u6700\u591a\u80fd\u8bd5\u51fa\u591a\u5c11\u9053\u9898\u76ee\u7b54\u6848\u3002 \u601d\u8def\uff1a \u6392\u5e8f\uff0c\u524d\u7f00\u79ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 110 #define ll long long struct node { int a , b , sum ; inline void scan () { scanf ( \"%d%d\" , & a , & b ); sum = a + b ; } inline bool operator < ( const node & r ) const { return sum < r . sum ; } } arr [ N ]; int t , n , m ; ll sum ; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; ++ i ) arr [ i ]. scan (); sort ( arr + 1 , arr + 1 + n ); int ans = 0 ; sum = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { sum *= arr [ i ]. sum ; if ( sum > m ) break ; ans = i ; } printf ( \"%d \\n \" , ans ); } return 0 ; }","title":"Problem D. Nothing is Impossible"},{"location":"trainings/2018-Multi-University-Trainings/Contest-4/#problem-e-matrix-from-arrays","text":"\u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u79cd\u6784\u9020\u4e8c\u7ef4\u6570\u7ec4\u7684\u6784\u9020\u65b9\u5f0f\uff0c\u7136\u540e\u7ed9\u51fa\u4e00\u4e2a\u5de6\u4e0a\u89d2\uff0c\u4e00\u4e2a\u53f3\u4e0b\u89d2\uff0c\u6c42\u8fd9\u4e2a\u77e9\u5f62\u5185\u7684\u6570\u548c\u3002 \u601d\u8def\uff1a \u6253\u8868\u627e\u89c4\u5f8b\u53d1\u73b0\uff0c\u5927\u77e9\u9635\u662f\u7531\u82e5\u5e72\u4e2a 2L \\cdot 2L 2L \\cdot 2L \u4e2a\u5c0f\u77e9\u9635\u6784\u6210\u7684\uff0c\u90a3\u4e48\u628a\u7ed9\u51fa\u7684\u77e9\u9635\u5206\u6210\u56db\u5757\uff0c\u6574\u5757\u6574\u5757\u7684\u5904\u7406\uff0c\u8fb9\u8fb9\u89d2\u89d2\u7684\u5904\u7406\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 110 typedef long long ll ; int n ; int x [ 2 ], y [ 2 ]; ll arr [ N ]; ll G [ N ][ N ]; inline ll cal ( int x , int y ) { if ( x < 0 || y < 0 ) return 0l l ; ll res = G [ n - 1 ][ n - 1 ] * ( x / n ) * ( y / n ) + G [ n - 1 ][ y % n ] * ( x / n ) + G [ x % n ][ n - 1 ] * ( y / n ) + G [ x % n ][ y % n ]; return res ; } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); for ( int i = 0 ; i < n ; ++ i ) { scanf ( \"%lld\" , arr + i ); } for ( int i = 0 , cnt = 0 ; i < ( n << 2 ); ++ i ) { for ( int j = 0 ; j <= i ; ++ j ) { G [ j ][ i - j ] = arr [ cnt ]; cnt = ( cnt + 1 ) % n ; } } n <<= 1 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { G [ i ][ j ] += ( i ? G [ i - 1 ][ j ] : 0 ); G [ i ][ j ] += ( j ? G [ i ][ j - 1 ] : 0 ); G [ i ][ j ] -= (( i && j ) ? G [ i - 1 ][ j - 1 ] : 0 ); } } int q ; scanf ( \"%d\" , & q ); while ( q -- ) { scanf ( \"%d %d %d %d\" , & x [ 0 ], & y [ 0 ], & x [ 1 ], & y [ 1 ]); ll ans = cal ( x [ 1 ], y [ 1 ]) - cal ( x [ 0 ] - 1 , y [ 1 ]) - cal ( x [ 1 ], y [ 0 ] - 1 ) + cal ( x [ 0 ] - 1 , y [ 0 ] - 1 ); printf ( \"%lld \\n \" , ans ); } } return 0 ; } Code #include <bits/stdc++.h> using namespace std ; #define N 1100 #define ll long long int t , n , q , x [ 2 ], y [ 2 ]; ll arr [ N ]; ll G [ N ][ N ]; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%lld\" , arr + i ); memset ( G , 0 , sizeof G ); for ( int i = 0 , cnt = 0 ; i <= ( n << 2 ); ++ i ) { for ( int j = 0 ; j <= i ; ++ j ) { G [ j ][ i - j ] = arr [ cnt + 1 ]; cnt = ( cnt + 1 ) % n ; } } n <<= 1 ; ll base = 0 ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) base += G [ i ][ j ]; scanf ( \"%d\" , & q ); while ( q -- ) { scanf ( \"%d%d%d%d\" , & x [ 0 ], & y [ 0 ], & x [ 1 ], & y [ 1 ]); ll ans = 0 , tmp ; // compute Big ll xl = ( x [ 1 ] - x [ 0 ] + 1 ) / n , yl = ( y [ 1 ] - y [ 0 ] + 1 ) / n ; ans += ( base * xl * yl ); // compute lower_left corner tmp = 0 ; for ( int i = x [ 0 ] + xl * n ; i <= x [ 1 ]; ++ i ) { for ( int j = y [ 0 ], cnt = 1 ; cnt <= n ; ++ cnt , ++ j ) tmp += G [ i % n ][ j % n ]; } // compute upper_right corner ans += tmp * yl ; tmp = 0 ; for ( int i = x [ 0 ], cnt = 1 ; cnt <= n ; ++ cnt , ++ i ) { for ( int j = y [ 0 ] + yl * n ; j <= y [ 1 ]; ++ j ) tmp += G [ i % n ][ j % n ]; } // compute lower_right corner ans += tmp * xl ; tmp = 0 ; for ( int i = x [ 0 ] + xl * n ; i <= x [ 1 ]; ++ i ) { for ( int j = y [ 0 ] + yl * n ; j <= y [ 1 ]; ++ j ) ans += G [ i % n ][ j % n ]; } printf ( \"%lld \\n \" , ans ); } } return 0 ; }","title":"Problem E. Matrix from Arrays"},{"location":"trainings/2018-Multi-University-Trainings/Contest-4/#problem-f-travel-through-time","text":"\u7559\u5751\u3002","title":"Problem F. Travel Through Time"},{"location":"trainings/2018-Multi-University-Trainings/Contest-4/#problem-g-depth-first-search","text":"\u7559\u5751\u3002","title":"Problem G. Depth-First Search"},{"location":"trainings/2018-Multi-University-Trainings/Contest-4/#problem-h-eat-cards-have-fun","text":"\u7559\u5751\u3002","title":"Problem H. Eat Cards, Have Fun"},{"location":"trainings/2018-Multi-University-Trainings/Contest-4/#problem-i-delightful-formulas","text":"\u7559\u5751\u3002","title":"Problem I. Delightful Formulas"},{"location":"trainings/2018-Multi-University-Trainings/Contest-4/#problem-j-let-sudoku-rotate","text":"\u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a 16 \\times 16 16 \\times 16 \u7684\u6570\u72ec\uff0c\u6709\u4e00\u4e9b 4 \\times 4 4 \\times 4 \u7684\u77e9\u9635\u88ab\u9006\u65f6\u9488\u65cb\u8f6c\u8fc7\uff0c\u7136\u540e\u6c42\u6062\u590d\u6700\u5c11\u9700\u8981\u65cb\u8f6c\u591a\u5c11\u6b21\u3002 \u601d\u8def\uff1a \u7206\u641c\uff0c\u4e24\u6761\u526a\u679d\uff0c\u4e00\u4e2a\u662f\u5224\u65ad\u662f\u5426\u6709\u51b2\u7a81\uff0c\u4e00\u4e2a\u662f\u5224\u65ad\u5f53\u524d\u6b65\u6570\u662f\u5426\u6bd4\u5df2\u6709\u7b54\u6848\u5927\u3002 Code #include <bits/stdc++.h> using namespace std ; const int maxn = 1e2 + 10 ; int ans ; bool vis [ 20 ]; char s [ 20 ]; int G [ maxn ][ maxn ]; inline bool judge ( int x , int y ) { for ( int i = x * 4 - 3 ; i <= x * 4 ; ++ i ) { memset ( vis , false , sizeof vis ); for ( int j = 1 ; j <= y * 4 ; ++ j ) { if ( vis [ G [ i ][ j ]]) return false ; vis [ G [ i ][ j ]] = true ; } } for ( int i = y * 4 - 3 ; i <= y * 4 ; ++ i ) { memset ( vis , false , sizeof vis ); for ( int j = 1 ; j <= x * 4 ; ++ j ) { if ( vis [ G [ j ][ i ]]) return false ; vis [ G [ j ][ i ]] = true ; } } return true ; } inline void fun ( int x , int y ) { int tmp [ 10 ][ 10 ]; for ( int i = 1 ; i <= 4 ; ++ i ) { for ( int j = 1 ; j <= 4 ; ++ j ) { tmp [ j ][ 4 - i + 1 ] = G [( x - 1 ) * 4 + i ][( y - 1 ) * 4 + j ]; } } for ( int i = 1 ; i <= 4 ; ++ i ) { for ( int j = 1 ; j <= 4 ; ++ j ) { G [( x - 1 ) * 4 + i ][( y - 1 ) * 4 + j ] = tmp [ i ][ j ]; } } } inline void DFS ( int x , int y , int res ) { if ( res >= ans ) return ; if ( y > 4 ) { DFS ( x + 1 , 1 , res ); return ; } if ( x == 5 ) { ans = min ( ans , res ); return ; } for ( int i = 0 ; i < 4 ; ++ i ) { if ( i ) { fun ( x , y ); /* if(x == 3 && y == 1 && i == 1) { for(int i = x * 4 - 3; i <= x * 4; ++i) { for(int j = y * 4 - 3; j <= y * 4; ++j) { printf(\"%d%c\", G[i][j], \" \\n\"[j == y * 4]); } } }*/ } if ( judge ( x , y )) { DFS ( x , y + 1 , res + i ); } } fun ( x , y ); } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { ans = 1 << 16 ; for ( int i = 1 ; i <= 16 ; ++ i ) { scanf ( \"%s\" , s + 1 ); for ( int j = 1 ; j <= 16 ; ++ j ) { if ( s [ j ] >= '0' && s [ j ] <= '9' ) { G [ i ][ j ] = s [ j ] - '0' ; } else if ( s [ j ] >= 'A' && s [ j ] <= 'F' ) { G [ i ][ j ] = ( s [ j ] - 'A' ) + 10 ; } } } // fun(1, 1); DFS ( 1 , 1 , 0 ); printf ( \"%d \\n \" , ans ); } return 0 ; }","title":"Problem J. Let Sudoku Rotate"},{"location":"trainings/2018-Multi-University-Trainings/Contest-4/#problem-k-expression-in-memories","text":"\u6309\u9898\u610f\u6a21\u62df\u5373\u53ef Code #include <bits/stdc++.h> using namespace std ; #define N 100010 int t ; char s [ N ]; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%s\" , s ); bool flag = true ; int len = strlen ( s ); for ( int i = 0 ; i < len ; ++ i ) { if ( s [ i ] == '*' || s [ i ] == '+' ) { if ( i == 0 || i == len - 1 ) { flag = false ; break ; } else if ( s [ i + 1 ] == '*' || s [ i + 1 ] == '+' ) { flag = false ; break ; } } else if ( s [ i ] == '0' ) { if ( i == 0 || s [ i - 1 ] == '*' || s [ i - 1 ] == '+' ) { if ( i + 1 < len && s [ i + 1 ] >= '0' && s [ i + 1 ] <= '9' ) { flag = false ; break ; } else if ( s [ i + 1 ] == '?' ) s [ i + 1 ] = '+' ; } } else if ( s [ i ] == '?' ) { s [ i ] = '1' ; } } if ( flag ) { printf ( \"%s \\n \" , s ); } else { printf ( \"IMPOSSIBLE \\n \" ); } } return 0 ; }","title":"Problem K. Expression in Memories"},{"location":"trainings/2018-Multi-University-Trainings/Contest-4/#problem-l-graph-theory-homework","text":"\u6c34\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 int t , n ; int arr [ N ]; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , arr + i ); int ans = ( int ) floor ( sqrt ( abs ( arr [ 1 ] - arr [ n ]))); printf ( \"%d \\n \" , ans ); } return 0 ; }","title":"Problem L. Graph Theory Homework"},{"location":"trainings/2018-Multi-University-Trainings/Contest-5/","text":"2018 Multi-University Training Contest 5 Contents A. Always Online B.Beautiful Now C. Call It What You Want D. Daylight E. Everything Has Changed F. Fireflies G. Glad You Came H. Hills And Valleys I. Innocence J. Just So You Know K. Kaleidoscope L. Lost In The Echo A. Always Online Unsolved. B.Beautiful Now Solved. \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a n n \u548c k k \u3002 \u6bcf\u6b21\u53ef\u4ee5\u5c06 n n \u8fd9\u4e2a\u6570\u5b57\u4e0a\u7684\u67d0\u4e24\u4f4d\u4ea4\u6362\uff0c\u6700\u591a\u4ea4\u6362 k k \u6b21\uff0c\u6c42\u4ea4\u6362\u540e\u7684\u6700\u5927\u548c\u6700\u5c0f\u503c\u3002 \u601d\u8def\uff1a \u5f88\u660e\u663e\u6709\u4e00\u79cd\u601d\u8def\uff0c\u5bf9\u4e8e\u6700\u5c0f\u503c\uff0c\u5c3d\u53ef\u80fd\u628a\u5c0f\u7684\u653e\u524d\u9762\uff0c\u5bf9\u4e8e\u6700\u5927\u503c\uff0c\u5c3d\u53ef\u80fd\u628a\u6253\u7684\u653e\u524d\u9762\u3002 \u4f46\u662f\u5982\u679c\u6709\u591a\u4e2a\u6700\u5c0f\u6570\u5b57\u6216\u8005\u6700\u5927\u6570\u5b57\u4f1a\u65e0\u6cd5\u5f97\u51fa\u653e\u54ea\u4e2a\u597d\uff0c\u56e0\u6b64 BFS \u4e00\u4e0b\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 10 ; struct node { int num , idx , step ; node () {} node ( int num , int idx , int step ) : num ( num ), idx ( idx ), step ( step ) {} }; int n , k ; int cnt ; int arr [ maxn ]; int BFS1 () { queue < node > q ; q . push ( node ( n , cnt , 0 )); int ans = INF ; while ( ! q . empty ()) { node now = q . front (); q . pop (); ans = min ( ans , now . num ); if ( now . step == k ) continue ; if ( now . idx == 1 ) continue ; int tmp = now . num ; cnt = 0 ; while ( tmp ) { arr [ ++ cnt ] = tmp % 10 ; tmp /= 10 ; } int Min = now . idx ; for ( int i = now . idx - 1 ; i >= 1 ; -- i ) { if ( arr [ i ] == arr [ now . idx ]) continue ; if ( arr [ i ] == 0 && now . idx == cnt ) continue ; if ( arr [ i ] < arr [ Min ]) Min = i ; } if ( Min == now . idx ) { q . push ( node ( now . num , now . idx - 1 , now . step )); } else { for ( int i = now . idx - 1 ; i >= 1 ; -- i ) { if ( arr [ i ] == arr [ Min ]) { swap ( arr [ i ], arr [ now . idx ]); tmp = 0 ; for ( int j = cnt ; j >= 1 ; -- j ) { tmp = tmp * 10 + arr [ j ]; } q . push ( node ( tmp , now . idx - 1 , now . step + 1 )); swap ( arr [ i ], arr [ now . idx ]); } } } } return ans ; } int BFS2 () { queue < node > q ; q . push ( node ( n , cnt , 0 )); int ans = - INF ; while ( ! q . empty ()) { node now = q . front (); q . pop (); ans = max ( ans , now . num ); if ( now . step == k ) continue ; if ( now . idx == 1 ) continue ; int tmp = now . num ; cnt = 0 ; while ( tmp ) { arr [ ++ cnt ] = tmp % 10 ; tmp /= 10 ; } int Max = now . idx ; for ( int i = now . idx - 1 ; i >= 1 ; -- i ) { if ( arr [ i ] == arr [ now . idx ]) continue ; if ( arr [ i ] > arr [ Max ]) Max = i ; } if ( Max == now . idx ) { q . push ( node ( now . num , now . idx - 1 , now . step )); } else { for ( int i = now . idx - 1 ; i >= 1 ; -- i ) { if ( arr [ i ] == arr [ Max ]) { swap ( arr [ i ], arr [ now . idx ]); tmp = 0 ; for ( int j = cnt ; j >= 1 ; -- j ) { tmp = tmp * 10 + arr [ j ]; } q . push ( node ( tmp , now . idx - 1 , now . step + 1 )); swap ( arr [ i ], arr [ now . idx ]); } } } } return ans ; } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d\" , & n , & k ); int tmp = n ; cnt = 0 ; while ( tmp ) { cnt ++ ; tmp /= 10 ; } k = min ( k , cnt - 1 ); int ans1 = BFS1 (); int ans2 = BFS2 (); printf ( \"%d %d \\n \" , ans1 , ans2 ); } return 0 ; } C. Call It What You Want Unsolved. D. Daylight Unsolved. E. Everything Has Changed Solved. \u9898\u610f\uff1a \u6c42\u591a\u4e2a\u5706\u7684\u5468\u957f\u5e76 \u601d\u8def\uff1a \u5bf9\u4e8e\u4e0d\u60f3\u4ea4\u548c\u5185\u542b\u7684\u76f4\u63a5 continue\uff0c\u76f8\u5207\u7684\u76f4\u63a5\u76f8\u52a0\u3002 \u5bf9\u4e8e\u76f8\u4ea4\u7684\u53ef\u4ee5\u51cf\u53bb\u5927\u5706\u4e0a\u7684\u5f27\u957f\uff0c\u52a0\u4e0a\u5c0f\u5706\u7684\u5f27\u957f\u3002 Code #include <bits/stdc++.h> using namespace std ; const double PI = acos ( -1.0 ); const double eps = 1e-8 ; int sgn ( double x ) { if ( fabs ( x ) < eps ) return 0 ; else return x > 0 ? 1 : -1 ; } struct Point { double x , y ; Point () {} Point ( double _x , double _y ) { x = _x ; y = _y ; } double distance ( Point p ) { return hypot ( x - p . x , y - p . y ); } } P ; int n ; double R , r ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %lf\" , & n , & R ); double ans = 2 * R * PI ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lf %lf %lf\" , & P . x , & P . y , & r ); double dis = P . distance ( Point ( 0.0 , 0.0 )); if ( sgn ( dis - ( r + R )) >= 0 ) continue ; else if ( sgn ( dis - ( R - r )) < 0 ) continue ; else if ( sgn ( dis - ( R - r )) == 0 ) { ans += 2 * PI * r ; continue ; } double arc1 = ( R * R + dis * dis - r * r ) / ( 2.0 * R * dis ); arc1 = 2 * acos ( arc1 ); double arc2 = ( r * r + dis * dis - R * R ) / ( 2.0 * r * dis ); arc2 = 2 * acos ( arc2 ); ans -= R * arc1 ; ans += r * arc2 ; } printf ( \"%.10f \\n \" , ans ); } return 0 ; } F. Fireflies Unsolved. G. Glad You Came Upsolved. \u9898\u610f\uff1a m m \u4e2a\u533a\u95f4\u64cd\u4f5c\uff0c\u6bcf\u6b21\u7ed9 [L, R] [L, R] \u533a\u95f4\u5185\u5c0f\u4e8e v v \u7684\u6570\u53d8\u4e3a v v \u3002 \u601d\u8def\uff1a \u7ebf\u6bb5\u6811\uff0c\u7ef4\u62a4\u6700\u5927\u6700\u5c0f\u503c + \u526a\u679d\uff0c\u56e0\u4e3a\u6570\u636e\u968f\u673a\u624d\u53ef\u4ee5\u8fd9\u6837\u505a\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 5000010 #define M 100010 #define ui unsigned int #define ll long long int t , n , m ; ui x , y , z , w ; ui f [ N << 2 ]; ui MOD = ( ui ) 1 << 30 ; ui rng61 () { x = x ^ ( x << 11 ); x = x ^ ( x >> 4 ); x = x ^ ( x << 5 ); x = x ^ ( x >> 14 ); w = x ^ y ^ z ; x = y ; y = z ; z = w ; return z ; } struct SEG { ui lazy [ M << 2 ], Max [ M << 2 ], Min [ M << 2 ]; void Init () { memset ( lazy , 0 , sizeof lazy ); memset ( Max , 0 , sizeof Max ); memset ( Min , 0 , sizeof Min ); } void pushup ( int id ) { Max [ id ] = max ( Max [ id << 1 ], Max [ id << 1 | 1 ]); Min [ id ] = min ( Min [ id << 1 ], Min [ id << 1 | 1 ]); } void pushdown ( int id ) { if ( ! lazy [ id ]) return ; lazy [ id << 1 ] = lazy [ id ]; Max [ id << 1 ] = lazy [ id ]; Min [ id << 1 ] = lazy [ id ]; lazy [ id << 1 | 1 ] = lazy [ id ]; Max [ id << 1 | 1 ] = lazy [ id ]; Min [ id << 1 | 1 ] = lazy [ id ]; lazy [ id ] = 0 ; } void update ( int id , int l , int r , int ql , int qr , ui val ) { if ( Min [ id ] >= val ) return ; if ( l >= ql && r <= qr && Max [ id ] < val ) { lazy [ id ] = Max [ id ] = val ; return ; } pushdown ( id ); int mid = ( l + r ) >> 1 ; if ( ql <= mid ) update ( id << 1 , l , mid , ql , qr , val ); if ( qr > mid ) update ( id << 1 | 1 , mid + 1 , r , ql , qr , val ); pushup ( id ); } int query ( int id , int l , int r , int pos ) { if ( l == r ) return Max [ id ]; pushdown ( id ); int mid = ( l + r ) >> 1 ; if ( pos <= mid ) return query ( id << 1 , l , mid , pos ); else return query ( id << 1 | 1 , mid + 1 , r , pos ); } } seg ; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d%u%u%u\" , & n , & m , & x , & y , & z ); for ( int i = 1 ; i <= 3 * m ; ++ i ) f [ i ] = rng61 (); seg . Init (); for ( int i = 1 , l , r , v ; i <= m ; ++ i ) { l = f [ 3 * i - 2 ] % n + 1 ; r = f [ 3 * i - 1 ] % n + 1 ; v = f [ 3 * i ] % MOD ; if ( l > r ) swap ( l , r ); seg . update ( 1 , 1 , n , l , r , v ); } ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) res ^= ( ll ) seg . query ( 1 , 1 , n , i ) * ( ll ) i ; printf ( \"%lld \\n \" , res ); } return 0 ; } H. Hills And Valleys Upsolved, \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u957f\u4e3a n n \u7684\u6570\u5b57\u4e32\uff0c\u6bcf\u4e00\u4f4d\u8303\u56f4\u662f [0, 9] [0, 9] \uff0c\u53ef\u4ee5\u7ffb\u8f6c\u5176\u4e2d\u4e00\u6bb5\uff0c\u4f7f\u5f97\u6700\u957f\u975e\u4e0b\u964d\u5b50\u5e8f\u5217\u6700\u957f\u3002 \u601d\u8def\uff1a \u4e5f\u5c31\u662f\u8bf4\uff0c\u53ef\u4ee5\u5b58\u5728\u8fd9\u6837\u4e00\u6bb5\uff1a 0, 1, 2, \\cdots, x, (x - 1), y, (y - 1), \\cdots, x, y + 1, y + 2, \\cdots 0, 1, 2, \\cdots, x, (x - 1), y, (y - 1), \\cdots, x, y + 1, y + 2, \\cdots \u6211\u4eec\u77e5\u9053\uff0c\u5982\u679c\u4e0d\u53ef\u4ee5\u7ffb\u8f6c\uff0c\u6c42\u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217\u7684\u8bdd\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u539f\u4e32\u548c\u6a21\u5f0f\u4e32 0123456789 0123456789 \u6c42\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u3002 \u90a3\u4e48\u7ffb\u8f6c\u7684\u8bdd\uff0c\u6211\u4eec\u901a\u8fc7\u679a\u4e3e\u7ffb\u8f6c\u7684\u533a\u95f4 C(2, 10) C(2, 10) \u6784\u9020\u51fa\u4e0a\u8ff0\u7684\u6a21\u5f0f\u4e32\uff0c\u518d\u6c42\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 #define INF 0x3f3f3f3f int t , n , m , a [ N ], b [ 20 ]; int dp [ N ][ 20 ], tl [ N ][ 20 ], tr [ N ][ 20 ], res , l , r , ql , qr ; void solve () { for ( int i = 1 ; i <= m ; ++ i ) dp [ 0 ][ i ] = 0 , tl [ 0 ][ i ] = -1 , tr [ 0 ][ i ] = -1 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j <= m ; ++ j ) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; tl [ i ][ j ] = tl [ i - 1 ][ j ]; tr [ i ][ j ] = tr [ i - 1 ][ j ]; if ( a [ i ] == b [ j ]) { ++ dp [ i ][ j ]; if ( j == ql && tl [ i ][ j ] == -1 ) tl [ i ][ j ] = i ; if ( j == qr ) tr [ i ][ j ] = i ; } if ( j > 1 && dp [ i ][ j - 1 ] > dp [ i ][ j ]) { dp [ i ][ j ] = dp [ i ][ j - 1 ]; tl [ i ][ j ] = tl [ i ][ j - 1 ]; tr [ i ][ j ] = tr [ i ][ j - 1 ]; } } if ( ql == 1 && qr == 1 ) { res = dp [ n ][ m ]; l = 1 ; r = 1 ; } else if ( dp [ n ][ m ] > res && tl [ n ][ m ] != -1 && tr [ n ][ m ] != -1 ) { res = dp [ n ][ m ]; l = tl [ n ][ m ]; r = tr [ n ][ m ]; } } int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); res = 1 , l = 1 , r = 1 ; for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%1d\" , a + i ); for ( int i = 1 ; i <= 10 ; ++ i ) b [ i ] = i - 1 ; m = 10 ; ql = 1 , qr = 1 ; solve (); for ( int i = 1 ; i < m ; ++ i ) for ( int j = i + 1 ; j <= 10 ; ++ j ) { m = 0 ; for ( int pos = 1 ; pos <= i ; ++ pos ) b [ ++ m ] = pos - 1 ; ql = m + 1 ; for ( int pos = j ; pos >= i ; -- pos ) b [ ++ m ] = pos - 1 ; qr = m ; for ( int pos = j ; pos <= 10 ; ++ pos ) b [ ++ m ] = pos - 1 ; solve (); // for (int i = 1; i <= m; ++i) printf(\"%d%c\", b[i], \" \\n\"[i == m]); } printf ( \"%d %d %d \\n \" , res , l , r ); } return 0 ; } I. Innocence Unsolved. J. Just So You Know Unsolved. K. Kaleidoscope Unsolved. L. Lost In The Echo Unsolved.","title":"2018 Multi-University Training Contest 5"},{"location":"trainings/2018-Multi-University-Trainings/Contest-5/#a-always-online","text":"Unsolved.","title":"A. Always Online"},{"location":"trainings/2018-Multi-University-Trainings/Contest-5/#bbeautiful-now","text":"Solved. \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a n n \u548c k k \u3002 \u6bcf\u6b21\u53ef\u4ee5\u5c06 n n \u8fd9\u4e2a\u6570\u5b57\u4e0a\u7684\u67d0\u4e24\u4f4d\u4ea4\u6362\uff0c\u6700\u591a\u4ea4\u6362 k k \u6b21\uff0c\u6c42\u4ea4\u6362\u540e\u7684\u6700\u5927\u548c\u6700\u5c0f\u503c\u3002 \u601d\u8def\uff1a \u5f88\u660e\u663e\u6709\u4e00\u79cd\u601d\u8def\uff0c\u5bf9\u4e8e\u6700\u5c0f\u503c\uff0c\u5c3d\u53ef\u80fd\u628a\u5c0f\u7684\u653e\u524d\u9762\uff0c\u5bf9\u4e8e\u6700\u5927\u503c\uff0c\u5c3d\u53ef\u80fd\u628a\u6253\u7684\u653e\u524d\u9762\u3002 \u4f46\u662f\u5982\u679c\u6709\u591a\u4e2a\u6700\u5c0f\u6570\u5b57\u6216\u8005\u6700\u5927\u6570\u5b57\u4f1a\u65e0\u6cd5\u5f97\u51fa\u653e\u54ea\u4e2a\u597d\uff0c\u56e0\u6b64 BFS \u4e00\u4e0b\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; const int INF = 0x3f3f3f3f ; const int maxn = 1e5 + 10 ; struct node { int num , idx , step ; node () {} node ( int num , int idx , int step ) : num ( num ), idx ( idx ), step ( step ) {} }; int n , k ; int cnt ; int arr [ maxn ]; int BFS1 () { queue < node > q ; q . push ( node ( n , cnt , 0 )); int ans = INF ; while ( ! q . empty ()) { node now = q . front (); q . pop (); ans = min ( ans , now . num ); if ( now . step == k ) continue ; if ( now . idx == 1 ) continue ; int tmp = now . num ; cnt = 0 ; while ( tmp ) { arr [ ++ cnt ] = tmp % 10 ; tmp /= 10 ; } int Min = now . idx ; for ( int i = now . idx - 1 ; i >= 1 ; -- i ) { if ( arr [ i ] == arr [ now . idx ]) continue ; if ( arr [ i ] == 0 && now . idx == cnt ) continue ; if ( arr [ i ] < arr [ Min ]) Min = i ; } if ( Min == now . idx ) { q . push ( node ( now . num , now . idx - 1 , now . step )); } else { for ( int i = now . idx - 1 ; i >= 1 ; -- i ) { if ( arr [ i ] == arr [ Min ]) { swap ( arr [ i ], arr [ now . idx ]); tmp = 0 ; for ( int j = cnt ; j >= 1 ; -- j ) { tmp = tmp * 10 + arr [ j ]; } q . push ( node ( tmp , now . idx - 1 , now . step + 1 )); swap ( arr [ i ], arr [ now . idx ]); } } } } return ans ; } int BFS2 () { queue < node > q ; q . push ( node ( n , cnt , 0 )); int ans = - INF ; while ( ! q . empty ()) { node now = q . front (); q . pop (); ans = max ( ans , now . num ); if ( now . step == k ) continue ; if ( now . idx == 1 ) continue ; int tmp = now . num ; cnt = 0 ; while ( tmp ) { arr [ ++ cnt ] = tmp % 10 ; tmp /= 10 ; } int Max = now . idx ; for ( int i = now . idx - 1 ; i >= 1 ; -- i ) { if ( arr [ i ] == arr [ now . idx ]) continue ; if ( arr [ i ] > arr [ Max ]) Max = i ; } if ( Max == now . idx ) { q . push ( node ( now . num , now . idx - 1 , now . step )); } else { for ( int i = now . idx - 1 ; i >= 1 ; -- i ) { if ( arr [ i ] == arr [ Max ]) { swap ( arr [ i ], arr [ now . idx ]); tmp = 0 ; for ( int j = cnt ; j >= 1 ; -- j ) { tmp = tmp * 10 + arr [ j ]; } q . push ( node ( tmp , now . idx - 1 , now . step + 1 )); swap ( arr [ i ], arr [ now . idx ]); } } } } return ans ; } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d\" , & n , & k ); int tmp = n ; cnt = 0 ; while ( tmp ) { cnt ++ ; tmp /= 10 ; } k = min ( k , cnt - 1 ); int ans1 = BFS1 (); int ans2 = BFS2 (); printf ( \"%d %d \\n \" , ans1 , ans2 ); } return 0 ; }","title":"B.Beautiful Now"},{"location":"trainings/2018-Multi-University-Trainings/Contest-5/#c-call-it-what-you-want","text":"Unsolved.","title":"C. Call It What You Want"},{"location":"trainings/2018-Multi-University-Trainings/Contest-5/#d-daylight","text":"Unsolved.","title":"D. Daylight"},{"location":"trainings/2018-Multi-University-Trainings/Contest-5/#e-everything-has-changed","text":"Solved. \u9898\u610f\uff1a \u6c42\u591a\u4e2a\u5706\u7684\u5468\u957f\u5e76 \u601d\u8def\uff1a \u5bf9\u4e8e\u4e0d\u60f3\u4ea4\u548c\u5185\u542b\u7684\u76f4\u63a5 continue\uff0c\u76f8\u5207\u7684\u76f4\u63a5\u76f8\u52a0\u3002 \u5bf9\u4e8e\u76f8\u4ea4\u7684\u53ef\u4ee5\u51cf\u53bb\u5927\u5706\u4e0a\u7684\u5f27\u957f\uff0c\u52a0\u4e0a\u5c0f\u5706\u7684\u5f27\u957f\u3002 Code #include <bits/stdc++.h> using namespace std ; const double PI = acos ( -1.0 ); const double eps = 1e-8 ; int sgn ( double x ) { if ( fabs ( x ) < eps ) return 0 ; else return x > 0 ? 1 : -1 ; } struct Point { double x , y ; Point () {} Point ( double _x , double _y ) { x = _x ; y = _y ; } double distance ( Point p ) { return hypot ( x - p . x , y - p . y ); } } P ; int n ; double R , r ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %lf\" , & n , & R ); double ans = 2 * R * PI ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lf %lf %lf\" , & P . x , & P . y , & r ); double dis = P . distance ( Point ( 0.0 , 0.0 )); if ( sgn ( dis - ( r + R )) >= 0 ) continue ; else if ( sgn ( dis - ( R - r )) < 0 ) continue ; else if ( sgn ( dis - ( R - r )) == 0 ) { ans += 2 * PI * r ; continue ; } double arc1 = ( R * R + dis * dis - r * r ) / ( 2.0 * R * dis ); arc1 = 2 * acos ( arc1 ); double arc2 = ( r * r + dis * dis - R * R ) / ( 2.0 * r * dis ); arc2 = 2 * acos ( arc2 ); ans -= R * arc1 ; ans += r * arc2 ; } printf ( \"%.10f \\n \" , ans ); } return 0 ; }","title":"E. Everything Has Changed"},{"location":"trainings/2018-Multi-University-Trainings/Contest-5/#f-fireflies","text":"Unsolved.","title":"F. Fireflies"},{"location":"trainings/2018-Multi-University-Trainings/Contest-5/#g-glad-you-came","text":"Upsolved. \u9898\u610f\uff1a m m \u4e2a\u533a\u95f4\u64cd\u4f5c\uff0c\u6bcf\u6b21\u7ed9 [L, R] [L, R] \u533a\u95f4\u5185\u5c0f\u4e8e v v \u7684\u6570\u53d8\u4e3a v v \u3002 \u601d\u8def\uff1a \u7ebf\u6bb5\u6811\uff0c\u7ef4\u62a4\u6700\u5927\u6700\u5c0f\u503c + \u526a\u679d\uff0c\u56e0\u4e3a\u6570\u636e\u968f\u673a\u624d\u53ef\u4ee5\u8fd9\u6837\u505a\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 5000010 #define M 100010 #define ui unsigned int #define ll long long int t , n , m ; ui x , y , z , w ; ui f [ N << 2 ]; ui MOD = ( ui ) 1 << 30 ; ui rng61 () { x = x ^ ( x << 11 ); x = x ^ ( x >> 4 ); x = x ^ ( x << 5 ); x = x ^ ( x >> 14 ); w = x ^ y ^ z ; x = y ; y = z ; z = w ; return z ; } struct SEG { ui lazy [ M << 2 ], Max [ M << 2 ], Min [ M << 2 ]; void Init () { memset ( lazy , 0 , sizeof lazy ); memset ( Max , 0 , sizeof Max ); memset ( Min , 0 , sizeof Min ); } void pushup ( int id ) { Max [ id ] = max ( Max [ id << 1 ], Max [ id << 1 | 1 ]); Min [ id ] = min ( Min [ id << 1 ], Min [ id << 1 | 1 ]); } void pushdown ( int id ) { if ( ! lazy [ id ]) return ; lazy [ id << 1 ] = lazy [ id ]; Max [ id << 1 ] = lazy [ id ]; Min [ id << 1 ] = lazy [ id ]; lazy [ id << 1 | 1 ] = lazy [ id ]; Max [ id << 1 | 1 ] = lazy [ id ]; Min [ id << 1 | 1 ] = lazy [ id ]; lazy [ id ] = 0 ; } void update ( int id , int l , int r , int ql , int qr , ui val ) { if ( Min [ id ] >= val ) return ; if ( l >= ql && r <= qr && Max [ id ] < val ) { lazy [ id ] = Max [ id ] = val ; return ; } pushdown ( id ); int mid = ( l + r ) >> 1 ; if ( ql <= mid ) update ( id << 1 , l , mid , ql , qr , val ); if ( qr > mid ) update ( id << 1 | 1 , mid + 1 , r , ql , qr , val ); pushup ( id ); } int query ( int id , int l , int r , int pos ) { if ( l == r ) return Max [ id ]; pushdown ( id ); int mid = ( l + r ) >> 1 ; if ( pos <= mid ) return query ( id << 1 , l , mid , pos ); else return query ( id << 1 | 1 , mid + 1 , r , pos ); } } seg ; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d%u%u%u\" , & n , & m , & x , & y , & z ); for ( int i = 1 ; i <= 3 * m ; ++ i ) f [ i ] = rng61 (); seg . Init (); for ( int i = 1 , l , r , v ; i <= m ; ++ i ) { l = f [ 3 * i - 2 ] % n + 1 ; r = f [ 3 * i - 1 ] % n + 1 ; v = f [ 3 * i ] % MOD ; if ( l > r ) swap ( l , r ); seg . update ( 1 , 1 , n , l , r , v ); } ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) res ^= ( ll ) seg . query ( 1 , 1 , n , i ) * ( ll ) i ; printf ( \"%lld \\n \" , res ); } return 0 ; }","title":"G. Glad You Came"},{"location":"trainings/2018-Multi-University-Trainings/Contest-5/#h-hills-and-valleys","text":"Upsolved, \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u957f\u4e3a n n \u7684\u6570\u5b57\u4e32\uff0c\u6bcf\u4e00\u4f4d\u8303\u56f4\u662f [0, 9] [0, 9] \uff0c\u53ef\u4ee5\u7ffb\u8f6c\u5176\u4e2d\u4e00\u6bb5\uff0c\u4f7f\u5f97\u6700\u957f\u975e\u4e0b\u964d\u5b50\u5e8f\u5217\u6700\u957f\u3002 \u601d\u8def\uff1a \u4e5f\u5c31\u662f\u8bf4\uff0c\u53ef\u4ee5\u5b58\u5728\u8fd9\u6837\u4e00\u6bb5\uff1a 0, 1, 2, \\cdots, x, (x - 1), y, (y - 1), \\cdots, x, y + 1, y + 2, \\cdots 0, 1, 2, \\cdots, x, (x - 1), y, (y - 1), \\cdots, x, y + 1, y + 2, \\cdots \u6211\u4eec\u77e5\u9053\uff0c\u5982\u679c\u4e0d\u53ef\u4ee5\u7ffb\u8f6c\uff0c\u6c42\u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217\u7684\u8bdd\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u539f\u4e32\u548c\u6a21\u5f0f\u4e32 0123456789 0123456789 \u6c42\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u3002 \u90a3\u4e48\u7ffb\u8f6c\u7684\u8bdd\uff0c\u6211\u4eec\u901a\u8fc7\u679a\u4e3e\u7ffb\u8f6c\u7684\u533a\u95f4 C(2, 10) C(2, 10) \u6784\u9020\u51fa\u4e0a\u8ff0\u7684\u6a21\u5f0f\u4e32\uff0c\u518d\u6c42\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 #define INF 0x3f3f3f3f int t , n , m , a [ N ], b [ 20 ]; int dp [ N ][ 20 ], tl [ N ][ 20 ], tr [ N ][ 20 ], res , l , r , ql , qr ; void solve () { for ( int i = 1 ; i <= m ; ++ i ) dp [ 0 ][ i ] = 0 , tl [ 0 ][ i ] = -1 , tr [ 0 ][ i ] = -1 ; for ( int i = 1 ; i <= n ; ++ i ) for ( int j = 1 ; j <= m ; ++ j ) { dp [ i ][ j ] = dp [ i - 1 ][ j ]; tl [ i ][ j ] = tl [ i - 1 ][ j ]; tr [ i ][ j ] = tr [ i - 1 ][ j ]; if ( a [ i ] == b [ j ]) { ++ dp [ i ][ j ]; if ( j == ql && tl [ i ][ j ] == -1 ) tl [ i ][ j ] = i ; if ( j == qr ) tr [ i ][ j ] = i ; } if ( j > 1 && dp [ i ][ j - 1 ] > dp [ i ][ j ]) { dp [ i ][ j ] = dp [ i ][ j - 1 ]; tl [ i ][ j ] = tl [ i ][ j - 1 ]; tr [ i ][ j ] = tr [ i ][ j - 1 ]; } } if ( ql == 1 && qr == 1 ) { res = dp [ n ][ m ]; l = 1 ; r = 1 ; } else if ( dp [ n ][ m ] > res && tl [ n ][ m ] != -1 && tr [ n ][ m ] != -1 ) { res = dp [ n ][ m ]; l = tl [ n ][ m ]; r = tr [ n ][ m ]; } } int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); res = 1 , l = 1 , r = 1 ; for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%1d\" , a + i ); for ( int i = 1 ; i <= 10 ; ++ i ) b [ i ] = i - 1 ; m = 10 ; ql = 1 , qr = 1 ; solve (); for ( int i = 1 ; i < m ; ++ i ) for ( int j = i + 1 ; j <= 10 ; ++ j ) { m = 0 ; for ( int pos = 1 ; pos <= i ; ++ pos ) b [ ++ m ] = pos - 1 ; ql = m + 1 ; for ( int pos = j ; pos >= i ; -- pos ) b [ ++ m ] = pos - 1 ; qr = m ; for ( int pos = j ; pos <= 10 ; ++ pos ) b [ ++ m ] = pos - 1 ; solve (); // for (int i = 1; i <= m; ++i) printf(\"%d%c\", b[i], \" \\n\"[i == m]); } printf ( \"%d %d %d \\n \" , res , l , r ); } return 0 ; }","title":"H. Hills And Valleys"},{"location":"trainings/2018-Multi-University-Trainings/Contest-5/#i-innocence","text":"Unsolved.","title":"I. Innocence"},{"location":"trainings/2018-Multi-University-Trainings/Contest-5/#j-just-so-you-know","text":"Unsolved.","title":"J. Just So You Know"},{"location":"trainings/2018-Multi-University-Trainings/Contest-5/#k-kaleidoscope","text":"Unsolved.","title":"K. Kaleidoscope"},{"location":"trainings/2018-Multi-University-Trainings/Contest-5/#l-lost-in-the-echo","text":"Unsolved.","title":"L. Lost In The Echo"},{"location":"trainings/2018-Multi-University-Trainings/Contest-6/","text":"2018 Multi-University Training Contest 6 Contents A. oval-and-rectangle B. bookshelf C. Ringland D. Shoot Game E. black-and-white F. foam-transformation G. Variance-MST H. Rectangle Outline I. Werewolf J. Chopping hands K. sacul L. Pinball A. oval-and-rectangle \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u692d\u5706\u7684 a a \u548c b b \uff0c\u5728 [0, b] [0, b] \u4e2d\u968f\u673a\u9009\u62e9 c c \u4f7f\u5f97 4 4 \u4e2a\u9876\u70b9\u5728\u692d\u5706\u4e0a\u6784\u6210\u4e00\u4e2a\u77e9\u5f62\uff0c\u6c42\u77e9\u5f62\u5468\u957f\u671f\u671b\u3002 \u601d\u8def\uff1a \u6c42\u51fa\u6bcf\u79cd\u77e9\u5f62\u7684\u5468\u957f\uff0c\u9664\u4ee5 b b \u3002\uff08\u79ef\u5206\uff09 Code #include <bits/stdc++.h> using namespace std ; const double PI = acos ( -1.0 ); double a , b ; void RUN () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%lf %lf\" , & a , & b ); double ans = 2 * b + a * PI ; printf ( \"%.6f \\n \" , ans - 5e-7 ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE return 0 ; } B. bookshelf \u7559\u5751\u3002 C. Ringland \u7559\u5751\u3002 D. Shoot Game \u7559\u5751\u3002 E. black-and-white \u7559\u5751\u3002 F. foam-transformation \u7559\u5751\u3002 G. Variance-MST \u7559\u5751\u3002 H. Rectangle Outline \u7559\u5751\u3002 I. Werewolf \u9898\u610f\uff1a \u72fc\u4eba\u6740\u6e38\u620f\uff0c\u6bcf\u4e2a\u4eba\u90fd\u4f1a\u6307\u660e\u53e6\u4e00\u4e2a\u4eba\u7684\u8eab\u4efd\uff0c\u6751\u6c11\u4e00\u5b9a\u4e0d\u4f1a\u8bf4\u8c0e\uff0c\u72fc\u4eba\u53ef\u80fd\u8bf4\u8c0e\uff0c\u6c42\u786e\u5b9a\u7684\u6751\u6c11\u548c\u72fc\u4eba\u3002 \u601d\u8def\uff1a \u5982\u679c\u5168\u90fd\u662f\u72fc\u4eba\uff0c\u90a3\u4e48\u903b\u8f91\u4e00\u5b9a\u6210\u7acb\uff0c\u6240\u4ee5\u786e\u5b9a\u7684\u6751\u6c11\u6570\u91cf\u4e3a 0 0 \u3002 \u5bf9\u4e8e\u72fc\u4eba\u53ef\u4ee5\u901a\u8fc7\u53cd\u8bc1\u6cd5\u8bc1\u660e\uff0c\u82e5 1 1 \u8ba4\u4e3a 2 2 \u662f\u6751\u6c11\uff0c 2 2 \u8ba4\u4e3a 3 3 \u4e3a\u6751\u6c11\uff0c 3 3 \u8ba4\u4e3a 4 4 \u4e3a\u6751\u6c11\uff0c 4 4 \u8ba4\u4e3a 2 2 \u4e3a\u72fc\u4eba\uff0c\u53cd\u8bc1\u6cd5\u5f97\u51fa 1,2 1,2 \u4e3a\u72fc\u4eba\uff0c\u4ee5\u6b64\u7c7b\u63a8\uff0cDFS \u4e00\u4e0b\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; const int maxn = ( int ) 1e5 + 10 ; int n ; int ans1 , ans2 ; int fa [ maxn ]; char str [ 110 ]; vector < pair < int , int > > wolf ; vector < int > human [ maxn ]; void Init ( int n ) { ans1 = ans2 = 0 ; for ( int i = 0 ; i <= n ; ++ i ) fa [ i ] = i , human [ i ]. clear (); wolf . clear (); } int find ( int x ) { return x == fa [ x ] ? fa [ x ] : fa [ x ] = find ( fa [ x ]); } void mix ( int x , int y ) { x = find ( x ), y = find ( y ); if ( x != y ) { fa [ x ] = y ; } } bool same ( int x , int y ) { return find ( x ) == find ( y ); } void DFS ( int u ) { for ( auto it : human [ u ]) { ++ ans2 ; DFS ( it ); } } void RUN () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); Init ( n ); for ( int i = 1 ; i <= n ; ++ i ) { int u ; scanf ( \"%d %s\" , & u , str ); if ( str [ 0 ] == 'v' ) { mix ( i , u ); human [ u ]. push_back ( i ); } else { wolf . push_back ( make_pair ( i , u )); } } for ( auto it : wolf ) { if ( same ( it . first , it . second )) { ++ ans2 ; DFS ( it . second ); } } printf ( \"%d %d \\n \" , ans1 , ans2 ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE return 0 ; } J. Chopping hands \u7559\u5751\u3002 K. sacul \u7559\u5751\u3002 L. Pinball \u9898\u610f\uff1a \u4e00\u4e2a\u5c0f\u7403\u5782\u76f4\u4e0b\u843d\u5728\u4e00\u4e2a\u659c\u677f\u4e0a\uff0c\u6c42\u5728\u659c\u677f\u4e0a\u5f39\u51e0\u6b21\u3002 \u601d\u8def\uff1a \u5206\u89e3\u5c0f\u7403\u8fd0\u52a8\uff08\u7269\u7406\u9898\uff09 Code #include <bits/stdc++.h> using namespace std ; const double g = 9.8 ; double a , b , x , y ; void RUN () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%lf %lf %lf %lf\" , & a , & b , & x , & y ); x = -1.0 * x ; double Tan = b / a ; double arc = atan ( Tan ); double vx = g * sin ( arc ); double vy = g * cos ( arc ); double h = ( y - b / a * x ) * cos ( arc ); double dis = ( y - b / a * x ) * sin ( arc ) + x / cos ( arc ); double t = sqrt ( 2 * dis / vx ); double per = sqrt ( 2 * h / vy ); int ans = 0 ; if ( t > per ) { ans ++ ; t -= per ; } ans += t / ( per * 2 ); printf ( \"%d \\n \" , ans ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE return 0 ; }","title":"2018 Multi-University Training Contest 6"},{"location":"trainings/2018-Multi-University-Trainings/Contest-6/#a-oval-and-rectangle","text":"\u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u692d\u5706\u7684 a a \u548c b b \uff0c\u5728 [0, b] [0, b] \u4e2d\u968f\u673a\u9009\u62e9 c c \u4f7f\u5f97 4 4 \u4e2a\u9876\u70b9\u5728\u692d\u5706\u4e0a\u6784\u6210\u4e00\u4e2a\u77e9\u5f62\uff0c\u6c42\u77e9\u5f62\u5468\u957f\u671f\u671b\u3002 \u601d\u8def\uff1a \u6c42\u51fa\u6bcf\u79cd\u77e9\u5f62\u7684\u5468\u957f\uff0c\u9664\u4ee5 b b \u3002\uff08\u79ef\u5206\uff09 Code #include <bits/stdc++.h> using namespace std ; const double PI = acos ( -1.0 ); double a , b ; void RUN () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%lf %lf\" , & a , & b ); double ans = 2 * b + a * PI ; printf ( \"%.6f \\n \" , ans - 5e-7 ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE return 0 ; }","title":"A. oval-and-rectangle"},{"location":"trainings/2018-Multi-University-Trainings/Contest-6/#b-bookshelf","text":"\u7559\u5751\u3002","title":"B. bookshelf"},{"location":"trainings/2018-Multi-University-Trainings/Contest-6/#c-ringland","text":"\u7559\u5751\u3002","title":"C. Ringland"},{"location":"trainings/2018-Multi-University-Trainings/Contest-6/#d-shoot-game","text":"\u7559\u5751\u3002","title":"D. Shoot Game"},{"location":"trainings/2018-Multi-University-Trainings/Contest-6/#e-black-and-white","text":"\u7559\u5751\u3002","title":"E. black-and-white"},{"location":"trainings/2018-Multi-University-Trainings/Contest-6/#f-foam-transformation","text":"\u7559\u5751\u3002","title":"F. foam-transformation"},{"location":"trainings/2018-Multi-University-Trainings/Contest-6/#g-variance-mst","text":"\u7559\u5751\u3002","title":"G. Variance-MST"},{"location":"trainings/2018-Multi-University-Trainings/Contest-6/#h-rectangle-outline","text":"\u7559\u5751\u3002","title":"H. Rectangle Outline"},{"location":"trainings/2018-Multi-University-Trainings/Contest-6/#i-werewolf","text":"\u9898\u610f\uff1a \u72fc\u4eba\u6740\u6e38\u620f\uff0c\u6bcf\u4e2a\u4eba\u90fd\u4f1a\u6307\u660e\u53e6\u4e00\u4e2a\u4eba\u7684\u8eab\u4efd\uff0c\u6751\u6c11\u4e00\u5b9a\u4e0d\u4f1a\u8bf4\u8c0e\uff0c\u72fc\u4eba\u53ef\u80fd\u8bf4\u8c0e\uff0c\u6c42\u786e\u5b9a\u7684\u6751\u6c11\u548c\u72fc\u4eba\u3002 \u601d\u8def\uff1a \u5982\u679c\u5168\u90fd\u662f\u72fc\u4eba\uff0c\u90a3\u4e48\u903b\u8f91\u4e00\u5b9a\u6210\u7acb\uff0c\u6240\u4ee5\u786e\u5b9a\u7684\u6751\u6c11\u6570\u91cf\u4e3a 0 0 \u3002 \u5bf9\u4e8e\u72fc\u4eba\u53ef\u4ee5\u901a\u8fc7\u53cd\u8bc1\u6cd5\u8bc1\u660e\uff0c\u82e5 1 1 \u8ba4\u4e3a 2 2 \u662f\u6751\u6c11\uff0c 2 2 \u8ba4\u4e3a 3 3 \u4e3a\u6751\u6c11\uff0c 3 3 \u8ba4\u4e3a 4 4 \u4e3a\u6751\u6c11\uff0c 4 4 \u8ba4\u4e3a 2 2 \u4e3a\u72fc\u4eba\uff0c\u53cd\u8bc1\u6cd5\u5f97\u51fa 1,2 1,2 \u4e3a\u72fc\u4eba\uff0c\u4ee5\u6b64\u7c7b\u63a8\uff0cDFS \u4e00\u4e0b\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; const int maxn = ( int ) 1e5 + 10 ; int n ; int ans1 , ans2 ; int fa [ maxn ]; char str [ 110 ]; vector < pair < int , int > > wolf ; vector < int > human [ maxn ]; void Init ( int n ) { ans1 = ans2 = 0 ; for ( int i = 0 ; i <= n ; ++ i ) fa [ i ] = i , human [ i ]. clear (); wolf . clear (); } int find ( int x ) { return x == fa [ x ] ? fa [ x ] : fa [ x ] = find ( fa [ x ]); } void mix ( int x , int y ) { x = find ( x ), y = find ( y ); if ( x != y ) { fa [ x ] = y ; } } bool same ( int x , int y ) { return find ( x ) == find ( y ); } void DFS ( int u ) { for ( auto it : human [ u ]) { ++ ans2 ; DFS ( it ); } } void RUN () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); Init ( n ); for ( int i = 1 ; i <= n ; ++ i ) { int u ; scanf ( \"%d %s\" , & u , str ); if ( str [ 0 ] == 'v' ) { mix ( i , u ); human [ u ]. push_back ( i ); } else { wolf . push_back ( make_pair ( i , u )); } } for ( auto it : wolf ) { if ( same ( it . first , it . second )) { ++ ans2 ; DFS ( it . second ); } } printf ( \"%d %d \\n \" , ans1 , ans2 ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE return 0 ; }","title":"I. Werewolf"},{"location":"trainings/2018-Multi-University-Trainings/Contest-6/#j-chopping-hands","text":"\u7559\u5751\u3002","title":"J. Chopping hands"},{"location":"trainings/2018-Multi-University-Trainings/Contest-6/#k-sacul","text":"\u7559\u5751\u3002","title":"K. sacul"},{"location":"trainings/2018-Multi-University-Trainings/Contest-6/#l-pinball","text":"\u9898\u610f\uff1a \u4e00\u4e2a\u5c0f\u7403\u5782\u76f4\u4e0b\u843d\u5728\u4e00\u4e2a\u659c\u677f\u4e0a\uff0c\u6c42\u5728\u659c\u677f\u4e0a\u5f39\u51e0\u6b21\u3002 \u601d\u8def\uff1a \u5206\u89e3\u5c0f\u7403\u8fd0\u52a8\uff08\u7269\u7406\u9898\uff09 Code #include <bits/stdc++.h> using namespace std ; const double g = 9.8 ; double a , b , x , y ; void RUN () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%lf %lf %lf %lf\" , & a , & b , & x , & y ); x = -1.0 * x ; double Tan = b / a ; double arc = atan ( Tan ); double vx = g * sin ( arc ); double vy = g * cos ( arc ); double h = ( y - b / a * x ) * cos ( arc ); double dis = ( y - b / a * x ) * sin ( arc ) + x / cos ( arc ); double t = sqrt ( 2 * dis / vx ); double per = sqrt ( 2 * h / vy ); int ans = 0 ; if ( t > per ) { ans ++ ; t -= per ; } ans += t / ( per * 2 ); printf ( \"%d \\n \" , ans ); } } int main () { #ifdef LOCAL_JUDGE freopen ( \"Text.txt\" , \"r\" , stdin ); #endif // LOCAL_JUDGE RUN (); #ifdef LOCAL_JUDGE fclose ( stdin ); #endif // LOCAL_JUDGE return 0 ; }","title":"L. Pinball"},{"location":"trainings/2018-Multi-University-Trainings/Contest-7/","text":"2018 Multi-University Training Contest 7 Contents A. Age of Moyu B. AraBellaC C. YJJ\u2019s Stack D. Go to school E. GuGuFishtion F. Lord Li's problem G. Reverse Game H. Traffic Network in Numazu I. Tree J. Sequence K. Swordsman A. Age of Moyu \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u5f20\u56fe\uff0c\u4ece 1 1 \u8d70\u5230 n n \uff0c\u5982\u679c\u76f8\u90bb\u4e24\u6b21\u8d70\u7684\u8fb9\u7684\u6743\u503c\u4e0d\u540c\uff0c\u82b1\u8d39 +1 +1 \uff0c\u5426\u5219\u82b1\u8d39\u76f8\u540c\uff0c\u6c42\u6700\u5c0f\u82b1\u8d39\u3002 \u601d\u8def\uff1a \u7528 set \u8bb0\u5f55\u6709\u5f53\u524d\u70b9\u7684\u6700\u5c0f\u82b1\u8d39\u6709\u591a\u5c11\u79cd\u65b9\u6848\u5230\u8fbe\uff0c\u7136\u540e\u6700\u77ed\u8def\u3002 Code #include <bits/stdc++.h> using namespace std ; const int INF = 0x3f3f3f3f ; const int maxn = 2e5 + 10 ; struct Edge { int to , nxt , val ; Edge () {} Edge ( int to , int nxt , int val ) : to ( to ), nxt ( nxt ), val ( val ){}; } edge [ maxn << 1 ]; set < int > s [ maxn ]; int head [ maxn ], tot ; void Init ( int n ) { for ( int i = 0 ; i <= n ; ++ i ) head [ i ] = -1 , s [ i ]. clear (); tot = 0 ; } void addedge ( int u , int v , int val ) { edge [ tot ] = Edge ( v , head [ u ], val ); head [ u ] = tot ++ ; } struct qnode { int v , c ; int pre ; int fa ; qnode () {} qnode ( int v , int c , int pre , int fa ) : v ( v ), c ( c ), pre ( pre ), fa ( fa ) {} bool operator < ( const qnode & r ) const { return c > r . c ; } }; int n , m ; int dist [ maxn ]; void BFS ( int st ) { for ( int i = 1 ; i <= n ; ++ i ) dist [ i ] = INF ; priority_queue < qnode > q ; dist [ st ] = 0 ; q . push ( qnode ( st , 0 , 0 , 0 )); while ( ! q . empty ()) { qnode tmp = q . top (); q . pop (); int u = tmp . v ; if ( tmp . c > dist [ u ]) continue ; else if ( tmp . c == dist [ u ]) { if ( s [ u ]. find ( tmp . pre ) != s [ u ]. end ()) continue ; s [ u ]. insert ( tmp . pre ); } else { dist [ u ] = tmp . c ; s [ u ]. clear (); s [ u ]. insert ( tmp . pre ); } for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { int v = edge [ i ]. to ; int cost = edge [ i ]. val ; if ( v == tmp . fa ) continue ; if ( dist [ u ] + ( cost != tmp . pre ) <= dist [ v ]) { dist [ v ] = dist [ u ] + ( cost != tmp . pre ); if ( v != n ) { q . push ( qnode ( v , dist [ v ], cost , u )); } } } } } int main () { int t ; while ( scanf ( \"%d %d\" , & n , & m ) != EOF ) { Init ( n ); for ( int i = 1 ; i <= m ; ++ i ) { int u , v , w ; scanf ( \"%d %d %d\" , & u , & v , & w ); addedge ( u , v , w ); addedge ( v , u , w ); } BFS ( 1 ); if ( dist [ n ] == INF ) dist [ n ] = -1 ; printf ( \"%d \\n \" , dist [ n ]); } return 0 ; } B. AraBellaC \u7559\u5751\u3002 C. YJJ\u2019s Stack \u7559\u5751\u3002 D. Go to school \u7559\u5751\u3002 E. GuGuFishtion \u7559\u5751\u3002 F. Lord Li's problem \u7559\u5751\u3002 G. Reverse Game \u7559\u5751\u3002 H. Traffic Network in Numazu \u9898\u610f\uff1a \u4e24\u79cd\u64cd\u4f5c\uff1a \u7b2c\u4e00\u79cd\u662f\u66f4\u6539\u4e00\u6761\u8fb9\u6743\u7684\u503c\u3002 \u7b2c\u4e8c\u79cd\u662f\u67e5\u8be2 x \\rightarrow y x \\rightarrow y \u7684\u6700\u77ed\u8def\u5f84\u3002 \u7ed9\u51fa\u7684\u662f\u4e00\u9897\u6811\u52a0\u4e00\u6761\u8fb9\u3002 \u601d\u8def\uff1a \u5c06\u5f62\u6210\u73af\u7684\u8fb9\u5355\u72ec\u62ff\u51fa\u6765\u8003\u8651\u3002 \u90a3\u4e48\u8003\u8651\u662f\u5426\u7ecf\u8fc7\u8fd9\u6761\u8fb9\u4f7f\u5f97\u7b54\u6848\u66f4\u4f18\u3002 \u4fee\u6539\u64cd\u4f5c\u7528\u7ebf\u6bb5\u6811\u6216\u8005\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int maxn = 1e5 + 10 ; const int DEG = 20 ; struct EDGE { int u , v , w ; } EDGE [ maxn ], TEMP ; struct Edge { int to , nxt , val ; Edge () {} Edge ( int to , int nxt , int val ) : to ( to ), nxt ( nxt ), val ( val ) {} } edge [ maxn << 1 ]; int head [ maxn ], tot , cnt ; int father [ maxn ]; void Init ( int n ) { for ( int i = 0 ; i <= n ; ++ i ) head [ i ] = -1 , father [ i ] = i ; tot = cnt = 0 ; } int find ( int x ) { return x == father [ x ] ? father [ x ] : father [ x ] = find ( father [ x ]); } void mix ( int x , int y ) { x = find ( x ), y = find ( y ); if ( x != y ) father [ x ] = y ; } bool same ( int x , int y ) { return find ( x ) == find ( y ); } void addedge ( int u , int v , int val ) { edge [ tot ] = Edge ( v , head [ u ], val ); head [ u ] = tot ++ ; } int dro [ maxn ]; int ord [ maxn ], son [ maxn ]; int fa [ maxn ][ DEG ]; int deg [ maxn ]; void DFS ( int u , int pre ) { ord [ u ] = ++ cnt ; dro [ cnt ] = u ; for ( int i = 1 ; i < DEG ; ++ i ) fa [ u ][ i ] = fa [ fa [ u ][ i - 1 ]][ i - 1 ]; for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { int v = edge [ i ]. to ; if ( v == pre ) continue ; fa [ v ][ 0 ] = u ; deg [ v ] = deg [ u ] + 1 ; DFS ( v , u ); } son [ u ] = cnt ; } int LCA ( int u , int v ) { if ( deg [ u ] > deg [ v ]) swap ( u , v ); int hu = deg [ u ], hv = deg [ v ]; int tu = u , tv = v ; for ( int det = hv - hu , i = 0 ; det ; det >>= 1 , ++ i ) { if ( det & 1 ) { tv = fa [ tv ][ i ]; } } if ( tu == tv ) return tu ; for ( int i = DEG - 1 ; i >= 0 ; -- i ) { if ( fa [ tu ][ i ] == fa [ tv ][ i ]) continue ; tu = fa [ tu ][ i ]; tv = fa [ tv ][ i ]; } return fa [ tu ][ 0 ]; } struct node { int l , r ; ll val , lazy ; node () {} node ( int l , int r , ll val , ll lazy ) : l ( l ), r ( r ), val ( val ), lazy ( lazy ) {} } tree [ maxn << 2 ]; void pushup ( int id ) { tree [ id ]. val = tree [ id << 1 ]. val + tree [ id << 1 | 1 ]. val ; } void pushdown ( int id ) { if ( tree [ id ]. lazy ) { ll lazy = tree [ id ]. lazy ; tree [ id << 1 ]. val += lazy ; tree [ id << 1 | 1 ]. val += lazy ; tree [ id << 1 ]. lazy += lazy ; tree [ id << 1 | 1 ]. lazy += lazy ; tree [ id ]. lazy = 0 ; } } void build ( int id , int l , int r ) { tree [ id ] = node ( l , r , 0 , 0 ); if ( l == r ) return ; int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); } void update ( int id , int l , int r , ll val ) { if ( l <= tree [ id ]. l && r >= tree [ id ]. r ) { tree [ id ]. val += val ; tree [ id ]. lazy += val ; return ; } pushdown ( id ); int mid = ( tree [ id ]. l + tree [ id ]. r ) >> 1 ; if ( mid >= l ) update ( id << 1 , l , r , val ); if ( r > mid ) update ( id << 1 | 1 , l , r , val ); pushup ( id ); } ll query ( int id , int pos ) { if ( tree [ id ]. l == pos && tree [ id ]. r == pos ) { return tree [ id ]. val ; } pushdown ( id ); int mid = ( tree [ id ]. l + tree [ id ]. r ) >> 1 ; if ( pos <= mid ) return query ( id << 1 , pos ); if ( pos > mid ) return query ( id << 1 | 1 , pos ); pushup ( id ); } ll getdis ( int u , int v ) { int root = LCA ( u , v ); return query ( 1 , ord [ u ]) + query ( 1 , ord [ v ]) - 2 * query ( 1 , ord [ root ]); } int n , q ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d\" , & n , & q ); Init ( n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d %d %d\" , & EDGE [ i ]. u , & EDGE [ i ]. v , & EDGE [ i ]. w ); int u = EDGE [ i ]. u , v = EDGE [ i ]. v , w = EDGE [ i ]. w ; if ( same ( u , v )) { TEMP = EDGE [ i ]; continue ; } mix ( u , v ); addedge ( u , v , w ); addedge ( v , u , w ); } fa [ 1 ][ 0 ] = 1 ; deg [ 1 ] = 0 ; DFS ( 1 , -1 ); build ( 1 , 1 , n ); for ( int i = 1 ; i <= n ; ++ i ) { int u = EDGE [ i ]. u , v = EDGE [ i ]. v , w = EDGE [ i ]. w ; if ( u == TEMP . u && v == TEMP . v ) continue ; if ( fa [ u ][ 0 ] == v ) { update ( 1 , ord [ u ], son [ u ], w ); } else if ( fa [ v ][ 0 ] == u ) ; { update ( 1 , ord [ v ], son [ v ], w ); } } // for(int i = 1; i <= n; ++i) cout << ord[i] << endl; // for(int i = 1; i <= n; ++i) cout << i << \" \" << query(1, ord[i]) << endl; while ( q -- ) { int op , x , y ; scanf ( \"%d %d %d\" , & op , & x , & y ); if ( op == 0 ) { int u = EDGE [ x ]. u , v = EDGE [ x ]. v , w = EDGE [ x ]. w ; if ( u == TEMP . u && v == TEMP . v ) { EDGE [ x ]. w = y ; TEMP . w = y ; } if ( fa [ u ][ 0 ] == v ) { update ( 1 , ord [ u ], son [ u ], y - w ); } else if ( fa [ v ][ 0 ] == u ) { update ( 1 , ord [ v ], son [ v ], y - w ); } EDGE [ x ]. w = y ; } else if ( op == 1 ) { ll ans = getdis ( x , y ); ans = min ( ans , getdis ( x , TEMP . u ) + TEMP . w + getdis ( y , TEMP . v )); ans = min ( ans , getdis ( y , TEMP . u ) + TEMP . w + getdis ( x , TEMP . v )); printf ( \"%lld \\n \" , ans ); } } } return 0 ; } I. Tree \u9898\u610f\uff1a \u4e00\u68f5\u6811\u79cd\uff0c\u6bcf\u4e2a\u70b9\u6709\u4e00\u4e2a\u6743\u503c\uff0c\u8868\u793a\u53ef\u4ee5\u5411\u4e0a\u8df3\u51e0\u6b65\uff0c\u4e24\u79cd\u64cd\u4f5c\uff0c\u4e00\u79cd\u662f\u4fee\u6539\u67d0\u70b9\u6743\u503c\uff0c\u8fd8\u6709\u4e00\u79cd\u662f\u8be2\u95ee\u67d0\u4e2a\u70b9\u9700\u8981\u8df3\u51e0\u6b21\u8df3\u51fa\u3002 \u601d\u8def\uff1a DFS \u5e8f\u5206\u5757\uff0c\u5f39\u98de\u7ef5\u9633\u5347\u7ea7\u7248\uff0c\u6ce8\u610f\u66f4\u65b0\u7684\u65f6\u5019\uff0c\u7ef4\u62a4\u4e00\u4e2a In[u] In[u] \u8868\u793a\u6700\u8fdc\u8df3\u5230\u5757\u5185\u662f\u7b2c\u51e0\u5757\uff0c\u8fd9\u6837\u5c31\u4e0d\u7528\u591a\u4e00\u4e2a log log \u590d\u6742\u5ea6\u3002 Code #include <bits/stdc++.h> using namespace std ; namespace FastIO { #define BUF_SIZE 10000005 bool IOerror = false ; inline char NC () { static char buf [ BUF_SIZE ], * p1 = buf + BUF_SIZE , * pend = buf + BUF_SIZE ; if ( p1 == pend ) { p1 = buf ; pend = buf + fread ( buf , 1 , BUF_SIZE , stdin ); if ( pend == p1 ) { IOerror = true ; return -1 ; } } return * p1 ++ ; } inline bool blank ( char ch ) { return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t' ; } template < typename T > inline void read ( T & x ) { char ch ; while ( blank ( ch = NC ())) ; if ( IOerror ) { x = -1 ; return ; } bool flag = false ; if ( ch == '-' ) { flag = true ; ch = NC (); } if ( ! isdigit ( ch )) while ( ! isdigit ( ch = NC ())) ; for ( x = ch - '0' ; isdigit ( ch = NC ()); x = x * 10 + ch - '0' ) ; if ( flag ) x *= -1 ; } void out ( int x ) { if ( x / 10 ) out ( x / 10 ); putchar ( x % 10 + '0' ); } inline void print ( int x ) { out ( x ); puts ( \"\" ); } #undef BUF_SIZE } // namespace FastIO using namespace FastIO ; #define N 100010 #define DEG 20 #define block 400 int t , n , q ; int a [ N ], b [ N ], In [ N ], Out [ N ], fa [ N ][ 20 ], deep [ N ], p [ N ], fp [ N ], cnt ; vector < int > G [ N ]; void Init () { for ( int i = 1 ; i <= n ; ++ i ) G [ i ]. clear (); cnt = 0 ; fa [ 1 ][ 0 ] = 1 ; deep [ 1 ] = 0 ; } void DFS ( int u ) { p [ u ] = ++ cnt ; fp [ cnt ] = u ; for ( int i = 1 ; i < DEG ; ++ i ) fa [ u ][ i ] = fa [ fa [ u ][ i - 1 ]][ i - 1 ]; for ( auto v : G [ u ]) if ( v != fa [ u ][ 0 ]) { deep [ v ] = deep [ u ] + 1 ; DFS ( v ); } } int GetK ( int x , int k ) { bitset < 20 > b ; b = k ; for ( int i = 19 ; i >= 0 ; -- i ) if ( b [ i ]) x = fa [ x ][ i ]; return x ; } int query ( int x ) { int res = 0 ; x = p [ x ]; while ( x ) { res += b [ x ]; x = Out [ x ]; } return res ; } void update ( int x ) { if ( a [ x ] > deep [ x ]) { b [ p [ x ]] = 1 ; Out [ p [ x ]] = 0 ; In [ p [ x ]] = p [ x ]; } else { int root = GetK ( x , a [ x ]); if (( p [ root ] - 1 ) / block != ( p [ x ] - 1 ) / block ) { b [ p [ x ]] = 1 ; Out [ p [ x ]] = p [ root ]; In [ p [ x ]] = p [ x ]; } else { b [ p [ x ]] = b [ p [ root ]] + 1 ; Out [ p [ x ]] = Out [ p [ root ]]; In [ p [ x ]] = p [ root ]; } } x = p [ x ]; for ( int i = x + 1 ; i <= n && ( i - 1 ) / block == ( x - 1 ) / block ; ++ i ) { if ( In [ i ] != i ) { b [ i ] = b [ In [ i ]] + 1 ; Out [ i ] = Out [ In [ i ]]; } } } void Run () { read ( t ); while ( t -- ) { read ( n ); Init (); for ( int i = 2 ; i <= n ; ++ i ) { read ( fa [ i ][ 0 ]); G [ fa [ i ][ 0 ]]. push_back ( i ); } DFS ( 1 ); for ( int i = 1 ; i <= n ; ++ i ) read ( a [ i ]); for ( int i = 1 ; i <= n ; ++ i ) { int x = fp [ i ]; if ( a [ x ] > deep [ x ]) { b [ i ] = 1 ; Out [ i ] = 0 ; In [ i ] = i ; continue ; } int root = GetK ( x , a [ x ]); if (( p [ root ] - 1 ) / block != ( i - 1 ) / block ) { b [ i ] = 1 ; Out [ i ] = p [ root ]; In [ i ] = i ; } else { b [ i ] = b [ p [ root ]] + 1 ; Out [ i ] = Out [ p [ root ]]; In [ i ] = p [ root ]; } } read ( q ); for ( int i = 1 , op , x , v ; i <= q ; ++ i ) { read ( op ); read ( x ); if ( op == 1 ) print ( query ( x )); else { read ( v ); a [ x ] = v ; update ( x ); } } } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; } J. Sequence \u9898\u610f\uff1a \u6c42\uff1a F_n = C * F_{n - 2} + D * F_{n - 1} + \\lfloor{\\frac {p}{n}}\\rfloor F_n = C * F_{n - 2} + D * F_{n - 1} + \\lfloor{\\frac {p}{n}}\\rfloor \u601d\u8def\uff1a \u8003\u8651\u6700\u540e\u4e00\u9879\u6700\u591a\u6709 \\sqrt n \\sqrt n \u9879\uff0c\u6309\u8fd9\u4e2a\u503c\u5206\u5757\u77e9\u9635\u5feb\u901f\u5e42\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define ll long long const ll MOD = ( ll ) 1e9 + 7 ; int t , n ; ll A , B , C , D , P ; ll Biner ( ll x ) { ll l = x , r = n , res = l ; x = P / x ; while ( r - l >= 0 ) { ll mid = ( l + r ) >> 1 ; ll tmp = P / mid ; if ( tmp >= x ) { l = mid + 1 ; res = mid ; } else r = mid - 1 ; } return res ; } struct node { ll a [ 3 ][ 3 ]; node () { memset ( a , 0 , sizeof a ); } node operator * ( const node & r ) const { node ans = node (); for ( int i = 0 ; i < 3 ; ++ i ) for ( int j = 0 ; j < 3 ; ++ j ) for ( int k = 0 ; k < 3 ; ++ k ) ans . a [ i ][ j ] = ( ans . a [ i ][ j ] + a [ i ][ k ] * r . a [ k ][ j ] % MOD ) % MOD ; return ans ; } } base ; node qmod ( node base , int n ) { node res = node (); res . a [ 0 ][ 0 ] = B , res . a [ 0 ][ 1 ] = A ; res . a [ 0 ][ 2 ] = 1 ; while ( n ) { if ( n & 1 ) res = res * base ; base = base * base ; n >>= 1 ; } return res ; } ll work () { if ( n == 1 ) return A ; if ( n == 2 ) return B ; int l = 3 , r ; while ( l <= n ) { r = Biner ( l ); base . a [ 2 ][ 0 ] = P / l ; node res = qmod ( base , r - l + 1 ); B = res . a [ 0 ][ 0 ], A = res . a [ 0 ][ 1 ]; l = r + 1 ; } return B ; } int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%lld%lld%lld%lld%lld%d\" , & A , & B , & C , & D , & P , & n ); memset ( base . a , 0 , sizeof base . a ); base . a [ 0 ][ 0 ] = D , base . a [ 1 ][ 0 ] = C , base . a [ 0 ][ 1 ] = 1 ; base . a [ 2 ][ 2 ] = 1 ; printf ( \"%lld \\n \" , work ()); } return 0 ; } K. Swordsman \u9898\u610f\uff1a \u6709\u4e94\u79cd\u653b\u51fb\u5c5e\u6027\uff0c\u602a\u7269\u6709\u4e94\u79cd\u9632\u5fa1\u5c5e\u6027\uff0c\u6240\u6709\u653b\u51fb\u5c5e\u6027\u8981\u5927\u4e8e\u5176\u5bf9\u5e94\u7684\u9632\u5fa1\u5c5e\u6027\u4fbf\u80fd\u5c06\u5176\u51fb\u6740\uff0c\u51fb\u6740\u540e\u6709\u7ecf\u9a8c\u52a0\u6210\uff0c\u6c42\u6700\u591a\u6740\u6b7b\u591a\u5c11\u602a\u7269\u3002 \u601d\u8def\uff1a \u7528 5 5 \u4e2a set \u4f9d\u6b21\u7ef4\u62a4\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; namespace FastIO { #define BUF_SIZE 10000005 bool IOerror = false ; inline char NC () { static char buf [ BUF_SIZE ], * p1 = buf + BUF_SIZE , * pend = buf + BUF_SIZE ; if ( p1 == pend ) { p1 = buf ; pend = buf + fread ( buf , 1 , BUF_SIZE , stdin ); if ( pend == p1 ) { IOerror = true ; return -1 ; } } return * p1 ++ ; } inline bool blank ( char ch ) { return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t' ; } template < typename T > inline void read ( T & x ) { char ch ; while ( blank ( ch = NC ())) ; if ( IOerror ) { x = -1 ; return ; } bool flag = false ; if ( ch == '-' ) { flag = true ; ch = NC (); } if ( ! isdigit ( ch )) while ( ! isdigit ( ch = NC ())) ; for ( x = ch - '0' ; isdigit ( ch = NC ()); x = x * 10 + ch - '0' ) ; if ( flag ) x *= -1 ; } #undef BUF_SIZE } // namespace FastIO using namespace FastIO ; const int maxn = 1e5 + 10 ; struct node { int id ; int v ; node () {} node ( int id , int v ) : id ( id ), v ( v ) {} bool operator < ( const node & r ) const { return v > r . v ; } }; priority_queue < node > q [ 10 ]; int n , k ; int ans [ maxn ]; int arr [ maxn ][ 20 ]; int main () { int t ; read ( t ); while ( t -- ) { read ( n ), read ( k ); for ( int i = 1 ; i <= k ; ++ i ) while ( ! q [ i ]. empty ()) q [ i ]. pop (); for ( int i = 1 ; i <= k ; ++ i ) read ( ans [ i ]); for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= ( k * 2 ); ++ j ) { read ( arr [ i ][ j ]); } q [ 1 ]. push ( node ( i , arr [ i ][ 1 ])); } int cnt = 0 ; while ( 1 ) { bool flag = false ; for ( int i = 1 ; i <= k ; ++ i ) { while ( ! q [ i ]. empty ()) { node tmp = q [ i ]. top (); if ( tmp . v <= ans [ i ]) { if ( i == k ) { cnt ++ ; flag = true ; for ( int j = 1 ; j <= k ; ++ j ) ans [ j ] += arr [ tmp . id ][ j + k ]; } else { tmp . v = arr [ tmp . id ][ i + 1 ]; q [ i + 1 ]. push ( tmp ); } q [ i ]. pop (); } else break ; } } if ( ! flag ) break ; } printf ( \"%d \\n \" , cnt ); for ( int i = 1 ; i <= k ; ++ i ) printf ( \"%d%c\" , ans [ i ], \" \\n \" [ i == k ]); } return 0 ; }","title":"2018 Multi-University Training Contest 7"},{"location":"trainings/2018-Multi-University-Trainings/Contest-7/#a-age-of-moyu","text":"\u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u5f20\u56fe\uff0c\u4ece 1 1 \u8d70\u5230 n n \uff0c\u5982\u679c\u76f8\u90bb\u4e24\u6b21\u8d70\u7684\u8fb9\u7684\u6743\u503c\u4e0d\u540c\uff0c\u82b1\u8d39 +1 +1 \uff0c\u5426\u5219\u82b1\u8d39\u76f8\u540c\uff0c\u6c42\u6700\u5c0f\u82b1\u8d39\u3002 \u601d\u8def\uff1a \u7528 set \u8bb0\u5f55\u6709\u5f53\u524d\u70b9\u7684\u6700\u5c0f\u82b1\u8d39\u6709\u591a\u5c11\u79cd\u65b9\u6848\u5230\u8fbe\uff0c\u7136\u540e\u6700\u77ed\u8def\u3002 Code #include <bits/stdc++.h> using namespace std ; const int INF = 0x3f3f3f3f ; const int maxn = 2e5 + 10 ; struct Edge { int to , nxt , val ; Edge () {} Edge ( int to , int nxt , int val ) : to ( to ), nxt ( nxt ), val ( val ){}; } edge [ maxn << 1 ]; set < int > s [ maxn ]; int head [ maxn ], tot ; void Init ( int n ) { for ( int i = 0 ; i <= n ; ++ i ) head [ i ] = -1 , s [ i ]. clear (); tot = 0 ; } void addedge ( int u , int v , int val ) { edge [ tot ] = Edge ( v , head [ u ], val ); head [ u ] = tot ++ ; } struct qnode { int v , c ; int pre ; int fa ; qnode () {} qnode ( int v , int c , int pre , int fa ) : v ( v ), c ( c ), pre ( pre ), fa ( fa ) {} bool operator < ( const qnode & r ) const { return c > r . c ; } }; int n , m ; int dist [ maxn ]; void BFS ( int st ) { for ( int i = 1 ; i <= n ; ++ i ) dist [ i ] = INF ; priority_queue < qnode > q ; dist [ st ] = 0 ; q . push ( qnode ( st , 0 , 0 , 0 )); while ( ! q . empty ()) { qnode tmp = q . top (); q . pop (); int u = tmp . v ; if ( tmp . c > dist [ u ]) continue ; else if ( tmp . c == dist [ u ]) { if ( s [ u ]. find ( tmp . pre ) != s [ u ]. end ()) continue ; s [ u ]. insert ( tmp . pre ); } else { dist [ u ] = tmp . c ; s [ u ]. clear (); s [ u ]. insert ( tmp . pre ); } for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { int v = edge [ i ]. to ; int cost = edge [ i ]. val ; if ( v == tmp . fa ) continue ; if ( dist [ u ] + ( cost != tmp . pre ) <= dist [ v ]) { dist [ v ] = dist [ u ] + ( cost != tmp . pre ); if ( v != n ) { q . push ( qnode ( v , dist [ v ], cost , u )); } } } } } int main () { int t ; while ( scanf ( \"%d %d\" , & n , & m ) != EOF ) { Init ( n ); for ( int i = 1 ; i <= m ; ++ i ) { int u , v , w ; scanf ( \"%d %d %d\" , & u , & v , & w ); addedge ( u , v , w ); addedge ( v , u , w ); } BFS ( 1 ); if ( dist [ n ] == INF ) dist [ n ] = -1 ; printf ( \"%d \\n \" , dist [ n ]); } return 0 ; }","title":"A. Age of Moyu"},{"location":"trainings/2018-Multi-University-Trainings/Contest-7/#b-arabellac","text":"\u7559\u5751\u3002","title":"B. AraBellaC"},{"location":"trainings/2018-Multi-University-Trainings/Contest-7/#c-yjjs-stack","text":"\u7559\u5751\u3002","title":"C. YJJ\u2019s Stack"},{"location":"trainings/2018-Multi-University-Trainings/Contest-7/#d-go-to-school","text":"\u7559\u5751\u3002","title":"D. Go to school"},{"location":"trainings/2018-Multi-University-Trainings/Contest-7/#e-gugufishtion","text":"\u7559\u5751\u3002","title":"E. GuGuFishtion"},{"location":"trainings/2018-Multi-University-Trainings/Contest-7/#f-lord-lis-problem","text":"\u7559\u5751\u3002","title":"F. Lord Li's problem"},{"location":"trainings/2018-Multi-University-Trainings/Contest-7/#g-reverse-game","text":"\u7559\u5751\u3002","title":"G. Reverse Game"},{"location":"trainings/2018-Multi-University-Trainings/Contest-7/#h-traffic-network-in-numazu","text":"\u9898\u610f\uff1a \u4e24\u79cd\u64cd\u4f5c\uff1a \u7b2c\u4e00\u79cd\u662f\u66f4\u6539\u4e00\u6761\u8fb9\u6743\u7684\u503c\u3002 \u7b2c\u4e8c\u79cd\u662f\u67e5\u8be2 x \\rightarrow y x \\rightarrow y \u7684\u6700\u77ed\u8def\u5f84\u3002 \u7ed9\u51fa\u7684\u662f\u4e00\u9897\u6811\u52a0\u4e00\u6761\u8fb9\u3002 \u601d\u8def\uff1a \u5c06\u5f62\u6210\u73af\u7684\u8fb9\u5355\u72ec\u62ff\u51fa\u6765\u8003\u8651\u3002 \u90a3\u4e48\u8003\u8651\u662f\u5426\u7ecf\u8fc7\u8fd9\u6761\u8fb9\u4f7f\u5f97\u7b54\u6848\u66f4\u4f18\u3002 \u4fee\u6539\u64cd\u4f5c\u7528\u7ebf\u6bb5\u6811\u6216\u8005\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int maxn = 1e5 + 10 ; const int DEG = 20 ; struct EDGE { int u , v , w ; } EDGE [ maxn ], TEMP ; struct Edge { int to , nxt , val ; Edge () {} Edge ( int to , int nxt , int val ) : to ( to ), nxt ( nxt ), val ( val ) {} } edge [ maxn << 1 ]; int head [ maxn ], tot , cnt ; int father [ maxn ]; void Init ( int n ) { for ( int i = 0 ; i <= n ; ++ i ) head [ i ] = -1 , father [ i ] = i ; tot = cnt = 0 ; } int find ( int x ) { return x == father [ x ] ? father [ x ] : father [ x ] = find ( father [ x ]); } void mix ( int x , int y ) { x = find ( x ), y = find ( y ); if ( x != y ) father [ x ] = y ; } bool same ( int x , int y ) { return find ( x ) == find ( y ); } void addedge ( int u , int v , int val ) { edge [ tot ] = Edge ( v , head [ u ], val ); head [ u ] = tot ++ ; } int dro [ maxn ]; int ord [ maxn ], son [ maxn ]; int fa [ maxn ][ DEG ]; int deg [ maxn ]; void DFS ( int u , int pre ) { ord [ u ] = ++ cnt ; dro [ cnt ] = u ; for ( int i = 1 ; i < DEG ; ++ i ) fa [ u ][ i ] = fa [ fa [ u ][ i - 1 ]][ i - 1 ]; for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { int v = edge [ i ]. to ; if ( v == pre ) continue ; fa [ v ][ 0 ] = u ; deg [ v ] = deg [ u ] + 1 ; DFS ( v , u ); } son [ u ] = cnt ; } int LCA ( int u , int v ) { if ( deg [ u ] > deg [ v ]) swap ( u , v ); int hu = deg [ u ], hv = deg [ v ]; int tu = u , tv = v ; for ( int det = hv - hu , i = 0 ; det ; det >>= 1 , ++ i ) { if ( det & 1 ) { tv = fa [ tv ][ i ]; } } if ( tu == tv ) return tu ; for ( int i = DEG - 1 ; i >= 0 ; -- i ) { if ( fa [ tu ][ i ] == fa [ tv ][ i ]) continue ; tu = fa [ tu ][ i ]; tv = fa [ tv ][ i ]; } return fa [ tu ][ 0 ]; } struct node { int l , r ; ll val , lazy ; node () {} node ( int l , int r , ll val , ll lazy ) : l ( l ), r ( r ), val ( val ), lazy ( lazy ) {} } tree [ maxn << 2 ]; void pushup ( int id ) { tree [ id ]. val = tree [ id << 1 ]. val + tree [ id << 1 | 1 ]. val ; } void pushdown ( int id ) { if ( tree [ id ]. lazy ) { ll lazy = tree [ id ]. lazy ; tree [ id << 1 ]. val += lazy ; tree [ id << 1 | 1 ]. val += lazy ; tree [ id << 1 ]. lazy += lazy ; tree [ id << 1 | 1 ]. lazy += lazy ; tree [ id ]. lazy = 0 ; } } void build ( int id , int l , int r ) { tree [ id ] = node ( l , r , 0 , 0 ); if ( l == r ) return ; int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); } void update ( int id , int l , int r , ll val ) { if ( l <= tree [ id ]. l && r >= tree [ id ]. r ) { tree [ id ]. val += val ; tree [ id ]. lazy += val ; return ; } pushdown ( id ); int mid = ( tree [ id ]. l + tree [ id ]. r ) >> 1 ; if ( mid >= l ) update ( id << 1 , l , r , val ); if ( r > mid ) update ( id << 1 | 1 , l , r , val ); pushup ( id ); } ll query ( int id , int pos ) { if ( tree [ id ]. l == pos && tree [ id ]. r == pos ) { return tree [ id ]. val ; } pushdown ( id ); int mid = ( tree [ id ]. l + tree [ id ]. r ) >> 1 ; if ( pos <= mid ) return query ( id << 1 , pos ); if ( pos > mid ) return query ( id << 1 | 1 , pos ); pushup ( id ); } ll getdis ( int u , int v ) { int root = LCA ( u , v ); return query ( 1 , ord [ u ]) + query ( 1 , ord [ v ]) - 2 * query ( 1 , ord [ root ]); } int n , q ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d\" , & n , & q ); Init ( n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d %d %d\" , & EDGE [ i ]. u , & EDGE [ i ]. v , & EDGE [ i ]. w ); int u = EDGE [ i ]. u , v = EDGE [ i ]. v , w = EDGE [ i ]. w ; if ( same ( u , v )) { TEMP = EDGE [ i ]; continue ; } mix ( u , v ); addedge ( u , v , w ); addedge ( v , u , w ); } fa [ 1 ][ 0 ] = 1 ; deg [ 1 ] = 0 ; DFS ( 1 , -1 ); build ( 1 , 1 , n ); for ( int i = 1 ; i <= n ; ++ i ) { int u = EDGE [ i ]. u , v = EDGE [ i ]. v , w = EDGE [ i ]. w ; if ( u == TEMP . u && v == TEMP . v ) continue ; if ( fa [ u ][ 0 ] == v ) { update ( 1 , ord [ u ], son [ u ], w ); } else if ( fa [ v ][ 0 ] == u ) ; { update ( 1 , ord [ v ], son [ v ], w ); } } // for(int i = 1; i <= n; ++i) cout << ord[i] << endl; // for(int i = 1; i <= n; ++i) cout << i << \" \" << query(1, ord[i]) << endl; while ( q -- ) { int op , x , y ; scanf ( \"%d %d %d\" , & op , & x , & y ); if ( op == 0 ) { int u = EDGE [ x ]. u , v = EDGE [ x ]. v , w = EDGE [ x ]. w ; if ( u == TEMP . u && v == TEMP . v ) { EDGE [ x ]. w = y ; TEMP . w = y ; } if ( fa [ u ][ 0 ] == v ) { update ( 1 , ord [ u ], son [ u ], y - w ); } else if ( fa [ v ][ 0 ] == u ) { update ( 1 , ord [ v ], son [ v ], y - w ); } EDGE [ x ]. w = y ; } else if ( op == 1 ) { ll ans = getdis ( x , y ); ans = min ( ans , getdis ( x , TEMP . u ) + TEMP . w + getdis ( y , TEMP . v )); ans = min ( ans , getdis ( y , TEMP . u ) + TEMP . w + getdis ( x , TEMP . v )); printf ( \"%lld \\n \" , ans ); } } } return 0 ; }","title":"H. Traffic Network in Numazu"},{"location":"trainings/2018-Multi-University-Trainings/Contest-7/#i-tree","text":"\u9898\u610f\uff1a \u4e00\u68f5\u6811\u79cd\uff0c\u6bcf\u4e2a\u70b9\u6709\u4e00\u4e2a\u6743\u503c\uff0c\u8868\u793a\u53ef\u4ee5\u5411\u4e0a\u8df3\u51e0\u6b65\uff0c\u4e24\u79cd\u64cd\u4f5c\uff0c\u4e00\u79cd\u662f\u4fee\u6539\u67d0\u70b9\u6743\u503c\uff0c\u8fd8\u6709\u4e00\u79cd\u662f\u8be2\u95ee\u67d0\u4e2a\u70b9\u9700\u8981\u8df3\u51e0\u6b21\u8df3\u51fa\u3002 \u601d\u8def\uff1a DFS \u5e8f\u5206\u5757\uff0c\u5f39\u98de\u7ef5\u9633\u5347\u7ea7\u7248\uff0c\u6ce8\u610f\u66f4\u65b0\u7684\u65f6\u5019\uff0c\u7ef4\u62a4\u4e00\u4e2a In[u] In[u] \u8868\u793a\u6700\u8fdc\u8df3\u5230\u5757\u5185\u662f\u7b2c\u51e0\u5757\uff0c\u8fd9\u6837\u5c31\u4e0d\u7528\u591a\u4e00\u4e2a log log \u590d\u6742\u5ea6\u3002 Code #include <bits/stdc++.h> using namespace std ; namespace FastIO { #define BUF_SIZE 10000005 bool IOerror = false ; inline char NC () { static char buf [ BUF_SIZE ], * p1 = buf + BUF_SIZE , * pend = buf + BUF_SIZE ; if ( p1 == pend ) { p1 = buf ; pend = buf + fread ( buf , 1 , BUF_SIZE , stdin ); if ( pend == p1 ) { IOerror = true ; return -1 ; } } return * p1 ++ ; } inline bool blank ( char ch ) { return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t' ; } template < typename T > inline void read ( T & x ) { char ch ; while ( blank ( ch = NC ())) ; if ( IOerror ) { x = -1 ; return ; } bool flag = false ; if ( ch == '-' ) { flag = true ; ch = NC (); } if ( ! isdigit ( ch )) while ( ! isdigit ( ch = NC ())) ; for ( x = ch - '0' ; isdigit ( ch = NC ()); x = x * 10 + ch - '0' ) ; if ( flag ) x *= -1 ; } void out ( int x ) { if ( x / 10 ) out ( x / 10 ); putchar ( x % 10 + '0' ); } inline void print ( int x ) { out ( x ); puts ( \"\" ); } #undef BUF_SIZE } // namespace FastIO using namespace FastIO ; #define N 100010 #define DEG 20 #define block 400 int t , n , q ; int a [ N ], b [ N ], In [ N ], Out [ N ], fa [ N ][ 20 ], deep [ N ], p [ N ], fp [ N ], cnt ; vector < int > G [ N ]; void Init () { for ( int i = 1 ; i <= n ; ++ i ) G [ i ]. clear (); cnt = 0 ; fa [ 1 ][ 0 ] = 1 ; deep [ 1 ] = 0 ; } void DFS ( int u ) { p [ u ] = ++ cnt ; fp [ cnt ] = u ; for ( int i = 1 ; i < DEG ; ++ i ) fa [ u ][ i ] = fa [ fa [ u ][ i - 1 ]][ i - 1 ]; for ( auto v : G [ u ]) if ( v != fa [ u ][ 0 ]) { deep [ v ] = deep [ u ] + 1 ; DFS ( v ); } } int GetK ( int x , int k ) { bitset < 20 > b ; b = k ; for ( int i = 19 ; i >= 0 ; -- i ) if ( b [ i ]) x = fa [ x ][ i ]; return x ; } int query ( int x ) { int res = 0 ; x = p [ x ]; while ( x ) { res += b [ x ]; x = Out [ x ]; } return res ; } void update ( int x ) { if ( a [ x ] > deep [ x ]) { b [ p [ x ]] = 1 ; Out [ p [ x ]] = 0 ; In [ p [ x ]] = p [ x ]; } else { int root = GetK ( x , a [ x ]); if (( p [ root ] - 1 ) / block != ( p [ x ] - 1 ) / block ) { b [ p [ x ]] = 1 ; Out [ p [ x ]] = p [ root ]; In [ p [ x ]] = p [ x ]; } else { b [ p [ x ]] = b [ p [ root ]] + 1 ; Out [ p [ x ]] = Out [ p [ root ]]; In [ p [ x ]] = p [ root ]; } } x = p [ x ]; for ( int i = x + 1 ; i <= n && ( i - 1 ) / block == ( x - 1 ) / block ; ++ i ) { if ( In [ i ] != i ) { b [ i ] = b [ In [ i ]] + 1 ; Out [ i ] = Out [ In [ i ]]; } } } void Run () { read ( t ); while ( t -- ) { read ( n ); Init (); for ( int i = 2 ; i <= n ; ++ i ) { read ( fa [ i ][ 0 ]); G [ fa [ i ][ 0 ]]. push_back ( i ); } DFS ( 1 ); for ( int i = 1 ; i <= n ; ++ i ) read ( a [ i ]); for ( int i = 1 ; i <= n ; ++ i ) { int x = fp [ i ]; if ( a [ x ] > deep [ x ]) { b [ i ] = 1 ; Out [ i ] = 0 ; In [ i ] = i ; continue ; } int root = GetK ( x , a [ x ]); if (( p [ root ] - 1 ) / block != ( i - 1 ) / block ) { b [ i ] = 1 ; Out [ i ] = p [ root ]; In [ i ] = i ; } else { b [ i ] = b [ p [ root ]] + 1 ; Out [ i ] = Out [ p [ root ]]; In [ i ] = p [ root ]; } } read ( q ); for ( int i = 1 , op , x , v ; i <= q ; ++ i ) { read ( op ); read ( x ); if ( op == 1 ) print ( query ( x )); else { read ( v ); a [ x ] = v ; update ( x ); } } } } int main () { #ifdef LOCAL freopen ( \"Test.in\" , \"r\" , stdin ); #endif Run (); return 0 ; }","title":"I. Tree"},{"location":"trainings/2018-Multi-University-Trainings/Contest-7/#j-sequence","text":"\u9898\u610f\uff1a \u6c42\uff1a F_n = C * F_{n - 2} + D * F_{n - 1} + \\lfloor{\\frac {p}{n}}\\rfloor F_n = C * F_{n - 2} + D * F_{n - 1} + \\lfloor{\\frac {p}{n}}\\rfloor \u601d\u8def\uff1a \u8003\u8651\u6700\u540e\u4e00\u9879\u6700\u591a\u6709 \\sqrt n \\sqrt n \u9879\uff0c\u6309\u8fd9\u4e2a\u503c\u5206\u5757\u77e9\u9635\u5feb\u901f\u5e42\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define ll long long const ll MOD = ( ll ) 1e9 + 7 ; int t , n ; ll A , B , C , D , P ; ll Biner ( ll x ) { ll l = x , r = n , res = l ; x = P / x ; while ( r - l >= 0 ) { ll mid = ( l + r ) >> 1 ; ll tmp = P / mid ; if ( tmp >= x ) { l = mid + 1 ; res = mid ; } else r = mid - 1 ; } return res ; } struct node { ll a [ 3 ][ 3 ]; node () { memset ( a , 0 , sizeof a ); } node operator * ( const node & r ) const { node ans = node (); for ( int i = 0 ; i < 3 ; ++ i ) for ( int j = 0 ; j < 3 ; ++ j ) for ( int k = 0 ; k < 3 ; ++ k ) ans . a [ i ][ j ] = ( ans . a [ i ][ j ] + a [ i ][ k ] * r . a [ k ][ j ] % MOD ) % MOD ; return ans ; } } base ; node qmod ( node base , int n ) { node res = node (); res . a [ 0 ][ 0 ] = B , res . a [ 0 ][ 1 ] = A ; res . a [ 0 ][ 2 ] = 1 ; while ( n ) { if ( n & 1 ) res = res * base ; base = base * base ; n >>= 1 ; } return res ; } ll work () { if ( n == 1 ) return A ; if ( n == 2 ) return B ; int l = 3 , r ; while ( l <= n ) { r = Biner ( l ); base . a [ 2 ][ 0 ] = P / l ; node res = qmod ( base , r - l + 1 ); B = res . a [ 0 ][ 0 ], A = res . a [ 0 ][ 1 ]; l = r + 1 ; } return B ; } int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%lld%lld%lld%lld%lld%d\" , & A , & B , & C , & D , & P , & n ); memset ( base . a , 0 , sizeof base . a ); base . a [ 0 ][ 0 ] = D , base . a [ 1 ][ 0 ] = C , base . a [ 0 ][ 1 ] = 1 ; base . a [ 2 ][ 2 ] = 1 ; printf ( \"%lld \\n \" , work ()); } return 0 ; }","title":"J. Sequence"},{"location":"trainings/2018-Multi-University-Trainings/Contest-7/#k-swordsman","text":"\u9898\u610f\uff1a \u6709\u4e94\u79cd\u653b\u51fb\u5c5e\u6027\uff0c\u602a\u7269\u6709\u4e94\u79cd\u9632\u5fa1\u5c5e\u6027\uff0c\u6240\u6709\u653b\u51fb\u5c5e\u6027\u8981\u5927\u4e8e\u5176\u5bf9\u5e94\u7684\u9632\u5fa1\u5c5e\u6027\u4fbf\u80fd\u5c06\u5176\u51fb\u6740\uff0c\u51fb\u6740\u540e\u6709\u7ecf\u9a8c\u52a0\u6210\uff0c\u6c42\u6700\u591a\u6740\u6b7b\u591a\u5c11\u602a\u7269\u3002 \u601d\u8def\uff1a \u7528 5 5 \u4e2a set \u4f9d\u6b21\u7ef4\u62a4\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; namespace FastIO { #define BUF_SIZE 10000005 bool IOerror = false ; inline char NC () { static char buf [ BUF_SIZE ], * p1 = buf + BUF_SIZE , * pend = buf + BUF_SIZE ; if ( p1 == pend ) { p1 = buf ; pend = buf + fread ( buf , 1 , BUF_SIZE , stdin ); if ( pend == p1 ) { IOerror = true ; return -1 ; } } return * p1 ++ ; } inline bool blank ( char ch ) { return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t' ; } template < typename T > inline void read ( T & x ) { char ch ; while ( blank ( ch = NC ())) ; if ( IOerror ) { x = -1 ; return ; } bool flag = false ; if ( ch == '-' ) { flag = true ; ch = NC (); } if ( ! isdigit ( ch )) while ( ! isdigit ( ch = NC ())) ; for ( x = ch - '0' ; isdigit ( ch = NC ()); x = x * 10 + ch - '0' ) ; if ( flag ) x *= -1 ; } #undef BUF_SIZE } // namespace FastIO using namespace FastIO ; const int maxn = 1e5 + 10 ; struct node { int id ; int v ; node () {} node ( int id , int v ) : id ( id ), v ( v ) {} bool operator < ( const node & r ) const { return v > r . v ; } }; priority_queue < node > q [ 10 ]; int n , k ; int ans [ maxn ]; int arr [ maxn ][ 20 ]; int main () { int t ; read ( t ); while ( t -- ) { read ( n ), read ( k ); for ( int i = 1 ; i <= k ; ++ i ) while ( ! q [ i ]. empty ()) q [ i ]. pop (); for ( int i = 1 ; i <= k ; ++ i ) read ( ans [ i ]); for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= ( k * 2 ); ++ j ) { read ( arr [ i ][ j ]); } q [ 1 ]. push ( node ( i , arr [ i ][ 1 ])); } int cnt = 0 ; while ( 1 ) { bool flag = false ; for ( int i = 1 ; i <= k ; ++ i ) { while ( ! q [ i ]. empty ()) { node tmp = q [ i ]. top (); if ( tmp . v <= ans [ i ]) { if ( i == k ) { cnt ++ ; flag = true ; for ( int j = 1 ; j <= k ; ++ j ) ans [ j ] += arr [ tmp . id ][ j + k ]; } else { tmp . v = arr [ tmp . id ][ i + 1 ]; q [ i + 1 ]. push ( tmp ); } q [ i ]. pop (); } else break ; } } if ( ! flag ) break ; } printf ( \"%d \\n \" , cnt ); for ( int i = 1 ; i <= k ; ++ i ) printf ( \"%d%c\" , ans [ i ], \" \\n \" [ i == k ]); } return 0 ; }","title":"K. Swordsman"},{"location":"trainings/2018-Multi-University-Trainings/Contest-8/","text":"2018 Multi-University Training Contest 8 Contents A. Character Encoding B. Pizza Hub C. City Development D. Parentheses Matrix E. Magic Square F. Boolean 3-Array G. Card Game H. K-Similar Strings I. Make ZYB Happy J. Taotao Picks Apples K. Pop the Balloons L. From ICPC to ACM A. Character Encoding \u9898\u610f\uff1a \u7528 m m \u4e2a [0,n-1] [0,n-1] \u7684\u6570\u53bb\u6784\u6210 k k \uff0c\u6c42\u65b9\u6848\u6570\u3002 \u601d\u8def\uff1a \u5f53\u6ca1\u6709 [0,n-1] [0,n-1] \u8fd9\u4e2a\u6761\u4ef6\u662f\u7b54\u6848\u4e3a C(k+m-1, m-1) C(k+m-1, m-1) \u3002 \u51cf\u53bb\u6709\u5927\u4e8e\u7684\u5173\u4e8e n n \u7684\u60c5\u51b5\uff0c\u5f53\u6709 i i \u4e2a n n \u65f6\u7684\u79cd\u7c7b\u4e3a C(k+m-1-i \\cdot n,m-1) C(k+m-1-i \\cdot n,m-1) \u4e2a\uff0c\u5229\u7528\u5bb9\u65a5\u5b9a\u7406\u53ef\u5f97\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int MOD = 998244353 ; const int maxn = 1e6 + 10 ; ll fac [ maxn ]; ll inv [ maxn ]; ll invfac [ maxn ]; void Init () { fac [ 0 ] = inv [ 0 ] = invfac [ 0 ] = 1 ; fac [ 1 ] = inv [ 1 ] = invfac [ 1 ] = 1 ; for ( int i = 2 ; i < maxn ; ++ i ) { fac [ i ] = fac [ i - 1 ] * i % MOD ; inv [ i ] = inv [ MOD % i ] * ( MOD - MOD / i ) % MOD ; invfac [ i ] = invfac [ i - 1 ] * inv [ i ] % MOD ; } } ll calc ( ll n , ll m ) { if ( m > n || m < 0 || n < 0 ) return 0 ; return fac [ n ] * invfac [ m ] % MOD * invfac [ n - m ] % MOD ; } int n , m , k ; int main () { Init (); int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d %d\" , & n , & m , & k ); ll ans = 0 ; for ( int i = 0 ; i <= m ; ++ i ) { ll tmp = k - 1l l * i * n + m - 1 ; if ( tmp < 0 ) break ; if ( i & 1 ) ans = ( ans - calc ( m , i ) * calc ( tmp , m - 1 ) % MOD + MOD ) % MOD ; else ans = ( ans + calc ( m , i ) * calc ( tmp , m - 1 ) % MOD ) % MOD ; // cout << i << \" \" << m << \" \" << calc(m, i); // cout << tmp << \" \" << m - 1 << \" \" << calc(tmp, m - 1) << endl; } printf ( \"%lld \\n \" , ans ); } return 0 ; } B. Pizza Hub \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u4e09\u89d2\u5f62\uff0c\u4ee5\u53ca\u4e00\u4e2a\u77e9\u5f62\u7684\u5bbd\u5ea6\uff0c\u6c42\u4e00\u4e2a\u6700\u5c0f\u7684\u9ad8\u5ea6\u4f7f\u5f97\u77e9\u5f62\u80fd\u591f\u8986\u76d6\u4e09\u89d2\u5f62\u3002 \u601d\u8def\uff1a \u663e\u7136\u4e00\u5b9a\u6709\u4e00\u4e2a\u70b9\u5728\u77e9\u5f62\u7684\u9876\u70b9\uff0c\u679a\u4e3e\u8ba1\u7b97\u5373\u53ef Code #include <bits/stdc++.h> using namespace std ; const int INF = 0x3f3f3f3f ; const double PI = acos ( -1.0 ); const double eps = 1e-8 ; const int maxn = 1e2 ; int sgn ( double x ) { if ( fabs ( x ) < eps ) return 0 ; else return x > 0 ? 1 : -1 ; } struct Point { double x , y ; Point () {} Point ( double _x , double _y ) { x = _x ; y = _y ; } void input () { scanf ( \"%lf %lf\" , & x , & y ); } Point operator - ( const Point & b ) const { return Point ( x - b . x , y - b . y ); } double operator ^ ( const Point & b ) const { return x * b . y - y * b . x ; } double distance ( Point p ) { return hypot ( x - p . x , y - p . y ); } double len () { return hypot ( x , y ); } double operator * ( const Point & b ) const { return x * b . x + y * b . y ; } } P [ maxn ]; int w ; double ans ; double area ; void calc ( Point a , Point b ) // low high { if ( sgn ( a * b ) < 0 ) return ; if ( sgn ( a * a - w * w ) <= 0 ) { if ( sgn ( a ^ b ) < 0 ) return ; if ( sgn (( a * b ) * ( a * b ) - w * w * ( a * a )) > 0 ) return ; ans = min ( ans , ( a ^ b ) / sqrt ( a * a )); } else { double h = sqrt ( a * a - w * w ); double src1 = atan ( h / w ); if ( sgn ( a ^ b ) >= 0 ) { double src2 = acos (( a * b ) / ( sqrt ( a * a ) * sqrt ( b * b ))); if ( sgn ( src1 + src2 - PI / 2 ) > 0 ) return ; double len1 = sqrt ( b * b ) * cos ( src1 + src2 ); if ( sgn ( len1 - w ) > 0 ) return ; ans = min ( ans , max ( h , sqrt ( b * b ) * sin ( src1 + src2 ))); } else { double src2 = acos (( a * b ) / ( sqrt ( a * a ) * sqrt ( b * b ))); if ( sgn ( src1 - src2 ) < 0 ) return ; double len1 = sqrt ( b * b ) * cos ( src1 - src2 ); if ( sgn ( len1 - w ) > 0 ) return ; ans = min ( ans , h ); } } } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { for ( int i = 1 ; i <= 3 ; ++ i ) P [ i ]. input (); // double a = p[1].distance(p[2]); // double b = p[2].distance(p[3]); // double c = p[3].distance(p[1]); // double p = (a + b + c) / 2.0; // area = sqrt(p * (p - a) * (p - b) * (p - c)); ans = INF * 1.0 ; scanf ( \"%d\" , & w ); calc ( P [ 2 ] - P [ 1 ], P [ 3 ] - P [ 1 ]); calc ( P [ 3 ] - P [ 1 ], P [ 2 ] - P [ 1 ]); calc ( P [ 1 ] - P [ 2 ], P [ 3 ] - P [ 2 ]); calc ( P [ 3 ] - P [ 2 ], P [ 1 ] - P [ 2 ]); calc ( P [ 1 ] - P [ 3 ], P [ 2 ] - P [ 3 ]); calc ( P [ 2 ] - P [ 3 ], P [ 1 ] - P [ 3 ]); for ( int i = 1 ; i <= 3 ; ++ i ) P [ i ]. y *= -1.0 ; calc ( P [ 2 ] - P [ 1 ], P [ 3 ] - P [ 1 ]); calc ( P [ 3 ] - P [ 1 ], P [ 2 ] - P [ 1 ]); calc ( P [ 1 ] - P [ 2 ], P [ 3 ] - P [ 2 ]); calc ( P [ 3 ] - P [ 2 ], P [ 1 ] - P [ 2 ]); calc ( P [ 1 ] - P [ 3 ], P [ 2 ] - P [ 3 ]); calc ( P [ 2 ] - P [ 3 ], P [ 1 ] - P [ 3 ]); if ( ans >= INF * 1.0 ) puts ( \"impossible\" ); else printf ( \"%.10f \\n \" , ans ); } return 0 ; } C. City Development \u7559\u5751\u3002 D. Parentheses Matrix \u9898\u610f\uff1a \u6784\u9020\u4e00\u4e2a\u77e9\u9635\uff0c\u6bcf\u4e00\u884c\u548c\u6bcf\u4e00\u5217\u90fd\u4f1a\u6784\u6210\u4e00\u4e2a\u62ec\u53f7\u5e8f\u5217\uff0c\u6c42\u5408\u6cd5\u62ec\u53f7\u5e8f\u5217\u5c3d\u91cf\u591a\u3002 \u601d\u8def\uff1a \u5206\u7c7b\u8ba8\u8bba\uff1a n n , m m \u90fd\u662f\u5947\u6570\uff0c\u968f\u4fbf\u6784\u9020\u3002 n n , m m \u6709\u4e00\u4e2a\u5947\u6570 \u90a3\u4e48\u7b54\u6848\u662f\u90a3\u4e2a\u5947\u6570\u3002 \u6bd4\u5982 1, 4 1, 4 \uff1a ()() \u4e24\u4e2a\u90fd\u662f\u5076\u6570\uff0c\u5982\u679c\u6709\u4e00\u4e2a\u4e3a 2 2 \uff0c \u6bd4\u5982 2,4 2,4 \uff1b (((( )))) \u5982\u679c\u4e24\u4e2a\u90fd\u5927\u4e8e 4 4 \u6bd4\u5982 6,6 6,6 \uff1a (((((( ()()() (()()) ()()() (()()) ))))) \u50cf\u8fd9\u6837\u6784\u9020 \u7b54\u6848\u662f n + m - 4 n + m - 4 \u3002 \u5982\u679c n, m n, m \u4e2d\u6709\u4e2a 4 4 \uff0c \u6bd4\u5982 4,4 4,4 \uff1a (()) ()() (()) ()() Code #include <bits/stdc++.h> using namespace std ; const int maxn = 200 + 10 ; int n , m ; char str [ maxn ][ maxn ]; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d\" , & n , & m ); // printf(\"%d %d\\n\", n, m); if ( n % 2 == 1 && m % 2 == 1 ) { for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { printf ( \"(\" ); } printf ( \" \\n \" ); } } else if ( n % 2 == 1 ) { for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( j & 1 ) printf ( \"(\" ); else printf ( \")\" ); } printf ( \" \\n \" ); } } else if ( m % 2 == 1 ) { for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( i & 1 ) printf ( \"(\" ); else printf ( \")\" ); } printf ( \" \\n \" ); } } else if ( n == 2 ) { for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( i & 1 ) printf ( \"(\" ); else printf ( \")\" ); } printf ( \" \\n \" ); } } else if ( m == 2 ) { for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( j & 1 ) printf ( \"(\" ); else printf ( \")\" ); } printf ( \" \\n \" ); } } else if ( n == 4 ) { for ( int i = 1 ; i <= m ; ++ i ) printf ( \"(\" ); printf ( \" \\n \" ); for ( int i = 1 ; i <= m ; ++ i ) { if ( i & 1 ) printf ( \"(\" ); else printf ( \")\" ); } printf ( \" \\n \" ); for ( int i = 1 ; i <= m ; ++ i ) { if ( i & 1 ) printf ( \")\" ); else printf ( \"(\" ); } printf ( \" \\n \" ); for ( int i = 1 ; i <= m ; ++ i ) printf ( \")\" ); printf ( \" \\n \" ); } else if ( m == 4 ) { for ( int i = 1 ; i <= n ; ++ i ) str [ i ][ 1 ] = '(' ; for ( int i = 1 ; i <= n ; ++ i ) { if ( i & 1 ) str [ i ][ 2 ] = '(' ; else str [ i ][ 2 ] = ')' ; } for ( int i = 1 ; i <= n ; ++ i ) { if ( i & 1 ) str [ i ][ 3 ] = ')' ; else str [ i ][ 3 ] = '(' ; } for ( int i = 1 ; i <= n ; ++ i ) str [ i ][ 4 ] = ')' ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { printf ( \"%c\" , str [ i ][ j ]); } printf ( \" \\n \" ); } } else { for ( int i = 1 ; i <= m ; ++ i ) str [ 1 ][ i ] = '(' ; for ( int i = 2 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( i & 1 ) { if ( j == 1 ) str [ i ][ j ] = '(' ; else if ( j == m ) str [ i ][ j ] = ')' ; else if ( j & 1 ) str [ i ][ j ] = ')' ; else str [ i ][ j ] = '(' ; } else { if ( j & 1 ) str [ i ][ j ] = '(' ; else str [ i ][ j ] = ')' ; } } } for ( int i = 1 ; i <= m ; ++ i ) str [ n ][ i ] = ')' ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { printf ( \"%c\" , str [ i ][ j ]); } printf ( \" \\n \" ); } } } return 0 ; } E. Magic Square \u6309\u9898\u610f\u6a21\u62df\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define pii pair<int, int> int t , n ; char G [ 5 ][ 5 ]; void C ( pii a ) { int x = a . first , y = a . second ; char tmp [ 5 ][ 5 ]; tmp [ 1 ][ 1 ] = G [ x + 1 ][ y ]; tmp [ 1 ][ 2 ] = G [ x ][ y ]; tmp [ 2 ][ 1 ] = G [ x + 1 ][ y + 1 ]; tmp [ 2 ][ 2 ] = G [ x ][ y + 1 ]; for ( int i = 1 ; i <= 2 ; ++ i ) for ( int j = 1 ; j <= 2 ; ++ j ) G [ x + i - 1 ][ y + j - 1 ] = tmp [ i ][ j ]; } void R ( pii a ) { int x = a . first , y = a . second ; char tmp [ 5 ][ 5 ]; tmp [ 1 ][ 1 ] = G [ x ][ y + 1 ]; tmp [ 1 ][ 2 ] = G [ x + 1 ][ y + 1 ]; tmp [ 2 ][ 1 ] = G [ x ][ y ]; tmp [ 2 ][ 2 ] = G [ x + 1 ][ y ]; for ( int i = 1 ; i <= 2 ; ++ i ) for ( int j = 1 ; j <= 2 ; ++ j ) G [ x + i - 1 ][ y + j - 1 ] = tmp [ i ][ j ]; } pii pos [ 4 ] = { pii ( 1 , 1 ), pii ( 1 , 2 ), pii ( 2 , 1 ), pii ( 2 , 2 ), }; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= 3 ; ++ i ) scanf ( \"%s\" , G [ i ] + 1 ); char op ; int x ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d %c\" , & x , & op ); if ( op == 'C' ) C ( pos [ x - 1 ]); else R ( pos [ x - 1 ]); } for ( int i = 1 ; i <= 3 ; ++ i ) printf ( \"%s \\n \" , G [ i ] + 1 ); } return 0 ; } F. Boolean 3-Array \u7559\u5751\u3002 G. Card Game \u7559\u5751\u3002 H. K-Similar Strings \u7559\u5751\u3002 I. Make ZYB Happy \u7559\u5751\u3002 J. Taotao Picks Apples \u9898\u610f\uff1a \u6bcf\u6b21\u53ef\u4ee5\u6539\u53d8\u4e00\u4e2a\u503c\uff0c\u6c42\u6539\u53d8\u4e4b\u540e\u4ee5\u7b2c\u4e00\u4e2a\u6570\u5f00\u5934\u7684\u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217\u7684\u957f\u5ea6\uff0c\u6539\u53d8\u4ec5\u5f53\u6b21\u6709\u6548\u3002 \u601d\u8def\uff1a \u8003\u8651\u7ebf\u6bb5\u6811\uff0c\u7ef4\u62a4\u4e00\u4e2a cnt cnt , \u548c\u4e00\u4e2a Max Max \u3002 \u4e24\u4e2a\u533a\u95f4\u5408\u5e76\u7684\u65f6\u5019\uff1b \u5982\u679c \\mbox{\u5de6\u533a\u95f4\u7684}Max > \\mbox{\u53f3\u533a\u95f4\u7684} Max \\mbox{\u5de6\u533a\u95f4\u7684}Max > \\mbox{\u53f3\u533a\u95f4\u7684} Max \u3002 \u90a3\u4e48\u53f3\u533a\u95f4\u6ca1\u6709\u8d21\u732e\u3002 \u5426\u5219\u9012\u5f52\u67e5\u627e\u8d21\u732e\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 int t ; int n , m ; int arr [ N ]; struct SEG { int cnt [ N << 2 ], Max [ N << 2 ]; void build ( int id , int l , int r ) { cnt [ id ] = Max [ id ] = 0 ; if ( l == r ) return ; int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); } int query ( int id , int l , int r , int val ) { if ( l == r ) return Max [ id ] > val ; int mid = ( l + r ) >> 1 ; if ( Max [ id ] <= val ) return 0 ; if ( Max [ id << 1 ] <= val ) return query ( id << 1 | 1 , mid + 1 , r , val ); else return cnt [ id ] - cnt [ id << 1 ] + query ( id << 1 , l , mid , val ); } void update ( int id , int l , int r , int pos , int val ) { if ( l == r ) { cnt [ id ] = 1 ; Max [ id ] = val ; return ; } int mid = ( l + r ) >> 1 ; if ( pos <= mid ) update ( id << 1 , l , mid , pos , val ); else update ( id << 1 | 1 , mid + 1 , r , pos , val ); cnt [ id ] = cnt [ id << 1 ] + query ( id << 1 | 1 , mid + 1 , r , Max [ id << 1 ]); Max [ id ] = max ( Max [ id << 1 ], Max [ id << 1 | 1 ]); } } seg ; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , arr + i ); seg . build ( 1 , 1 , n ); for ( int i = 1 ; i <= n ; ++ i ) seg . update ( 1 , 1 , n , i , arr [ i ]); for ( int i = 1 , x , v ; i <= m ; ++ i ) { scanf ( \"%d%d\" , & x , & v ); seg . update ( 1 , 1 , n , x , v ); printf ( \"%d \\n \" , seg . cnt [ 1 ]); seg . update ( 1 , 1 , n , x , arr [ x ]); } } return 0 ; } K. Pop the Balloons \u7559\u5751\u3002 L. From ICPC to ACM \u7559\u5751\u3002","title":"2018 Multi-University Training Contest 8"},{"location":"trainings/2018-Multi-University-Trainings/Contest-8/#a-character-encoding","text":"\u9898\u610f\uff1a \u7528 m m \u4e2a [0,n-1] [0,n-1] \u7684\u6570\u53bb\u6784\u6210 k k \uff0c\u6c42\u65b9\u6848\u6570\u3002 \u601d\u8def\uff1a \u5f53\u6ca1\u6709 [0,n-1] [0,n-1] \u8fd9\u4e2a\u6761\u4ef6\u662f\u7b54\u6848\u4e3a C(k+m-1, m-1) C(k+m-1, m-1) \u3002 \u51cf\u53bb\u6709\u5927\u4e8e\u7684\u5173\u4e8e n n \u7684\u60c5\u51b5\uff0c\u5f53\u6709 i i \u4e2a n n \u65f6\u7684\u79cd\u7c7b\u4e3a C(k+m-1-i \\cdot n,m-1) C(k+m-1-i \\cdot n,m-1) \u4e2a\uff0c\u5229\u7528\u5bb9\u65a5\u5b9a\u7406\u53ef\u5f97\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; const int MOD = 998244353 ; const int maxn = 1e6 + 10 ; ll fac [ maxn ]; ll inv [ maxn ]; ll invfac [ maxn ]; void Init () { fac [ 0 ] = inv [ 0 ] = invfac [ 0 ] = 1 ; fac [ 1 ] = inv [ 1 ] = invfac [ 1 ] = 1 ; for ( int i = 2 ; i < maxn ; ++ i ) { fac [ i ] = fac [ i - 1 ] * i % MOD ; inv [ i ] = inv [ MOD % i ] * ( MOD - MOD / i ) % MOD ; invfac [ i ] = invfac [ i - 1 ] * inv [ i ] % MOD ; } } ll calc ( ll n , ll m ) { if ( m > n || m < 0 || n < 0 ) return 0 ; return fac [ n ] * invfac [ m ] % MOD * invfac [ n - m ] % MOD ; } int n , m , k ; int main () { Init (); int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d %d\" , & n , & m , & k ); ll ans = 0 ; for ( int i = 0 ; i <= m ; ++ i ) { ll tmp = k - 1l l * i * n + m - 1 ; if ( tmp < 0 ) break ; if ( i & 1 ) ans = ( ans - calc ( m , i ) * calc ( tmp , m - 1 ) % MOD + MOD ) % MOD ; else ans = ( ans + calc ( m , i ) * calc ( tmp , m - 1 ) % MOD ) % MOD ; // cout << i << \" \" << m << \" \" << calc(m, i); // cout << tmp << \" \" << m - 1 << \" \" << calc(tmp, m - 1) << endl; } printf ( \"%lld \\n \" , ans ); } return 0 ; }","title":"A. Character Encoding"},{"location":"trainings/2018-Multi-University-Trainings/Contest-8/#b-pizza-hub","text":"\u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u4e09\u89d2\u5f62\uff0c\u4ee5\u53ca\u4e00\u4e2a\u77e9\u5f62\u7684\u5bbd\u5ea6\uff0c\u6c42\u4e00\u4e2a\u6700\u5c0f\u7684\u9ad8\u5ea6\u4f7f\u5f97\u77e9\u5f62\u80fd\u591f\u8986\u76d6\u4e09\u89d2\u5f62\u3002 \u601d\u8def\uff1a \u663e\u7136\u4e00\u5b9a\u6709\u4e00\u4e2a\u70b9\u5728\u77e9\u5f62\u7684\u9876\u70b9\uff0c\u679a\u4e3e\u8ba1\u7b97\u5373\u53ef Code #include <bits/stdc++.h> using namespace std ; const int INF = 0x3f3f3f3f ; const double PI = acos ( -1.0 ); const double eps = 1e-8 ; const int maxn = 1e2 ; int sgn ( double x ) { if ( fabs ( x ) < eps ) return 0 ; else return x > 0 ? 1 : -1 ; } struct Point { double x , y ; Point () {} Point ( double _x , double _y ) { x = _x ; y = _y ; } void input () { scanf ( \"%lf %lf\" , & x , & y ); } Point operator - ( const Point & b ) const { return Point ( x - b . x , y - b . y ); } double operator ^ ( const Point & b ) const { return x * b . y - y * b . x ; } double distance ( Point p ) { return hypot ( x - p . x , y - p . y ); } double len () { return hypot ( x , y ); } double operator * ( const Point & b ) const { return x * b . x + y * b . y ; } } P [ maxn ]; int w ; double ans ; double area ; void calc ( Point a , Point b ) // low high { if ( sgn ( a * b ) < 0 ) return ; if ( sgn ( a * a - w * w ) <= 0 ) { if ( sgn ( a ^ b ) < 0 ) return ; if ( sgn (( a * b ) * ( a * b ) - w * w * ( a * a )) > 0 ) return ; ans = min ( ans , ( a ^ b ) / sqrt ( a * a )); } else { double h = sqrt ( a * a - w * w ); double src1 = atan ( h / w ); if ( sgn ( a ^ b ) >= 0 ) { double src2 = acos (( a * b ) / ( sqrt ( a * a ) * sqrt ( b * b ))); if ( sgn ( src1 + src2 - PI / 2 ) > 0 ) return ; double len1 = sqrt ( b * b ) * cos ( src1 + src2 ); if ( sgn ( len1 - w ) > 0 ) return ; ans = min ( ans , max ( h , sqrt ( b * b ) * sin ( src1 + src2 ))); } else { double src2 = acos (( a * b ) / ( sqrt ( a * a ) * sqrt ( b * b ))); if ( sgn ( src1 - src2 ) < 0 ) return ; double len1 = sqrt ( b * b ) * cos ( src1 - src2 ); if ( sgn ( len1 - w ) > 0 ) return ; ans = min ( ans , h ); } } } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { for ( int i = 1 ; i <= 3 ; ++ i ) P [ i ]. input (); // double a = p[1].distance(p[2]); // double b = p[2].distance(p[3]); // double c = p[3].distance(p[1]); // double p = (a + b + c) / 2.0; // area = sqrt(p * (p - a) * (p - b) * (p - c)); ans = INF * 1.0 ; scanf ( \"%d\" , & w ); calc ( P [ 2 ] - P [ 1 ], P [ 3 ] - P [ 1 ]); calc ( P [ 3 ] - P [ 1 ], P [ 2 ] - P [ 1 ]); calc ( P [ 1 ] - P [ 2 ], P [ 3 ] - P [ 2 ]); calc ( P [ 3 ] - P [ 2 ], P [ 1 ] - P [ 2 ]); calc ( P [ 1 ] - P [ 3 ], P [ 2 ] - P [ 3 ]); calc ( P [ 2 ] - P [ 3 ], P [ 1 ] - P [ 3 ]); for ( int i = 1 ; i <= 3 ; ++ i ) P [ i ]. y *= -1.0 ; calc ( P [ 2 ] - P [ 1 ], P [ 3 ] - P [ 1 ]); calc ( P [ 3 ] - P [ 1 ], P [ 2 ] - P [ 1 ]); calc ( P [ 1 ] - P [ 2 ], P [ 3 ] - P [ 2 ]); calc ( P [ 3 ] - P [ 2 ], P [ 1 ] - P [ 2 ]); calc ( P [ 1 ] - P [ 3 ], P [ 2 ] - P [ 3 ]); calc ( P [ 2 ] - P [ 3 ], P [ 1 ] - P [ 3 ]); if ( ans >= INF * 1.0 ) puts ( \"impossible\" ); else printf ( \"%.10f \\n \" , ans ); } return 0 ; }","title":"B. Pizza Hub"},{"location":"trainings/2018-Multi-University-Trainings/Contest-8/#c-city-development","text":"\u7559\u5751\u3002","title":"C. City Development"},{"location":"trainings/2018-Multi-University-Trainings/Contest-8/#d-parentheses-matrix","text":"\u9898\u610f\uff1a \u6784\u9020\u4e00\u4e2a\u77e9\u9635\uff0c\u6bcf\u4e00\u884c\u548c\u6bcf\u4e00\u5217\u90fd\u4f1a\u6784\u6210\u4e00\u4e2a\u62ec\u53f7\u5e8f\u5217\uff0c\u6c42\u5408\u6cd5\u62ec\u53f7\u5e8f\u5217\u5c3d\u91cf\u591a\u3002 \u601d\u8def\uff1a \u5206\u7c7b\u8ba8\u8bba\uff1a n n , m m \u90fd\u662f\u5947\u6570\uff0c\u968f\u4fbf\u6784\u9020\u3002 n n , m m \u6709\u4e00\u4e2a\u5947\u6570 \u90a3\u4e48\u7b54\u6848\u662f\u90a3\u4e2a\u5947\u6570\u3002 \u6bd4\u5982 1, 4 1, 4 \uff1a ()() \u4e24\u4e2a\u90fd\u662f\u5076\u6570\uff0c\u5982\u679c\u6709\u4e00\u4e2a\u4e3a 2 2 \uff0c \u6bd4\u5982 2,4 2,4 \uff1b (((( )))) \u5982\u679c\u4e24\u4e2a\u90fd\u5927\u4e8e 4 4 \u6bd4\u5982 6,6 6,6 \uff1a (((((( ()()() (()()) ()()() (()()) ))))) \u50cf\u8fd9\u6837\u6784\u9020 \u7b54\u6848\u662f n + m - 4 n + m - 4 \u3002 \u5982\u679c n, m n, m \u4e2d\u6709\u4e2a 4 4 \uff0c \u6bd4\u5982 4,4 4,4 \uff1a (()) ()() (()) ()() Code #include <bits/stdc++.h> using namespace std ; const int maxn = 200 + 10 ; int n , m ; char str [ maxn ][ maxn ]; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d\" , & n , & m ); // printf(\"%d %d\\n\", n, m); if ( n % 2 == 1 && m % 2 == 1 ) { for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { printf ( \"(\" ); } printf ( \" \\n \" ); } } else if ( n % 2 == 1 ) { for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( j & 1 ) printf ( \"(\" ); else printf ( \")\" ); } printf ( \" \\n \" ); } } else if ( m % 2 == 1 ) { for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( i & 1 ) printf ( \"(\" ); else printf ( \")\" ); } printf ( \" \\n \" ); } } else if ( n == 2 ) { for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( i & 1 ) printf ( \"(\" ); else printf ( \")\" ); } printf ( \" \\n \" ); } } else if ( m == 2 ) { for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( j & 1 ) printf ( \"(\" ); else printf ( \")\" ); } printf ( \" \\n \" ); } } else if ( n == 4 ) { for ( int i = 1 ; i <= m ; ++ i ) printf ( \"(\" ); printf ( \" \\n \" ); for ( int i = 1 ; i <= m ; ++ i ) { if ( i & 1 ) printf ( \"(\" ); else printf ( \")\" ); } printf ( \" \\n \" ); for ( int i = 1 ; i <= m ; ++ i ) { if ( i & 1 ) printf ( \")\" ); else printf ( \"(\" ); } printf ( \" \\n \" ); for ( int i = 1 ; i <= m ; ++ i ) printf ( \")\" ); printf ( \" \\n \" ); } else if ( m == 4 ) { for ( int i = 1 ; i <= n ; ++ i ) str [ i ][ 1 ] = '(' ; for ( int i = 1 ; i <= n ; ++ i ) { if ( i & 1 ) str [ i ][ 2 ] = '(' ; else str [ i ][ 2 ] = ')' ; } for ( int i = 1 ; i <= n ; ++ i ) { if ( i & 1 ) str [ i ][ 3 ] = ')' ; else str [ i ][ 3 ] = '(' ; } for ( int i = 1 ; i <= n ; ++ i ) str [ i ][ 4 ] = ')' ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { printf ( \"%c\" , str [ i ][ j ]); } printf ( \" \\n \" ); } } else { for ( int i = 1 ; i <= m ; ++ i ) str [ 1 ][ i ] = '(' ; for ( int i = 2 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( i & 1 ) { if ( j == 1 ) str [ i ][ j ] = '(' ; else if ( j == m ) str [ i ][ j ] = ')' ; else if ( j & 1 ) str [ i ][ j ] = ')' ; else str [ i ][ j ] = '(' ; } else { if ( j & 1 ) str [ i ][ j ] = '(' ; else str [ i ][ j ] = ')' ; } } } for ( int i = 1 ; i <= m ; ++ i ) str [ n ][ i ] = ')' ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { printf ( \"%c\" , str [ i ][ j ]); } printf ( \" \\n \" ); } } } return 0 ; }","title":"D. Parentheses Matrix"},{"location":"trainings/2018-Multi-University-Trainings/Contest-8/#e-magic-square","text":"\u6309\u9898\u610f\u6a21\u62df\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define pii pair<int, int> int t , n ; char G [ 5 ][ 5 ]; void C ( pii a ) { int x = a . first , y = a . second ; char tmp [ 5 ][ 5 ]; tmp [ 1 ][ 1 ] = G [ x + 1 ][ y ]; tmp [ 1 ][ 2 ] = G [ x ][ y ]; tmp [ 2 ][ 1 ] = G [ x + 1 ][ y + 1 ]; tmp [ 2 ][ 2 ] = G [ x ][ y + 1 ]; for ( int i = 1 ; i <= 2 ; ++ i ) for ( int j = 1 ; j <= 2 ; ++ j ) G [ x + i - 1 ][ y + j - 1 ] = tmp [ i ][ j ]; } void R ( pii a ) { int x = a . first , y = a . second ; char tmp [ 5 ][ 5 ]; tmp [ 1 ][ 1 ] = G [ x ][ y + 1 ]; tmp [ 1 ][ 2 ] = G [ x + 1 ][ y + 1 ]; tmp [ 2 ][ 1 ] = G [ x ][ y ]; tmp [ 2 ][ 2 ] = G [ x + 1 ][ y ]; for ( int i = 1 ; i <= 2 ; ++ i ) for ( int j = 1 ; j <= 2 ; ++ j ) G [ x + i - 1 ][ y + j - 1 ] = tmp [ i ][ j ]; } pii pos [ 4 ] = { pii ( 1 , 1 ), pii ( 1 , 2 ), pii ( 2 , 1 ), pii ( 2 , 2 ), }; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= 3 ; ++ i ) scanf ( \"%s\" , G [ i ] + 1 ); char op ; int x ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d %c\" , & x , & op ); if ( op == 'C' ) C ( pos [ x - 1 ]); else R ( pos [ x - 1 ]); } for ( int i = 1 ; i <= 3 ; ++ i ) printf ( \"%s \\n \" , G [ i ] + 1 ); } return 0 ; }","title":"E. Magic Square"},{"location":"trainings/2018-Multi-University-Trainings/Contest-8/#f-boolean-3-array","text":"\u7559\u5751\u3002","title":"F. Boolean 3-Array"},{"location":"trainings/2018-Multi-University-Trainings/Contest-8/#g-card-game","text":"\u7559\u5751\u3002","title":"G. Card Game"},{"location":"trainings/2018-Multi-University-Trainings/Contest-8/#h-k-similar-strings","text":"\u7559\u5751\u3002","title":"H. K-Similar Strings"},{"location":"trainings/2018-Multi-University-Trainings/Contest-8/#i-make-zyb-happy","text":"\u7559\u5751\u3002","title":"I. Make ZYB Happy"},{"location":"trainings/2018-Multi-University-Trainings/Contest-8/#j-taotao-picks-apples","text":"\u9898\u610f\uff1a \u6bcf\u6b21\u53ef\u4ee5\u6539\u53d8\u4e00\u4e2a\u503c\uff0c\u6c42\u6539\u53d8\u4e4b\u540e\u4ee5\u7b2c\u4e00\u4e2a\u6570\u5f00\u5934\u7684\u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217\u7684\u957f\u5ea6\uff0c\u6539\u53d8\u4ec5\u5f53\u6b21\u6709\u6548\u3002 \u601d\u8def\uff1a \u8003\u8651\u7ebf\u6bb5\u6811\uff0c\u7ef4\u62a4\u4e00\u4e2a cnt cnt , \u548c\u4e00\u4e2a Max Max \u3002 \u4e24\u4e2a\u533a\u95f4\u5408\u5e76\u7684\u65f6\u5019\uff1b \u5982\u679c \\mbox{\u5de6\u533a\u95f4\u7684}Max > \\mbox{\u53f3\u533a\u95f4\u7684} Max \\mbox{\u5de6\u533a\u95f4\u7684}Max > \\mbox{\u53f3\u533a\u95f4\u7684} Max \u3002 \u90a3\u4e48\u53f3\u533a\u95f4\u6ca1\u6709\u8d21\u732e\u3002 \u5426\u5219\u9012\u5f52\u67e5\u627e\u8d21\u732e\u3002 Code #include <bits/stdc++.h> using namespace std ; #define N 100010 int t ; int n , m ; int arr [ N ]; struct SEG { int cnt [ N << 2 ], Max [ N << 2 ]; void build ( int id , int l , int r ) { cnt [ id ] = Max [ id ] = 0 ; if ( l == r ) return ; int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); } int query ( int id , int l , int r , int val ) { if ( l == r ) return Max [ id ] > val ; int mid = ( l + r ) >> 1 ; if ( Max [ id ] <= val ) return 0 ; if ( Max [ id << 1 ] <= val ) return query ( id << 1 | 1 , mid + 1 , r , val ); else return cnt [ id ] - cnt [ id << 1 ] + query ( id << 1 , l , mid , val ); } void update ( int id , int l , int r , int pos , int val ) { if ( l == r ) { cnt [ id ] = 1 ; Max [ id ] = val ; return ; } int mid = ( l + r ) >> 1 ; if ( pos <= mid ) update ( id << 1 , l , mid , pos , val ); else update ( id << 1 | 1 , mid + 1 , r , pos , val ); cnt [ id ] = cnt [ id << 1 ] + query ( id << 1 | 1 , mid + 1 , r , Max [ id << 1 ]); Max [ id ] = max ( Max [ id << 1 ], Max [ id << 1 | 1 ]); } } seg ; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , arr + i ); seg . build ( 1 , 1 , n ); for ( int i = 1 ; i <= n ; ++ i ) seg . update ( 1 , 1 , n , i , arr [ i ]); for ( int i = 1 , x , v ; i <= m ; ++ i ) { scanf ( \"%d%d\" , & x , & v ); seg . update ( 1 , 1 , n , x , v ); printf ( \"%d \\n \" , seg . cnt [ 1 ]); seg . update ( 1 , 1 , n , x , arr [ x ]); } } return 0 ; }","title":"J. Taotao Picks Apples"},{"location":"trainings/2018-Multi-University-Trainings/Contest-8/#k-pop-the-balloons","text":"\u7559\u5751\u3002","title":"K. Pop the Balloons"},{"location":"trainings/2018-Multi-University-Trainings/Contest-8/#l-from-icpc-to-acm","text":"\u7559\u5751\u3002","title":"L. From ICPC to ACM"},{"location":"trainings/2018-Multi-University-Trainings/Contest-9/","text":"2018 Multi-University Training Contest 9 Contents A. Rikka with Nash Equilibrium B. Rikka with Seam C. Rikka with APSP D. Rikka with Stone-Paper-Scissors E. Rikka with Rain F. Rikka with Spanning Tree G. Rikka with Treasure H. Rikka with Line Graph I. Rikka with Bubble Sort J. Rikka with Time Complexity K. Rikka with Badminton A. Rikka with Nash Equilibrium \u9898\u610f\uff1a \u6784\u9020\u4e00\u4e2a n \\cdot m n \\cdot m \u7684\u77e9\u9635\uff0c\u4f7f\u5f97 [1, n \\cdot m] [1, n \\cdot m] \u4e2d\u6bcf\u4e2a\u6570\u53ea\u51fa\u73b0\u4e00\u6b21\uff0c\u5e76\u4e14\u7eb3\u4ec0\u5747\u8861\u53ea\u51fa\u73b0\u4e00\u6b21\u3002 \u601d\u8def\uff1a \u4ece\u5927\u5230\u5c0f\u7684\u653e\u7f6e\uff0c\u6bcf\u4e00\u4e2a\u90fd\u53ef\u4ee5\u62d3\u5c55\u4e00\u884c\u62d3\u5c55\u4e00\u5217\u6216\u8005\u653e\u5728\u5df2\u7ecf\u62d3\u5c55\u7684\u884c\u5217\u7126\u70b9\uff0c\u7528\u8bb0\u5fc6\u5316\u641c\u7d22\u6216 dp \u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int n , m ; ll p ; ll dp [ 81 ][ 81 ][ 81 * 81 ]; ll DFS ( int x , int y , int z ) { if ( z >= n * m ) return 1 ; if ( dp [ x ][ y ][ z ] != -1 ) return dp [ x ][ y ][ z ]; ll res = 0 ; if ( x < n ) res = ( res + y * ( n - x ) % p * DFS ( x + 1 , y , z + 1 )) % p ; if ( y < m ) res = ( res + x * ( m - y ) % p * DFS ( x , y + 1 , z + 1 )) % p ; if ( x * y > z ) res = ( res + ( x * y - z ) * DFS ( x , y , z + 1 )) % p ; dp [ x ][ y ][ z ] = res ; return res ; } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d %lld\" , & n , & m , & p ); memset ( dp , -1 , sizeof dp ); ll ans = DFS ( 1 , 1 , 1 ); ans = n * m % p * ans % p ; printf ( \"%lld \\n \" , ans ); } return 0 ; } B. Rikka with Seam \u7559\u5751\u3002 C. Rikka with APSP \u7559\u5751\u3002 D. Rikka with Stone-Paper-Scissors \u9898\u610f\uff1a \u6bcf\u4e2a\u4eba\u6709\u4e09\u79cd\u724c\uff1a\u300c\u77f3\u5934\u3001\u526a\u5200\u3001\u5e03\u300d\u3002 \u8be2\u95ee\u7b2c\u4e00\u4e2a\u4eba\u8d62\u7b2c\u4e8c\u4e2a\u4eba\u7684\u671f\u671b\u3002 \u601d\u8def\uff1a \u8003\u8651\u6bcf\u4e00\u6b21\u51fa\u724c\u7684\u6982\u7387\u76f8\u540c\uff0c\u90a3\u4e48\u7b54\u6848\u5c31\u662f\uff1a \\frac{\\mbox{\u8d62\u7684\u60c5\u51b5\u79cd\u6570 - \u8f93\u7684\u60c5\u51b5}}{\\mbox{\u724c\u6570}} \\frac{\\mbox{\u8d62\u7684\u60c5\u51b5\u79cd\u6570 - \u8f93\u7684\u60c5\u51b5}}{\\mbox{\u724c\u6570}} \u90a3\u4e48\u6240\u6709\u8d62\u8f93\u60c5\u51b5\u79cd\u7c7b\u6570\u5c31\u662f\uff1a \\frac {a_1 *(b_2 - c_2) + b_1 * (c_2 - a_2) + c_1 * (a_2 - b_2)} {a + b + c} \\frac {a_1 *(b_2 - c_2) + b_1 * (c_2 - a_2) + c_1 * (a_2 - b_2)} {a + b + c} Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll gcd ( ll a , ll b ) { return b == 0 ? a : gcd ( b , a % b ); } ll a1 , b1 , c1 , a2 , b2 , c2 ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%lld %lld %lld %lld %lld %lld\" , & a1 , & b1 , & c1 , & a2 , & b2 , & c2 ); ll ans = a1 * ( b2 - c2 ) + b1 * ( c2 - a2 ) + c1 * ( a2 - b2 ); if ( ans % ( a1 + b1 + c1 ) == 0 ) { ans /= a1 + b1 + c1 ; printf ( \"%lld \\n \" , ans ); } else { int flag = 0 ; if ( ans < 0 ) { ans = - ans ; flag = 1 ; } ll ans2 = a1 + b1 + c1 ; ll GCD = gcd ( ans , ans2 ); ans /= GCD ; ans2 /= GCD ; if ( flag ) printf ( \"-\" ); printf ( \"%lld/%lld \\n \" , ans , ans2 ); } } return 0 ; } E. Rikka with Rain \u7559\u5751\u3002 F. Rikka with Spanning Tree \u7559\u5751\u3002 G. Rikka with Treasure \u7559\u5751\u3002 H. Rikka with Line Graph \u7559\u5751\u3002 I. Rikka with Bubble Sort \u7559\u5751\u3002 J. Rikka with Time Complexity \u7559\u5751\u3002 K. Rikka with Badminton \u9898\u610f\uff1a \u56db\u79cd\u4eba\uff0c\u4e00\u79cd\u4eba\u5565\u90fd\u6ca1\u6709\uff0c\u4e00\u79cd\u4eba\u6709\u62cd\uff0c\u4e00\u79cd\u4eba\u6709\u7403\uff0c\u4e00\u79cd\u4eba\u6709\u62cd\u6709\u7403\uff0c\u6c42\u65b9\u6848\u6570\u4f7f\u5f97\u6709\u4e24\u62cd\u4e00\u7403\u3002 \u601d\u8def\uff1a \u8003\u8651\u4e09\u79cd\u9009\u62e9\u65b9\u6848\uff1a \u4e24\u4e2a\u6709\u62cd + \u4e00\u4e2a\u6709\u7403\u3002 \u4e24\u4e2a\u6709\u62cd\u6709\u7403\u3002 \u4e00\u4e2a\u6709\u62cd\uff0c\u4e00\u4e2a\u6709\u62cd\u6709\u7403\u3002 \u7b54\u6848\u5c31\u662f\uff1a 2^a \\cdot 2^c \\cdot (2^b - 1) \\cdot (2^d - 1) + 2^a \\cdot 2^c \\cdot (2^d - 1 - d) + 2^a \\cdot (2^b - 1 - b) \\cdot (2^c - 1) 2^a \\cdot 2^c \\cdot (2^b - 1) \\cdot (2^d - 1) + 2^a \\cdot 2^c \\cdot (2^d - 1 - d) + 2^a \\cdot (2^b - 1 - b) \\cdot (2^c - 1) Code #include <bits/stdc++.h> using namespace std ; #define ll long long const ll MOD = 998244353 ; ll qmod ( ll n ) { ll res = 1 ; ll base = 2 ; while ( n ) { if ( n & 1 ) res = res * base % MOD ; base = base * base % MOD ; n >>= 1 ; } return res ; } int t ; ll a , b , c , d ; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%lld%lld%lld%lld\" , & a , & b , & c , & d ); ll n = a + b + c + d ; ll res = qmod ( a ) * qmod ( c ) % MOD * ( qmod ( b ) - 1 + MOD ) % MOD * ( qmod ( d ) - 1 + MOD ) % MOD ; res = ( res + qmod ( a ) * qmod ( c ) % MOD * ( qmod ( d ) - 1 - d + MOD ) % MOD ) % MOD ; res = ( res + qmod ( a ) * ( qmod ( b ) - 1 - b + MOD ) % MOD * ( qmod ( c ) - 1 + MOD )) % MOD ; printf ( \"%lld \\n \" , ( qmod ( n ) - res + MOD ) % MOD ); } return 0 ; }","title":"2018 Multi-University Training Contest 9"},{"location":"trainings/2018-Multi-University-Trainings/Contest-9/#a-rikka-with-nash-equilibrium","text":"\u9898\u610f\uff1a \u6784\u9020\u4e00\u4e2a n \\cdot m n \\cdot m \u7684\u77e9\u9635\uff0c\u4f7f\u5f97 [1, n \\cdot m] [1, n \\cdot m] \u4e2d\u6bcf\u4e2a\u6570\u53ea\u51fa\u73b0\u4e00\u6b21\uff0c\u5e76\u4e14\u7eb3\u4ec0\u5747\u8861\u53ea\u51fa\u73b0\u4e00\u6b21\u3002 \u601d\u8def\uff1a \u4ece\u5927\u5230\u5c0f\u7684\u653e\u7f6e\uff0c\u6bcf\u4e00\u4e2a\u90fd\u53ef\u4ee5\u62d3\u5c55\u4e00\u884c\u62d3\u5c55\u4e00\u5217\u6216\u8005\u653e\u5728\u5df2\u7ecf\u62d3\u5c55\u7684\u884c\u5217\u7126\u70b9\uff0c\u7528\u8bb0\u5fc6\u5316\u641c\u7d22\u6216 dp \u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; int n , m ; ll p ; ll dp [ 81 ][ 81 ][ 81 * 81 ]; ll DFS ( int x , int y , int z ) { if ( z >= n * m ) return 1 ; if ( dp [ x ][ y ][ z ] != -1 ) return dp [ x ][ y ][ z ]; ll res = 0 ; if ( x < n ) res = ( res + y * ( n - x ) % p * DFS ( x + 1 , y , z + 1 )) % p ; if ( y < m ) res = ( res + x * ( m - y ) % p * DFS ( x , y + 1 , z + 1 )) % p ; if ( x * y > z ) res = ( res + ( x * y - z ) * DFS ( x , y , z + 1 )) % p ; dp [ x ][ y ][ z ] = res ; return res ; } int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%d %d %lld\" , & n , & m , & p ); memset ( dp , -1 , sizeof dp ); ll ans = DFS ( 1 , 1 , 1 ); ans = n * m % p * ans % p ; printf ( \"%lld \\n \" , ans ); } return 0 ; }","title":"A. Rikka with Nash Equilibrium"},{"location":"trainings/2018-Multi-University-Trainings/Contest-9/#b-rikka-with-seam","text":"\u7559\u5751\u3002","title":"B. Rikka with Seam"},{"location":"trainings/2018-Multi-University-Trainings/Contest-9/#c-rikka-with-apsp","text":"\u7559\u5751\u3002","title":"C. Rikka with APSP"},{"location":"trainings/2018-Multi-University-Trainings/Contest-9/#d-rikka-with-stone-paper-scissors","text":"\u9898\u610f\uff1a \u6bcf\u4e2a\u4eba\u6709\u4e09\u79cd\u724c\uff1a\u300c\u77f3\u5934\u3001\u526a\u5200\u3001\u5e03\u300d\u3002 \u8be2\u95ee\u7b2c\u4e00\u4e2a\u4eba\u8d62\u7b2c\u4e8c\u4e2a\u4eba\u7684\u671f\u671b\u3002 \u601d\u8def\uff1a \u8003\u8651\u6bcf\u4e00\u6b21\u51fa\u724c\u7684\u6982\u7387\u76f8\u540c\uff0c\u90a3\u4e48\u7b54\u6848\u5c31\u662f\uff1a \\frac{\\mbox{\u8d62\u7684\u60c5\u51b5\u79cd\u6570 - \u8f93\u7684\u60c5\u51b5}}{\\mbox{\u724c\u6570}} \\frac{\\mbox{\u8d62\u7684\u60c5\u51b5\u79cd\u6570 - \u8f93\u7684\u60c5\u51b5}}{\\mbox{\u724c\u6570}} \u90a3\u4e48\u6240\u6709\u8d62\u8f93\u60c5\u51b5\u79cd\u7c7b\u6570\u5c31\u662f\uff1a \\frac {a_1 *(b_2 - c_2) + b_1 * (c_2 - a_2) + c_1 * (a_2 - b_2)} {a + b + c} \\frac {a_1 *(b_2 - c_2) + b_1 * (c_2 - a_2) + c_1 * (a_2 - b_2)} {a + b + c} Code #include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll gcd ( ll a , ll b ) { return b == 0 ? a : gcd ( b , a % b ); } ll a1 , b1 , c1 , a2 , b2 , c2 ; int main () { int t ; scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%lld %lld %lld %lld %lld %lld\" , & a1 , & b1 , & c1 , & a2 , & b2 , & c2 ); ll ans = a1 * ( b2 - c2 ) + b1 * ( c2 - a2 ) + c1 * ( a2 - b2 ); if ( ans % ( a1 + b1 + c1 ) == 0 ) { ans /= a1 + b1 + c1 ; printf ( \"%lld \\n \" , ans ); } else { int flag = 0 ; if ( ans < 0 ) { ans = - ans ; flag = 1 ; } ll ans2 = a1 + b1 + c1 ; ll GCD = gcd ( ans , ans2 ); ans /= GCD ; ans2 /= GCD ; if ( flag ) printf ( \"-\" ); printf ( \"%lld/%lld \\n \" , ans , ans2 ); } } return 0 ; }","title":"D. Rikka with Stone-Paper-Scissors"},{"location":"trainings/2018-Multi-University-Trainings/Contest-9/#e-rikka-with-rain","text":"\u7559\u5751\u3002","title":"E. Rikka with Rain"},{"location":"trainings/2018-Multi-University-Trainings/Contest-9/#f-rikka-with-spanning-tree","text":"\u7559\u5751\u3002","title":"F. Rikka with Spanning Tree"},{"location":"trainings/2018-Multi-University-Trainings/Contest-9/#g-rikka-with-treasure","text":"\u7559\u5751\u3002","title":"G. Rikka with Treasure"},{"location":"trainings/2018-Multi-University-Trainings/Contest-9/#h-rikka-with-line-graph","text":"\u7559\u5751\u3002","title":"H. Rikka with Line Graph"},{"location":"trainings/2018-Multi-University-Trainings/Contest-9/#i-rikka-with-bubble-sort","text":"\u7559\u5751\u3002","title":"I. Rikka with Bubble Sort"},{"location":"trainings/2018-Multi-University-Trainings/Contest-9/#j-rikka-with-time-complexity","text":"\u7559\u5751\u3002","title":"J. Rikka with Time Complexity"},{"location":"trainings/2018-Multi-University-Trainings/Contest-9/#k-rikka-with-badminton","text":"\u9898\u610f\uff1a \u56db\u79cd\u4eba\uff0c\u4e00\u79cd\u4eba\u5565\u90fd\u6ca1\u6709\uff0c\u4e00\u79cd\u4eba\u6709\u62cd\uff0c\u4e00\u79cd\u4eba\u6709\u7403\uff0c\u4e00\u79cd\u4eba\u6709\u62cd\u6709\u7403\uff0c\u6c42\u65b9\u6848\u6570\u4f7f\u5f97\u6709\u4e24\u62cd\u4e00\u7403\u3002 \u601d\u8def\uff1a \u8003\u8651\u4e09\u79cd\u9009\u62e9\u65b9\u6848\uff1a \u4e24\u4e2a\u6709\u62cd + \u4e00\u4e2a\u6709\u7403\u3002 \u4e24\u4e2a\u6709\u62cd\u6709\u7403\u3002 \u4e00\u4e2a\u6709\u62cd\uff0c\u4e00\u4e2a\u6709\u62cd\u6709\u7403\u3002 \u7b54\u6848\u5c31\u662f\uff1a 2^a \\cdot 2^c \\cdot (2^b - 1) \\cdot (2^d - 1) + 2^a \\cdot 2^c \\cdot (2^d - 1 - d) + 2^a \\cdot (2^b - 1 - b) \\cdot (2^c - 1) 2^a \\cdot 2^c \\cdot (2^b - 1) \\cdot (2^d - 1) + 2^a \\cdot 2^c \\cdot (2^d - 1 - d) + 2^a \\cdot (2^b - 1 - b) \\cdot (2^c - 1) Code #include <bits/stdc++.h> using namespace std ; #define ll long long const ll MOD = 998244353 ; ll qmod ( ll n ) { ll res = 1 ; ll base = 2 ; while ( n ) { if ( n & 1 ) res = res * base % MOD ; base = base * base % MOD ; n >>= 1 ; } return res ; } int t ; ll a , b , c , d ; int main () { scanf ( \"%d\" , & t ); while ( t -- ) { scanf ( \"%lld%lld%lld%lld\" , & a , & b , & c , & d ); ll n = a + b + c + d ; ll res = qmod ( a ) * qmod ( c ) % MOD * ( qmod ( b ) - 1 + MOD ) % MOD * ( qmod ( d ) - 1 + MOD ) % MOD ; res = ( res + qmod ( a ) * qmod ( c ) % MOD * ( qmod ( d ) - 1 - d + MOD ) % MOD ) % MOD ; res = ( res + qmod ( a ) * ( qmod ( b ) - 1 - b + MOD ) % MOD * ( qmod ( c ) - 1 + MOD )) % MOD ; printf ( \"%lld \\n \" , ( qmod ( n ) - res + MOD ) % MOD ); } return 0 ; }","title":"K. Rikka with Badminton"},{"location":"trainings/random-trainings/18th-SHU-CPC/","text":"\u201c\u79d1\u5927\u8baf\u98de\u676f\u201d\u7b2c18\u5c4a\u4e0a\u6d77\u5927\u5b66\u7a0b\u5e8f\u8bbe\u8ba1\u8054\u8d5b\u6625\u5b63\u8d5b\u66a8\u9ad8\u6821\u7f51\u7edc\u53cb\u8c0a\u8d5b Contents Contest Info Solutions A. \u7ec4\u961f\u6bd4\u8d5b B. \u6bcf\u65e5\u4e00\u62a5 C. \u6700\u957f\u975e\u516c\u5171\u5b50\u5e8f\u5217 D. \u6700\u5927\u5b57\u7b26\u96c6 E. \u7f8e\u5473\u7684\u5e8f\u5217 F. \u65e5\u671f\u5c0f\u52a9\u624b G. \u8840\u538b\u6e38\u620f H. \u7eb8\u724c\u6e38\u620f I. \u53e4\u8001\u7684\u6253\u5b57\u673a J. \u80fd\u5230\u8fbe\u5417 K. \u8ff7\u5bab L. \u52a8\u7269\u68ee\u53cb\u4f1a Contest Info Practice Link Solved A B C D E F G H I J K L 12/12 O O O O O O \u00d8 O \u00d8 \u00d8 O O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5 Solutions A. \u7ec4\u961f\u6bd4\u8d5b Solved By Hsueh-. 0:04(+) \u7b7e\u5230\u3002 B. \u6bcf\u65e5\u4e00\u62a5 Solved By Hsueh-. 0:20(+2) \u7b7e\u5230\u3002 C. \u6700\u957f\u975e\u516c\u5171\u5b50\u5e8f\u5217 Solved By Hsueh-. 0:07(+) \u7b7e\u5230\u3002 D. \u6700\u5927\u5b57\u7b26\u96c6 Solved By Hsueh-. 0:41(+) \u601d\u8def\uff1a \u7279\u5224 1 1 \u548c 2 2 \uff0c\u7136\u540e\u5bf9\u4e8e n > 2 n > 2 \u7684\uff0c\u5982\u4e0b\u6784\u9020\uff1a \u4f8b\u5982 n = 5 n = 5 \uff1a 00 010 0110 01110 Code #include <bits/stdc++.h> using namespace std ; int n ; int main () { scanf ( \"%d\" , & n ); if ( n == 1 ) { printf ( \"%d \\n \" , 1 ); printf ( \"%d \\n \" , 1 ); } else if ( n == 2 ) { printf ( \"%d \\n \" , 2 ); puts ( \"0\" ); puts ( \"11\" ); } else { printf ( \"%d \\n \" , n - 1 ); for ( int i = 2 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= i ; ++ j ) { if ( j == 1 || j == i ) printf ( \"0\" ); else printf ( \"1\" ); } puts ( \"\" ); } } return 0 ; } E. \u7f8e\u5473\u7684\u5e8f\u5217 Solved By ltslts. 0:16(+) \u601d\u8def\uff1a \u4e0b\u964d\u7684\u7f8e\u5473\u5ea6\u662f\u56fa\u5b9a\u7684\u3002 Code #include <bits/stdc++.h> using namespace std ; int main () { int n ; scanf ( \"%d\" , & n ); long long ans = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { int x ; scanf ( \"%d\" , & x ); ans += x ; } ans -= 1l l * n * ( n - 1 ) / 2 ; printf ( \"%lld \\n \" , ans ); return 0 ; } F. \u65e5\u671f\u5c0f\u52a9\u624b Solved By Dup4. 0:37(+) \u601d\u8def\uff1a \u627e\u51fa\u5f53\u5e74\u548c\u4e0b\u5e74\u7684\u6bcd\u4eb2\u8282\u3001\u7236\u4eb2\u8282\uff0c\u53d6\u5408\u6cd5\u7684\uff0c\u6700\u5c0f\u7684\u3002 Code #include <bits/stdc++.h> using namespace std ; struct node { int y , m , d ; node ( int y = 0 , int m = 0 , int d = 0 ) : y ( y ), m ( m ), d ( d ) {} bool operator < ( const node & other ) const { if ( y != other . y ) return y < other . y ; if ( m != other . m ) return m < other . m ; return d < other . d ; } bool operator == ( const node & other ) const { return y == other . y && m == other . m && d == other . d ; } }; int getweek ( int y , int m , int d ) { int ans ; if ( m == 1 || m == 2 ) m += 12 , y -- ; if (( y < 1752 ) || ( y == 1752 && m < 9 ) || ( y == 1752 && m == 9 && d < 3 )) { ans = ( d + 2 * m + 3 * ( m + 1 ) / 5 + y + y / 4 + 5 ) % 7 ; } else { ans = ( d + 2 * m + 3 * ( m + 1 ) / 5 + y + y / 4 - y / 100 + y / 400 ) % 7 ; } ans = ( d + 2 * m + 3 * ( m + 1 ) / 5 + y + y / 4 - y / 100 + y / 400 ) % 7 ; return ans + 1 ; } int main () { int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { int y , m , d ; scanf ( \"%d%d%d\" , & y , & m , & d ); node A = node ( y , m , d ); vector < node > vec [ 2 ]; for ( int i = y ; i <= y + 1 ; ++ i ) { for ( int j = 1 , cnt = 0 ; j <= 31 ; ++ j ) { if ( getweek ( i , 5 , j ) == 7 ) { ++ cnt ; if ( cnt == 2 ) { vec [ 0 ]. emplace_back ( i , 5 , j ); break ; } } } for ( int j = 1 , cnt = 0 ; j <= 30 ; ++ j ) { if ( getweek ( i , 6 , j ) == 7 ) { ++ cnt ; if ( cnt == 3 ) { vec [ 1 ]. emplace_back ( i , 6 , j ); break ; } } } } node B = node (); ; int flag = -1 ; for ( auto & it : vec [ 0 ]) { if ( ! ( A == it ) && A < it ) { if ( flag == -1 ) { flag = 0 ; B = it ; } else if ( it < B ) { flag = 0 ; B = it ; } } } for ( auto & it : vec [ 1 ]) { if ( ! ( A == it ) && A < it ) { if ( flag == -1 ) { flag = 1 ; B = it ; } else if ( it < B ) { flag = 1 ; B = it ; } } } if ( ! flag ) printf ( \"Mother's Day: May \" ); else printf ( \"Father's Day: June \" ); string s = \"th\" ; if ( B . d == 1 || B . d == 21 || B . d == 31 ) s = \"st\" ; if ( B . d == 2 || B . d == 22 || B . d == 32 ) s = \"nd\" ; if ( B . d == 3 || B . d == 23 || B . d == 33 ) s = \"rd\" ; cout << B . d << s << \", \" << B . y << \" \\n \" ; } return 0 ; } G. \u8840\u538b\u6e38\u620f UpSolved By Dup4. \u601d\u8def\uff1a \u8003\u8651\u53ea\u6709\u540c\u4e00\u6df1\u5ea6\u7684\u70b9\u624d\u4f1a\u6253\u67b6\uff0c\u90a3\u4e48\u53ef\u4ee5\u76f4\u63a5\u505a\u4e00\u4e2a\u57fa\u4e8e\u6df1\u5ea6\u7684 dp\uff0c\u542c\u7fa4\u91cc\u8bf4\u6309\u6df1\u5ea6\u5206\u7c7b\uff0c\u5bf9\u6bcf\u4e2a\u865a\u6811 dfs \u4e5f\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; using pIL = pair < int , ll > ; #define fi first #define se second #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 2e5 + 10 ; int n , rt , use [ N ], a [ N ]; vector < vector < int >> G ; int fa [ N ], md [ N ], hson [ N ], deep [ N ]; void pre ( int u ) { hson [ u ] = 0 ; for ( auto & v : G [ u ]) { if ( v == fa [ u ]) continue ; fa [ v ] = u ; deep [ v ] = deep [ u ] + 1 ; pre ( v ); if ( ! hson [ u ] || md [ v ] > md [ hson [ u ]]) hson [ u ] = v ; } md [ u ] = md [ hson [ u ]] + 1 ; } pIL tmp [ N << 2 ], * f [ N ], * id = tmp ; void dfs ( int u ) { if ( hson [ u ]) { int v = hson [ u ]; f [ v ] = f [ u ] + 1 ; dfs ( v ); } for ( auto & v : G [ u ]) { if ( v == fa [ u ] || v == hson [ u ]) continue ; f [ v ] = id ; id += md [ v ] * 2 ; dfs ( v ); } f [ u ][ 0 ] = pIL ( deep [ u ], a [ u ]); for ( auto & v : G [ u ]) { if ( v == fa [ u ] || v == hson [ u ]) continue ; for ( int i = 1 ; i <= md [ v ]; ++ i ) if ( f [ u ][ i ]. se || f [ v ][ i - 1 ]. se ) { if ( f [ u ][ i ]. se == 0 ) f [ u ][ i ]. fi = deep [ v ]; if ( f [ u ][ i ]. fi > deep [ v ]) { int need = f [ u ][ i ]. fi - deep [ v ]; f [ u ][ i ]. se = max ( 1l l , f [ u ][ i ]. se - need ); f [ u ][ i ]. fi = deep [ u ] + 1 ; } if ( f [ v ][ i - 1 ]. se == 0 ) f [ v ][ i - 1 ]. fi = deep [ v ]; if ( f [ v ][ i - 1 ]. fi > deep [ v ]) { int need = f [ v ][ i - 1 ]. fi - deep [ v ]; f [ v ][ i - 1 ]. se = max ( 1l l , f [ v ][ i - 1 ]. se - need ); f [ v ][ i - 1 ]. fi = deep [ v ]; } f [ u ][ i ]. se += f [ v ][ i - 1 ]. se ; if ( use [ i ] == 0 && f [ u ][ i ]. se > 1 ) { -- f [ u ][ i ]. se ; use [ i ] = 1 ; } f [ u ][ i ]. fi = deep [ u ]; } } for ( auto & v : G [ u ]) { if ( v == fa [ u ] || v == hson [ u ]) continue ; for ( int i = 0 ; i <= md [ v ]; ++ i ) { use [ i ] = 0 ; } } } int main () { scanf ( \"%d%d\" , & n , & rt ); memset ( use , 0 , sizeof use ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); if ( a [ i ] > 1 ) -- a [ i ]; } G . clear (); G . resize ( n + 1 ); for ( int i = 1 , u , v ; i < n ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); G [ u ]. push_back ( v ); G [ v ]. push_back ( u ); } fa [ rt ] = rt ; deep [ rt ] = 1 ; pre ( rt ); f [ rt ] = id ; id += md [ rt ] * 2 ; dfs ( rt ); ll res = 0 ; for ( int i = 0 ; i <= md [ rt ]; ++ i ) if ( f [ rt ][ i ]. se > 0 ) { // dbg(i, f[rt][i].se); if ( f [ rt ][ i ]. fi > 1 ) { int need = f [ rt ][ i ]. fi - 1 ; f [ rt ][ i ]. se = max ( 1l l , f [ rt ][ i ]. se - need ); } res += f [ rt ][ i ]. se ; } printf ( \"%lld \\n \" , res ); return 0 ; } H. \u7eb8\u724c\u6e38\u620f Solved By Hsueh- & ltslts. 4:56(+7) \u601d\u8def\uff1a \u8d2a\u5fc3\u53d6\u524d k k \u4e2a\uff0c\u7136\u540e\u5982\u679c\u4e0d\u5408\u6cd5\uff0c\u8003\u8651\u4fee\u6539\u51e0\u4f4d\uff0c\u663e\u7136\u6700\u591a\u4fee\u6539\u4e24\u4f4d\uff0c\u56e0\u6b64\u8fdb\u884c\u5206\u7c7b\uff1a \u4ece\u5c0f\u5230\u5927\u66b4\u529b\u5224\u65ad\u6bcf\u4e00\u4f4d\u4fee\u6539\u4e3a 9-0 9-0 \u7684\u7ed3\u679c\u3002 \u4fee\u6539\u4e24\u4f4d\u540c\u6837\u662f\u4ece\u5c0f\u5230\u5927\u66b4\u529b\u4fee\u6539\u6bcf\u4e00\u4f4d\uff0c\u8003\u8651\u5230\u5f53\u524d\u662f\u4fee\u6539\u4e24\u4f4d\uff0c\u6240\u4ee5\u53ea\u53ef\u80fd\u662f\u9009\u4e24\u4e2a\u6570\u5b57\u6539\u4e3a \\% \\; 3 \\% \\; 3 \u540e\u51cf\u5c11\u4e00\u6216\u8005 \\% \\; 3 \\% \\; 3 \u540e\u589e\u52a0\u4e00\uff0c\u66b4\u529b\u5224\u65ad\u5373\u53ef\u3002 \u6700\u540e\u6392\u5e8f\u4e00\u4e0b\u5224\u65ad\u4e09\u79cd\u60c5\u51b5\u5927\u5c0f \u6ce8\u610f\u7279\u5224\u524d\u5bfc\u96f6 1 733110 3 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } int n , k , sum , sum2 ; char s [ N ]; int cnt [ 20 ], cnt2 [ 20 ]; vector < int > vec , vec1 , vec2 , vec3 ; bool cmp ( vector < int > V1 , vector < int > V2 ) { for ( int i = 0 ; i < k ; ++ i ) { if ( V1 > V2 ) return true ; if ( V1 < V2 ) return false ; } return true ; } void print ( vector < int > V ) { sort ( V . begin (), V . end ()); reverse ( V . begin (), V . end ()); if ( V [ 0 ] == 0 && V . size () > 1 ) { puts ( \"-1\" ); return ; } for ( auto it : V ) { printf ( \"%d\" , it ); } puts ( \"\" ); } bool ok1 ( vector < int >& vec ) { for ( int i = k - 1 ; i >= 0 ; -- i ) { int it = vec [ i ]; for ( int j = 9 ; j >= 0 ; -- j ) { if ( ! cnt [ j ]) continue ; if (( sum - it + j ) % 3 == 0 ) { vec [ i ] = j ; return true ; } } } return false ; } bool ok2 ( vector < int >& vec ) { for ( int i = k - 1 ; i >= 0 ; -- i ) { int it = vec [ i ]; bool F = false ; for ( int j = 9 ; j >= 0 ; -- j ) { if ( ! cnt [ j ]) continue ; int a = ( it % 3 + 2 ) % 3 ; if ( j % 3 == a ) { vec [ i ] = j ; sum = sum - it + j ; cnt [ j ] -- ; cnt [ it ] ++ ; F = true ; break ; } } if ( F ) break ; } for ( int i = k - 1 ; i >= 0 ; -- i ) { int it = vec [ i ]; bool F = false ; for ( int j = 9 ; j >= 0 ; -- j ) { if ( ! cnt [ j ]) continue ; int a = ( it % 3 + 2 ) % 3 ; if ( j % 3 == a ) { vec [ i ] = j ; sum = sum - it + j ; cnt [ j ] -- ; cnt [ it ] ++ ; F = true ; break ; } } if ( F ) break ; } return sum % 3 == 0 ; } bool ok3 ( vector < int >& vec ) { for ( int i = k - 1 ; i >= 0 ; -- i ) { int it = vec [ i ]; bool F = false ; for ( int j = 9 ; j >= 0 ; -- j ) { if ( ! cnt2 [ j ]) continue ; int a = ( it % 3 + 1 ) % 3 ; if ( j % 3 == a ) { vec [ i ] = j ; sum2 = sum2 - it + j ; cnt2 [ j ] -- ; cnt2 [ it ] ++ ; F = true ; break ; } } if ( F ) break ; } for ( int i = k - 1 ; i >= 0 ; -- i ) { int it = vec [ i ]; bool F = false ; for ( int j = 9 ; j >= 0 ; -- j ) { if ( ! cnt2 [ j ]) continue ; int a = ( it % 3 + 1 ) % 3 ; if ( j % 3 == a ) { vec [ i ] = j ; sum2 = sum2 - it + j ; cnt2 [ j ] -- ; cnt2 [ it ] ++ ; F = true ; break ; } } if ( F ) break ; } return sum2 % 3 == 0 ; } int main () { int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { memset ( cnt , 0 , sizeof cnt ); memset ( cnt2 , 0 , sizeof cnt2 ); sum = 0 ; sum2 = 0 ; vec . clear (); scanf ( \"%s %d\" , s + 1 , & k ); n = strlen ( s + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { cnt [ s [ i ] - '0' ] ++ ; cnt2 [ s [ i ] - '0' ] ++ ; } int need = k ; for ( int i = 9 ; i >= 0 ; -- i ) { while ( need > 0 && cnt [ i ]) { vec . push_back ( i ); need -- ; cnt [ i ] -- ; cnt2 [ i ] -- ; sum += i ; sum2 += i ; } } // print(vec); if ( sum % 3 == 0 ) { print ( vec ); continue ; } vec1 = vec ; vec2 = vec ; vec3 = vec ; bool F1 = ok1 ( vec1 ); bool F2 = ok2 ( vec2 ); bool F3 = ok3 ( vec3 ); sort ( vec1 . begin (), vec1 . end ()); reverse ( vec1 . begin (), vec1 . end ()); sort ( vec2 . begin (), vec2 . end ()); reverse ( vec2 . begin (), vec2 . end ()); sort ( vec3 . begin (), vec3 . end ()); reverse ( vec3 . begin (), vec3 . end ()); if ( F1 && ( ! F2 || vec1 >= vec2 ) && ( ! F3 || vec1 >= vec3 )) { print ( vec1 ); } else if ( F2 && ( ! F1 || vec2 >= vec1 ) && ( ! F3 || vec2 >= vec3 )) { print ( vec2 ); } else if ( F3 && ( ! F1 || vec3 >= vec1 ) && ( ! F2 || vec3 >= vec2 )) { print ( vec3 ); } else { puts ( \"-1\" ); } } return 0 ; } I. \u53e4\u8001\u7684\u6253\u5b57\u673a UpSolved By Dup4. \u601d\u8def\uff1a \u5047\u8bbe\u6211\u4eec\u77e5\u9053\u6572\u51fb i i \u6b21\uff0c\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a j j \u7684\u5b57\u7b26\u4e32\u4e2a\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u8fd9\u4e48\u7edf\u8ba1\u7b54\u6848\uff1a \u5bf9\u4e8e\u6bcf\u4e2a s_i s_i \uff0c\u5047\u8bbe\u4e32 t t \u7684\u957f\u5ea6\u4e3a n n \uff0c\u90a3\u4e48\u4e00\u5171\u6709 n - |s_i| + 1 n - |s_i| + 1 \u4e2a\u8d77\u70b9\uff0c\u518d\u4e58\u4e0a\u5b83\u7684\u4ef7\u503c v_i v_i \uff0c\u4ee5\u53ca\u6572\u51fb m m \u6b21\u957f\u5ea6\u4e3a n n \u7684\u5b57\u7b26\u4e32\u4e2a\u6570 f[m][i] f[m][i] \uff0c\u4f46\u662f\u8981\u9664\u53bb 26^{|s_i|} 26^{|s_i|} \uff0c\u56e0\u4e3a\u8fd9 |s_i| |s_i| \u4e2a\u4f4d\u7f6e\u662f\u786e\u5b9a\u4e86\u7684\u3002 \u90a3\u4e48\u518d\u8003\u8651\u5982\u4f55\u6c42 f[i][j] f[i][j] \uff0c\u76f4\u63a5 dp \u5373\u53ef\uff0c\u6709\u5982\u4e0b\u8f6c\u79fb\uff1a \\begin{eqnarray*} f[i][j] = \\left\\{ \\begin{array}{cccc} f[i - 1][0] + f[i - 1][1] && j = 0 \\\\ f[i - 1][j - 1] * 26 && j = i \\\\ f[i - 1][j - 1] * 26 + f[i - 1][j + 1] && other \\end{array} \\right. \\end{eqnarray*} \\begin{eqnarray*} f[i][j] = \\left\\{ \\begin{array}{cccc} f[i - 1][0] + f[i - 1][1] && j = 0 \\\\ f[i - 1][j - 1] * 26 && j = i \\\\ f[i - 1][j - 1] * 26 + f[i - 1][j + 1] && other \\end{array} \\right. \\end{eqnarray*} Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define SZ(x) (int(x.size())) const int N = 1e3 + 10 , mod = 1e9 + 7 ; int n , m , v [ N ], fac [ N ], inv [ N ], bit [ N ], fbit [ N ]; ll f [ N ][ N ]; char s [ N ]; ll qpow ( ll base , ll n ) { ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } ll C ( int n , int m ) { return 1l l * fac [ n ] * inv [ m ] % mod * inv [ n - m ] % mod ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); fac [ 0 ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) fac [ i ] = 1l l * fac [ i - 1 ] * i % mod ; inv [ N - 1 ] = qpow ( fac [ N - 1 ], mod - 2 ); for ( int i = N - 1 ; i >= 1 ; -- i ) inv [ i - 1 ] = 1l l * inv [ i ] * i % mod ; bit [ 0 ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) bit [ i ] = 1l l * bit [ i - 1 ] * 26 % mod ; fbit [ 0 ] = 1 ; fbit [ 1 ] = qpow ( 26 , mod - 2 ); for ( int i = 2 ; i < N ; ++ i ) fbit [ i ] = 1l l * fbit [ i - 1 ] * fbit [ 1 ] % mod ; f [ 0 ][ 0 ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) { for ( int j = 0 ; j <= i ; ++ j ) { if ( ! j ) { f [ i ][ j ] += f [ i - 1 ][ 0 ] + f [ i - 1 ][ 1 ]; f [ i ][ j ] %= mod ; } else if ( j < i ) { f [ i ][ j ] += f [ i - 1 ][ j - 1 ] * 26 + f [ i - 1 ][ j + 1 ]; f [ i ][ j ] %= mod ; } else if ( j == i ) { f [ i ][ j ] += f [ i - 1 ][ j - 1 ] * 26 % mod ; f [ i ][ j ] %= mod ; } } } cin >> n >> m ; vector < string > vec ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) cin >> vec [ i ] >> v [ i ]; ll res = 0 ; for ( int i = 1 ; i <= m ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { int len = SZ ( vec [ j ]); if ( i >= len ) { res += f [ m ][ i ] * ( i - len + 1 ) % mod * v [ j ] % mod * fbit [ len ] % mod ; res %= mod ; } } } printf ( \"%lld \\n \" , res ); return 0 ; } J. \u80fd\u5230\u8fbe\u5417 UpSolved By Dup4. \u601d\u8def\uff1a \u8003\u8651\u66b4\u529b\u600e\u4e48\u505a\uff0c\u6bcf\u4e2a\u70b9\u5f80\u56db\u5468\u5408\u5e76\uff0c\u4e00\u4e2a\u8054\u901a\u5757\u7684\u8d21\u732e\u662f \\displaystyle {n \\choose 2} + n \\displaystyle {n \\choose 2} + n \u3002 \u90a3\u4e48\u5bf9\u4e8e n \\cdot m n \\cdot m \u7684\u56fe\uff0c\u6309\u884c\u679a\u4e3e\uff0c\u6bcf\u4e00\u884c\u8fde\u7eed\u7684\u7a7a\u5730\u7f29\u6210\u4e00\u4e2a\u70b9\uff0c\u8fd9\u6837\u5bf9\u4e8e\u5355\u7ec4\u6570\u636e\u7684\u590d\u6742\u5ea6\u662f\u5bf9\u7684\u3002 \u4f46\u662f\u8fd9\u91cc\u662f T T \u7ec4\u6570\u636e\uff0c\u6240\u4ee5\u4e0d\u80fd\u6309\u884c\u679a\u4e3e\uff0c\u53ea\u80fd\u679a\u4e3e\u6709\u969c\u788d\u7269\u7684\u884c\uff0c\u5bf9\u4e8e\u8fde\u7eed\u7684\u6574\u884c\u90fd\u662f\u7a7a\u5730\u7684\u884c\u4e5f\u8981\u7f29\u70b9\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; using pII = pair < int , int > ; #define fi first #define se second #define SZ(x) (int(x.size())) #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 2e6 + 10 , M = 2e5 + 10 ; const int mod = 1e9 + 7 , inv2 = ( mod + 1 ) / 2 ; int n , m , K ; struct UFS { int fa [ N ]; ll sze [ N ]; int tot ; void init () { tot = 0 ; } int newnode ( ll _sze ) { ++ tot ; fa [ tot ] = 0 ; sze [ tot ] = _sze ; return tot ; } int find ( int x ) { return fa [ x ] == 0 ? x : fa [ x ] = find ( fa [ x ]); } bool merge ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( fx != fy ) { if ( sze [ fx ] > sze [ fy ]) swap ( fx , fy ); fa [ fx ] = fy ; sze [ fy ] += sze [ fx ]; return true ; } return false ; } } ufs ; inline ll C ( ll n ) { return ( 1l l * ( n % mod ) * (( n - 1 ) % mod ) % mod * inv2 % mod + n % mod ) % mod ; } struct E { int l , r , id ; bool cross ( const E & other ) const { if (( l >= other . l && l <= other . r ) || ( r >= other . l && r <= other . r ) || ( other . l >= l && other . l <= r ) || ( other . r >= l && other . r <= r )) return 1 ; return 0 ; } }; vector < vector < int >> vec ( M ); vector < vector < E >> seg ( M ); vector < int > has ; void gao () { if ( K == 0 ) { ll res = C ( 1l l * n * m ); printf ( \"%lld \\n \" , res ); return ; } ufs . init (); sort ( has . begin (), has . end ()); has . erase ( unique ( has . begin (), has . end ()), has . end ()); for ( int i = 0 ; i < SZ ( has ); ++ i ) { int p = has [ i ]; int pre = 0 ; sort ( vec [ p ]. begin (), vec [ p ]. end ()); for ( auto & it : vec [ p ]) { if ( it - 1 > pre ) { E tmp = { pre + 1 , it - 1 , ufs . newnode ( it - 1 - pre )}; // dbg(tmp.l, tmp.r, tmp.id, ufs.sze[tmp.id]); seg [ p ]. push_back ( tmp ); } pre = it ; } if ( pre < m ) { E tmp = { pre + 1 , m , ufs . newnode ( m - pre )}; seg [ p ]. push_back ( tmp ); } // for (auto &it : seg[p]) { // dbg(it.l, it.r); // } if ( i == 0 ) { if ( p > 1 ) { int node = ufs . newnode ( 1l l * ( p - 1 ) * m ); for ( auto & it : seg [ p ]) { ufs . merge ( node , it . id ); } } } else { int preP = has [ i - 1 ]; if ( preP + 1 < p ) { int node = ufs . newnode ( 1l l * ( p - preP - 1 ) * m ); for ( auto & it : seg [ p ]) { ufs . merge ( node , it . id ); } for ( auto & it : seg [ preP ]) { ufs . merge ( node , it . id ); } } else { int pos = 0 ; for ( auto & it : seg [ p ]) { while ( pos < SZ ( seg [ preP ])) { E it2 = seg [ preP ][ pos ]; if ( it . cross ( it2 )) { ufs . merge ( it . id , it2 . id ); } if ( it2 . r <= it . r ) ++ pos ; else break ; } } } } if ( i == SZ ( has ) - 1 ) { if ( p < n ) { int node = ufs . newnode ( 1l l * ( n - p ) * m ); // dbg(ufs.sze[node]); for ( auto & it : seg [ p ]) { ufs . merge ( node , it . id ); // dbg(it.l, it.r, it.id, ufs.sze[node]); } } } } for ( auto & it : has ) { vec [ it ]. clear (); seg [ it ]. clear (); } ll res = 0 ; for ( int i = 1 ; i <= ufs . tot ; ++ i ) { if ( ufs . fa [ i ] == 0 ) { // dbg(i, ufs.sze[i]); res += C ( ufs . sze [ i ]); res %= mod ; } } printf ( \"%lld \\n \" , res ); } int main () { int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d%d%d\" , & n , & m , & K ); has . clear (); for ( int i = 1 , x , y ; i <= K ; ++ i ) { scanf ( \"%d%d\" , & x , & y ); has . push_back ( x ); vec [ x ]. push_back ( y ); } gao (); } return 0 ; } K. \u8ff7\u5bab Solved By Dup4. 3:36(+3) \u601d\u8def\uff1a \u4ece\u8d77\u70b9\u548c\u7ec8\u70b9\u5206\u522b bfs \u5230\u6bcf\u4e2a\u70b9\u7684\u6700\u77ed\u8def\uff0c\u7136\u540e\u679a\u4e3e\u4e00\u4e2a\u70b9\uff0c\u76f8\u5f53\u4e8e\u627e\u77e9\u5f62\u6846\u5185\u7684\u6700\u5c0f\u503c\u3002 \u6ce8\u610f\u5230\u77e9\u5f62\u6846\u5927\u5c0f\u4e00\u81f4\uff0c\u8003\u8651\u4ece\u4e0a\u5f80\u4e0b\u679a\u4e3e\uff0c\u6bcf\u6b21\u591a\u4e00\u884c\uff0c\u7528 m m \u4e2a\u5355\u8c03\u961f\u5217\u7ef4\u62a4\u6bcf\u4e00\u5217 2d 2d \u4e2a\u5143\u7d20\u7684\u6700\u5c0f\u503c\uff0c\u7136\u540e\u4ece\u5de6\u5f80\u53f3\u679a\u4e3e\u7684\u65f6\u5019\uff0c\u518d\u6765\u4e00\u4e2a\u5355\u8c03\u961f\u5217\u3002 \u8d5b\u65f6\u6bd4\u8f83\u8822\uff0c\u65e0\u8111\u4e86\u4e00\u4e2a\u7ebf\u6bb5\u6811\uff0c\u4f46\u5b9e\u9645\u4e0a\u51fa\u9898\u4eba\u53ef\u4ee5\u76f4\u63a5\u5361\u5230 O(nm) O(nm) \u3002 Code #include <bits/stdc++.h> using namespace std ; using pII = pair < int , int > ; #define SZ(x) (int(x.size())) #define fi first #define se second #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 2e3 + 10 , INF = 1e9 ; int n , m , d , sx , sy , ex , ey , a [ N ]; pII b [ N ]; char G [ N ][ N ]; int Move [][ 2 ] = { 1 , 0 , -1 , 0 , 0 , 1 , 0 , -1 }; struct BFS { int dis [ N ][ N ]; pII pre [ N ][ N ]; bool ok ( int x , int y ) { if ( x < 1 || x > n || y < 1 || y > m || G [ x ][ y ] == 'X' ) return 0 ; return 1 ; } void gao ( int sx , int sy ) { for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { dis [ i ][ j ] = INF ; pre [ i ][ j ] = pII ( -1 , -1 ); } } dis [ sx ][ sy ] = 0 ; queue < pII > que ; que . push ( pII ( sx , sy )); while ( ! que . empty ()) { int x = que . front (). fi , y = que . front (). se ; que . pop (); for ( int i = 0 ; i < 4 ; ++ i ) { int nx = x + Move [ i ][ 0 ]; int ny = y + Move [ i ][ 1 ]; if ( ok ( nx , ny ) && dis [ nx ][ ny ] > dis [ x ][ y ] + 1 ) { dis [ nx ][ ny ] = dis [ x ][ y ] + 1 ; pre [ nx ][ ny ] = pII ( x , y ); que . push ( pII ( nx , ny )); } } } } } f , g ; struct DEQUE { int que [ N ], head , tail ; void init () { head = 1 , tail = 0 ; } } q [ N ]; struct SEG { struct node { int Min ; pII pos ; node () { Min = INF ; pos = pII ( -1 , -1 ); } node operator + ( const node & other ) const { node res = node (); if ( Min < other . Min ) { res . Min = Min ; res . pos = pos ; } else { res . Min = other . Min ; res . pos = other . pos ; } return res ; } } t [ N << 2 ], res ; void build ( int id , int l , int r ) { t [ id ] = node (); if ( l == r ) { t [ id ]. Min = a [ l ]; t [ id ]. pos = b [ l ]; return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); t [ id ] = t [ id << 1 ] + t [ id << 1 | 1 ]; } // void update(int id, int l, int r, int pos, int v) { // if (l == r) { // t[id].Min = v; // return; // } // int mid = (l + r) >> 1; // if (pos <= mid) update(id << 1, l, mid, ql, qr, v); // else update(id << 1 | 1, mid + 1, r, ql, qr, v); // t[id] = t[id << 1] + t[id << 1 | 1]; // } void query ( int id , int l , int r , int ql , int qr ) { if ( l >= ql && r <= qr ) { res = res + t [ id ]; return ; } int mid = ( l + r ) >> 1 ; if ( ql <= mid ) query ( id << 1 , l , mid , ql , qr ); if ( qr > mid ) query ( id << 1 | 1 , mid + 1 , r , ql , qr ); } } seg ; int main () { scanf ( \"%d%d%d\" , & n , & m , & d ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%s\" , G [ i ] + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( G [ i ][ j ] == 'S' ) { sx = i , sy = j ; } else if ( G [ i ][ j ] == 'T' ) { ex = i , ey = j ; } } } // dbg(sx, sy, ex, ey); f . gao ( sx , sy ); g . gao ( ex , ey ); // for (int i = 1; i <= n; ++i) { // for (int j = 1; j <= m; ++j) { // dbg(i, j, f.dis[i][j]); // } // } // for (int i = 1; i <= n; ++i) { // for (int j = 1; j <= m; ++j) { // dbg(i, j, g.dis[i][j]); // } // } for ( int i = 1 ; i <= m ; ++ i ) q [ i ]. init (); int up = 1 , down = 0 ; pII A = pII ( ex , ey ), B = pII ( -1 , -1 ); int dis = f . dis [ ex ][ ey ]; for ( int i = 1 ; i <= n ; ++ i ) { up = max ( 1 , i - d ); int _down = min ( n , i + d ); while ( down < _down ) { ++ down ; for ( int j = 1 ; j <= m ; ++ j ) { while ( q [ j ]. head <= q [ j ]. tail && g . dis [ q [ j ]. que [ q [ j ]. tail ]][ j ] >= g . dis [ down ][ j ]) -- q [ j ]. tail ; q [ j ]. que [ ++ q [ j ]. tail ] = down ; } } for ( int j = 1 ; j <= m ; ++ j ) { while ( q [ j ]. head <= q [ j ]. tail && q [ j ]. que [ q [ j ]. head ] < up ) ++ q [ j ]. head ; a [ j ] = g . dis [ q [ j ]. que [ q [ j ]. head ]][ j ]; b [ j ] = pII ( q [ j ]. que [ q [ j ]. head ], j ); } seg . build ( 1 , 1 , m ); for ( int j = 1 ; j <= m ; ++ j ) if ( G [ i ][ j ] != 'X' ) { int l = max ( 1 , j - d ); int r = min ( m , j + d ); seg . res = SEG :: node (); seg . query ( 1 , 1 , m , l , r ); pII _A = pII ( i , j ); pII _B = seg . res . pos ; int _dis = f . dis [ i ][ j ] + seg . res . Min + 1 ; if ( _dis <= dis ) { // dbg(i, j, f.dis[i][j], g.dis[_B.fi][_B.se], _B.fi, _B.se); dis = _dis ; A = _A ; B = _B ; } } } if ( dis >= INF ) puts ( \"-1\" ); else { printf ( \"%d \\n \" , dis ); vector < pII > vecA , vecB ; while ( A != pII ( -1 , -1 )) { vecA . push_back ( A ); A = f . pre [ A . fi ][ A . se ]; } while ( B != pII ( -1 , -1 )) { vecB . push_back ( B ); B = g . pre [ B . fi ][ B . se ]; } reverse ( vecA . begin (), vecA . end ()); for ( int i = 0 ; i < SZ ( vecA ); ++ i ) { printf ( \"%d %d \\n \" , vecA [ i ]. fi - 1 , vecA [ i ]. se - 1 ); } for ( int i = 0 ; i < SZ ( vecB ); ++ i ) { printf ( \"%d %d \\n \" , vecB [ i ]. fi - 1 , vecB [ i ]. se - 1 ); } } return 0 ; } L. \u52a8\u7269\u68ee\u53cb\u4f1a Solved By Hsueh-. 3:11(+) \u601d\u8def\uff1a \u8003\u8651\u4e8c\u5206\u65f6\u95f4\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u77e5\u9053\u4e86\u6bcf\u4e2a\u65e5\u5b50\u6709\u51e0\u5929\uff0c\u5efa\u7acb\u7f51\u7edc\u6d41\u53bb\u5224\u65ad\uff0c\u5176\u4e2d\u5de6\u8fb9\u4e3a\u4efb\u52a1\uff0c\u5411\u53f3\u8fb9\u7684\u661f\u671f\u51e0\u6d41\u9700\u8981\u7684\u9700\u6c42 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const ll INF = 0x3f3f3f3f3f3f3f3f ; template < class Type > struct Dinic { static const int M = 1e6 + 10 ; static const int N = 1e5 + 10 ; struct Edge { int to , nxt ; Type flow ; Edge () {} Edge ( int to , int nxt , Type flow ) : to ( to ), nxt ( nxt ), flow ( flow ) {} } edge [ M ]; int S , T ; int head [ N ], tot ; int dep [ N ]; void init () { memset ( head , -1 , sizeof head ); tot = 0 ; } void set ( int S , int T ) { this -> S = S ; this -> T = T ; } void addedge ( int u , int v , ll w , ll rw = 0 ) { // dbg(u, v, w); edge [ tot ] = Edge ( v , head [ u ], w ); head [ u ] = tot ++ ; edge [ tot ] = Edge ( u , head [ v ], rw ); head [ v ] = tot ++ ; } bool BFS () { memset ( dep , -1 , sizeof dep ); queue < int > q ; q . push ( S ); dep [ S ] = 1 ; while ( ! q . empty ()) { int u = q . front (); q . pop (); for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { if ( edge [ i ]. flow && dep [ edge [ i ]. to ] == -1 ) { dep [ edge [ i ]. to ] = dep [ u ] + 1 ; q . push ( edge [ i ]. to ); } } } return dep [ T ] >= 0 ; } Type DFS ( int u , Type f ) { if ( u == T || f == 0 ) return f ; Type w , used = 0 ; for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { if ( edge [ i ]. flow && dep [ edge [ i ]. to ] == dep [ u ] + 1 ) { w = DFS ( edge [ i ]. to , min ( f - used , edge [ i ]. flow )); edge [ i ]. flow -= w ; edge [ i ^ 1 ]. flow += w ; used += w ; if ( used == f ) return f ; } } if ( ! used ) dep [ u ] = -1 ; return used ; } Type solve () { Type ans = 0 ; while ( BFS ()) { ans += DFS ( S , INF ); } return ans ; } }; Dinic < ll > dinic ; const int N = 1e3 + 10 ; int n , e ; ll sum ; ll cnt [ 20 ]; ll c [ N ]; int a [ N ][ 10 ]; bool ok ( int x ) { memset ( cnt , 0 , sizeof cnt ); for ( int i = 1 ; i <= 7 ; ++ i ) { cnt [ i ] = x / 7 ; if ( x % 7 >= i ) cnt [ i ] ++ ; } dinic . init (); int S = 0 , T = n + 10 ; dinic . set ( S , T ); for ( int i = 1 ; i <= n ; ++ i ) { dinic . addedge ( S , i , c [ i ]); for ( int j = 1 ; j <= a [ i ][ 0 ]; ++ j ) { dinic . addedge ( i , n + a [ i ][ j ], c [ i ]); } } for ( int i = 1 ; i <= 7 ; ++ i ) { dinic . addedge ( n + i , T , cnt [ i ] * e ); } ll res = dinic . solve (); // dbg(res, sum); return res >= sum ; } int main () { scanf ( \"%d %d\" , & n , & e ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld %d\" , c + i , & a [ i ][ 0 ]); for ( int j = 1 ; j <= a [ i ][ 0 ]; ++ j ) { scanf ( \"%d\" , & a [ i ][ j ]); } sum += c [ i ]; } ll l = 0 , r = 1e9 , res = -1 ; // ok(5); while ( r - l >= 0 ) { ll mid = ( l + r ) >> 1 ; if ( ok ( mid )) { r = mid - 1 ; res = mid ; } else { l = mid + 1 ; } } printf ( \"%lld \\n \" , res ); return 0 ; }","title":"\u201c\u79d1\u5927\u8baf\u98de\u676f\u201d\u7b2c18\u5c4a\u4e0a\u6d77\u5927\u5b66\u7a0b\u5e8f\u8bbe\u8ba1\u8054\u8d5b\u6625\u5b63\u8d5b\u66a8\u9ad8\u6821\u7f51\u7edc\u53cb\u8c0a\u8d5b"},{"location":"trainings/random-trainings/18th-SHU-CPC/#contest-info","text":"Practice Link Solved A B C D E F G H I J K L 12/12 O O O O O O \u00d8 O \u00d8 \u00d8 O O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5","title":"Contest Info"},{"location":"trainings/random-trainings/18th-SHU-CPC/#solutions","text":"","title":"Solutions"},{"location":"trainings/random-trainings/18th-SHU-CPC/#a-\u7ec4\u961f\u6bd4\u8d5b","text":"Solved By Hsueh-. 0:04(+) \u7b7e\u5230\u3002","title":"A. \u7ec4\u961f\u6bd4\u8d5b"},{"location":"trainings/random-trainings/18th-SHU-CPC/#b-\u6bcf\u65e5\u4e00\u62a5","text":"Solved By Hsueh-. 0:20(+2) \u7b7e\u5230\u3002","title":"B. \u6bcf\u65e5\u4e00\u62a5"},{"location":"trainings/random-trainings/18th-SHU-CPC/#c-\u6700\u957f\u975e\u516c\u5171\u5b50\u5e8f\u5217","text":"Solved By Hsueh-. 0:07(+) \u7b7e\u5230\u3002","title":"C. \u6700\u957f\u975e\u516c\u5171\u5b50\u5e8f\u5217"},{"location":"trainings/random-trainings/18th-SHU-CPC/#d-\u6700\u5927\u5b57\u7b26\u96c6","text":"Solved By Hsueh-. 0:41(+) \u601d\u8def\uff1a \u7279\u5224 1 1 \u548c 2 2 \uff0c\u7136\u540e\u5bf9\u4e8e n > 2 n > 2 \u7684\uff0c\u5982\u4e0b\u6784\u9020\uff1a \u4f8b\u5982 n = 5 n = 5 \uff1a 00 010 0110 01110 Code #include <bits/stdc++.h> using namespace std ; int n ; int main () { scanf ( \"%d\" , & n ); if ( n == 1 ) { printf ( \"%d \\n \" , 1 ); printf ( \"%d \\n \" , 1 ); } else if ( n == 2 ) { printf ( \"%d \\n \" , 2 ); puts ( \"0\" ); puts ( \"11\" ); } else { printf ( \"%d \\n \" , n - 1 ); for ( int i = 2 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= i ; ++ j ) { if ( j == 1 || j == i ) printf ( \"0\" ); else printf ( \"1\" ); } puts ( \"\" ); } } return 0 ; }","title":"D. \u6700\u5927\u5b57\u7b26\u96c6"},{"location":"trainings/random-trainings/18th-SHU-CPC/#e-\u7f8e\u5473\u7684\u5e8f\u5217","text":"Solved By ltslts. 0:16(+) \u601d\u8def\uff1a \u4e0b\u964d\u7684\u7f8e\u5473\u5ea6\u662f\u56fa\u5b9a\u7684\u3002 Code #include <bits/stdc++.h> using namespace std ; int main () { int n ; scanf ( \"%d\" , & n ); long long ans = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { int x ; scanf ( \"%d\" , & x ); ans += x ; } ans -= 1l l * n * ( n - 1 ) / 2 ; printf ( \"%lld \\n \" , ans ); return 0 ; }","title":"E. \u7f8e\u5473\u7684\u5e8f\u5217"},{"location":"trainings/random-trainings/18th-SHU-CPC/#f-\u65e5\u671f\u5c0f\u52a9\u624b","text":"Solved By Dup4. 0:37(+) \u601d\u8def\uff1a \u627e\u51fa\u5f53\u5e74\u548c\u4e0b\u5e74\u7684\u6bcd\u4eb2\u8282\u3001\u7236\u4eb2\u8282\uff0c\u53d6\u5408\u6cd5\u7684\uff0c\u6700\u5c0f\u7684\u3002 Code #include <bits/stdc++.h> using namespace std ; struct node { int y , m , d ; node ( int y = 0 , int m = 0 , int d = 0 ) : y ( y ), m ( m ), d ( d ) {} bool operator < ( const node & other ) const { if ( y != other . y ) return y < other . y ; if ( m != other . m ) return m < other . m ; return d < other . d ; } bool operator == ( const node & other ) const { return y == other . y && m == other . m && d == other . d ; } }; int getweek ( int y , int m , int d ) { int ans ; if ( m == 1 || m == 2 ) m += 12 , y -- ; if (( y < 1752 ) || ( y == 1752 && m < 9 ) || ( y == 1752 && m == 9 && d < 3 )) { ans = ( d + 2 * m + 3 * ( m + 1 ) / 5 + y + y / 4 + 5 ) % 7 ; } else { ans = ( d + 2 * m + 3 * ( m + 1 ) / 5 + y + y / 4 - y / 100 + y / 400 ) % 7 ; } ans = ( d + 2 * m + 3 * ( m + 1 ) / 5 + y + y / 4 - y / 100 + y / 400 ) % 7 ; return ans + 1 ; } int main () { int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { int y , m , d ; scanf ( \"%d%d%d\" , & y , & m , & d ); node A = node ( y , m , d ); vector < node > vec [ 2 ]; for ( int i = y ; i <= y + 1 ; ++ i ) { for ( int j = 1 , cnt = 0 ; j <= 31 ; ++ j ) { if ( getweek ( i , 5 , j ) == 7 ) { ++ cnt ; if ( cnt == 2 ) { vec [ 0 ]. emplace_back ( i , 5 , j ); break ; } } } for ( int j = 1 , cnt = 0 ; j <= 30 ; ++ j ) { if ( getweek ( i , 6 , j ) == 7 ) { ++ cnt ; if ( cnt == 3 ) { vec [ 1 ]. emplace_back ( i , 6 , j ); break ; } } } } node B = node (); ; int flag = -1 ; for ( auto & it : vec [ 0 ]) { if ( ! ( A == it ) && A < it ) { if ( flag == -1 ) { flag = 0 ; B = it ; } else if ( it < B ) { flag = 0 ; B = it ; } } } for ( auto & it : vec [ 1 ]) { if ( ! ( A == it ) && A < it ) { if ( flag == -1 ) { flag = 1 ; B = it ; } else if ( it < B ) { flag = 1 ; B = it ; } } } if ( ! flag ) printf ( \"Mother's Day: May \" ); else printf ( \"Father's Day: June \" ); string s = \"th\" ; if ( B . d == 1 || B . d == 21 || B . d == 31 ) s = \"st\" ; if ( B . d == 2 || B . d == 22 || B . d == 32 ) s = \"nd\" ; if ( B . d == 3 || B . d == 23 || B . d == 33 ) s = \"rd\" ; cout << B . d << s << \", \" << B . y << \" \\n \" ; } return 0 ; }","title":"F. \u65e5\u671f\u5c0f\u52a9\u624b"},{"location":"trainings/random-trainings/18th-SHU-CPC/#g-\u8840\u538b\u6e38\u620f","text":"UpSolved By Dup4. \u601d\u8def\uff1a \u8003\u8651\u53ea\u6709\u540c\u4e00\u6df1\u5ea6\u7684\u70b9\u624d\u4f1a\u6253\u67b6\uff0c\u90a3\u4e48\u53ef\u4ee5\u76f4\u63a5\u505a\u4e00\u4e2a\u57fa\u4e8e\u6df1\u5ea6\u7684 dp\uff0c\u542c\u7fa4\u91cc\u8bf4\u6309\u6df1\u5ea6\u5206\u7c7b\uff0c\u5bf9\u6bcf\u4e2a\u865a\u6811 dfs \u4e5f\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; using pIL = pair < int , ll > ; #define fi first #define se second #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 2e5 + 10 ; int n , rt , use [ N ], a [ N ]; vector < vector < int >> G ; int fa [ N ], md [ N ], hson [ N ], deep [ N ]; void pre ( int u ) { hson [ u ] = 0 ; for ( auto & v : G [ u ]) { if ( v == fa [ u ]) continue ; fa [ v ] = u ; deep [ v ] = deep [ u ] + 1 ; pre ( v ); if ( ! hson [ u ] || md [ v ] > md [ hson [ u ]]) hson [ u ] = v ; } md [ u ] = md [ hson [ u ]] + 1 ; } pIL tmp [ N << 2 ], * f [ N ], * id = tmp ; void dfs ( int u ) { if ( hson [ u ]) { int v = hson [ u ]; f [ v ] = f [ u ] + 1 ; dfs ( v ); } for ( auto & v : G [ u ]) { if ( v == fa [ u ] || v == hson [ u ]) continue ; f [ v ] = id ; id += md [ v ] * 2 ; dfs ( v ); } f [ u ][ 0 ] = pIL ( deep [ u ], a [ u ]); for ( auto & v : G [ u ]) { if ( v == fa [ u ] || v == hson [ u ]) continue ; for ( int i = 1 ; i <= md [ v ]; ++ i ) if ( f [ u ][ i ]. se || f [ v ][ i - 1 ]. se ) { if ( f [ u ][ i ]. se == 0 ) f [ u ][ i ]. fi = deep [ v ]; if ( f [ u ][ i ]. fi > deep [ v ]) { int need = f [ u ][ i ]. fi - deep [ v ]; f [ u ][ i ]. se = max ( 1l l , f [ u ][ i ]. se - need ); f [ u ][ i ]. fi = deep [ u ] + 1 ; } if ( f [ v ][ i - 1 ]. se == 0 ) f [ v ][ i - 1 ]. fi = deep [ v ]; if ( f [ v ][ i - 1 ]. fi > deep [ v ]) { int need = f [ v ][ i - 1 ]. fi - deep [ v ]; f [ v ][ i - 1 ]. se = max ( 1l l , f [ v ][ i - 1 ]. se - need ); f [ v ][ i - 1 ]. fi = deep [ v ]; } f [ u ][ i ]. se += f [ v ][ i - 1 ]. se ; if ( use [ i ] == 0 && f [ u ][ i ]. se > 1 ) { -- f [ u ][ i ]. se ; use [ i ] = 1 ; } f [ u ][ i ]. fi = deep [ u ]; } } for ( auto & v : G [ u ]) { if ( v == fa [ u ] || v == hson [ u ]) continue ; for ( int i = 0 ; i <= md [ v ]; ++ i ) { use [ i ] = 0 ; } } } int main () { scanf ( \"%d%d\" , & n , & rt ); memset ( use , 0 , sizeof use ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); if ( a [ i ] > 1 ) -- a [ i ]; } G . clear (); G . resize ( n + 1 ); for ( int i = 1 , u , v ; i < n ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); G [ u ]. push_back ( v ); G [ v ]. push_back ( u ); } fa [ rt ] = rt ; deep [ rt ] = 1 ; pre ( rt ); f [ rt ] = id ; id += md [ rt ] * 2 ; dfs ( rt ); ll res = 0 ; for ( int i = 0 ; i <= md [ rt ]; ++ i ) if ( f [ rt ][ i ]. se > 0 ) { // dbg(i, f[rt][i].se); if ( f [ rt ][ i ]. fi > 1 ) { int need = f [ rt ][ i ]. fi - 1 ; f [ rt ][ i ]. se = max ( 1l l , f [ rt ][ i ]. se - need ); } res += f [ rt ][ i ]. se ; } printf ( \"%lld \\n \" , res ); return 0 ; }","title":"G. \u8840\u538b\u6e38\u620f"},{"location":"trainings/random-trainings/18th-SHU-CPC/#h-\u7eb8\u724c\u6e38\u620f","text":"Solved By Hsueh- & ltslts. 4:56(+7) \u601d\u8def\uff1a \u8d2a\u5fc3\u53d6\u524d k k \u4e2a\uff0c\u7136\u540e\u5982\u679c\u4e0d\u5408\u6cd5\uff0c\u8003\u8651\u4fee\u6539\u51e0\u4f4d\uff0c\u663e\u7136\u6700\u591a\u4fee\u6539\u4e24\u4f4d\uff0c\u56e0\u6b64\u8fdb\u884c\u5206\u7c7b\uff1a \u4ece\u5c0f\u5230\u5927\u66b4\u529b\u5224\u65ad\u6bcf\u4e00\u4f4d\u4fee\u6539\u4e3a 9-0 9-0 \u7684\u7ed3\u679c\u3002 \u4fee\u6539\u4e24\u4f4d\u540c\u6837\u662f\u4ece\u5c0f\u5230\u5927\u66b4\u529b\u4fee\u6539\u6bcf\u4e00\u4f4d\uff0c\u8003\u8651\u5230\u5f53\u524d\u662f\u4fee\u6539\u4e24\u4f4d\uff0c\u6240\u4ee5\u53ea\u53ef\u80fd\u662f\u9009\u4e24\u4e2a\u6570\u5b57\u6539\u4e3a \\% \\; 3 \\% \\; 3 \u540e\u51cf\u5c11\u4e00\u6216\u8005 \\% \\; 3 \\% \\; 3 \u540e\u589e\u52a0\u4e00\uff0c\u66b4\u529b\u5224\u65ad\u5373\u53ef\u3002 \u6700\u540e\u6392\u5e8f\u4e00\u4e0b\u5224\u65ad\u4e09\u79cd\u60c5\u51b5\u5927\u5c0f \u6ce8\u610f\u7279\u5224\u524d\u5bfc\u96f6 1 733110 3 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } int n , k , sum , sum2 ; char s [ N ]; int cnt [ 20 ], cnt2 [ 20 ]; vector < int > vec , vec1 , vec2 , vec3 ; bool cmp ( vector < int > V1 , vector < int > V2 ) { for ( int i = 0 ; i < k ; ++ i ) { if ( V1 > V2 ) return true ; if ( V1 < V2 ) return false ; } return true ; } void print ( vector < int > V ) { sort ( V . begin (), V . end ()); reverse ( V . begin (), V . end ()); if ( V [ 0 ] == 0 && V . size () > 1 ) { puts ( \"-1\" ); return ; } for ( auto it : V ) { printf ( \"%d\" , it ); } puts ( \"\" ); } bool ok1 ( vector < int >& vec ) { for ( int i = k - 1 ; i >= 0 ; -- i ) { int it = vec [ i ]; for ( int j = 9 ; j >= 0 ; -- j ) { if ( ! cnt [ j ]) continue ; if (( sum - it + j ) % 3 == 0 ) { vec [ i ] = j ; return true ; } } } return false ; } bool ok2 ( vector < int >& vec ) { for ( int i = k - 1 ; i >= 0 ; -- i ) { int it = vec [ i ]; bool F = false ; for ( int j = 9 ; j >= 0 ; -- j ) { if ( ! cnt [ j ]) continue ; int a = ( it % 3 + 2 ) % 3 ; if ( j % 3 == a ) { vec [ i ] = j ; sum = sum - it + j ; cnt [ j ] -- ; cnt [ it ] ++ ; F = true ; break ; } } if ( F ) break ; } for ( int i = k - 1 ; i >= 0 ; -- i ) { int it = vec [ i ]; bool F = false ; for ( int j = 9 ; j >= 0 ; -- j ) { if ( ! cnt [ j ]) continue ; int a = ( it % 3 + 2 ) % 3 ; if ( j % 3 == a ) { vec [ i ] = j ; sum = sum - it + j ; cnt [ j ] -- ; cnt [ it ] ++ ; F = true ; break ; } } if ( F ) break ; } return sum % 3 == 0 ; } bool ok3 ( vector < int >& vec ) { for ( int i = k - 1 ; i >= 0 ; -- i ) { int it = vec [ i ]; bool F = false ; for ( int j = 9 ; j >= 0 ; -- j ) { if ( ! cnt2 [ j ]) continue ; int a = ( it % 3 + 1 ) % 3 ; if ( j % 3 == a ) { vec [ i ] = j ; sum2 = sum2 - it + j ; cnt2 [ j ] -- ; cnt2 [ it ] ++ ; F = true ; break ; } } if ( F ) break ; } for ( int i = k - 1 ; i >= 0 ; -- i ) { int it = vec [ i ]; bool F = false ; for ( int j = 9 ; j >= 0 ; -- j ) { if ( ! cnt2 [ j ]) continue ; int a = ( it % 3 + 1 ) % 3 ; if ( j % 3 == a ) { vec [ i ] = j ; sum2 = sum2 - it + j ; cnt2 [ j ] -- ; cnt2 [ it ] ++ ; F = true ; break ; } } if ( F ) break ; } return sum2 % 3 == 0 ; } int main () { int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { memset ( cnt , 0 , sizeof cnt ); memset ( cnt2 , 0 , sizeof cnt2 ); sum = 0 ; sum2 = 0 ; vec . clear (); scanf ( \"%s %d\" , s + 1 , & k ); n = strlen ( s + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { cnt [ s [ i ] - '0' ] ++ ; cnt2 [ s [ i ] - '0' ] ++ ; } int need = k ; for ( int i = 9 ; i >= 0 ; -- i ) { while ( need > 0 && cnt [ i ]) { vec . push_back ( i ); need -- ; cnt [ i ] -- ; cnt2 [ i ] -- ; sum += i ; sum2 += i ; } } // print(vec); if ( sum % 3 == 0 ) { print ( vec ); continue ; } vec1 = vec ; vec2 = vec ; vec3 = vec ; bool F1 = ok1 ( vec1 ); bool F2 = ok2 ( vec2 ); bool F3 = ok3 ( vec3 ); sort ( vec1 . begin (), vec1 . end ()); reverse ( vec1 . begin (), vec1 . end ()); sort ( vec2 . begin (), vec2 . end ()); reverse ( vec2 . begin (), vec2 . end ()); sort ( vec3 . begin (), vec3 . end ()); reverse ( vec3 . begin (), vec3 . end ()); if ( F1 && ( ! F2 || vec1 >= vec2 ) && ( ! F3 || vec1 >= vec3 )) { print ( vec1 ); } else if ( F2 && ( ! F1 || vec2 >= vec1 ) && ( ! F3 || vec2 >= vec3 )) { print ( vec2 ); } else if ( F3 && ( ! F1 || vec3 >= vec1 ) && ( ! F2 || vec3 >= vec2 )) { print ( vec3 ); } else { puts ( \"-1\" ); } } return 0 ; }","title":"H. \u7eb8\u724c\u6e38\u620f"},{"location":"trainings/random-trainings/18th-SHU-CPC/#i-\u53e4\u8001\u7684\u6253\u5b57\u673a","text":"UpSolved By Dup4. \u601d\u8def\uff1a \u5047\u8bbe\u6211\u4eec\u77e5\u9053\u6572\u51fb i i \u6b21\uff0c\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a j j \u7684\u5b57\u7b26\u4e32\u4e2a\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u8fd9\u4e48\u7edf\u8ba1\u7b54\u6848\uff1a \u5bf9\u4e8e\u6bcf\u4e2a s_i s_i \uff0c\u5047\u8bbe\u4e32 t t \u7684\u957f\u5ea6\u4e3a n n \uff0c\u90a3\u4e48\u4e00\u5171\u6709 n - |s_i| + 1 n - |s_i| + 1 \u4e2a\u8d77\u70b9\uff0c\u518d\u4e58\u4e0a\u5b83\u7684\u4ef7\u503c v_i v_i \uff0c\u4ee5\u53ca\u6572\u51fb m m \u6b21\u957f\u5ea6\u4e3a n n \u7684\u5b57\u7b26\u4e32\u4e2a\u6570 f[m][i] f[m][i] \uff0c\u4f46\u662f\u8981\u9664\u53bb 26^{|s_i|} 26^{|s_i|} \uff0c\u56e0\u4e3a\u8fd9 |s_i| |s_i| \u4e2a\u4f4d\u7f6e\u662f\u786e\u5b9a\u4e86\u7684\u3002 \u90a3\u4e48\u518d\u8003\u8651\u5982\u4f55\u6c42 f[i][j] f[i][j] \uff0c\u76f4\u63a5 dp \u5373\u53ef\uff0c\u6709\u5982\u4e0b\u8f6c\u79fb\uff1a \\begin{eqnarray*} f[i][j] = \\left\\{ \\begin{array}{cccc} f[i - 1][0] + f[i - 1][1] && j = 0 \\\\ f[i - 1][j - 1] * 26 && j = i \\\\ f[i - 1][j - 1] * 26 + f[i - 1][j + 1] && other \\end{array} \\right. \\end{eqnarray*} \\begin{eqnarray*} f[i][j] = \\left\\{ \\begin{array}{cccc} f[i - 1][0] + f[i - 1][1] && j = 0 \\\\ f[i - 1][j - 1] * 26 && j = i \\\\ f[i - 1][j - 1] * 26 + f[i - 1][j + 1] && other \\end{array} \\right. \\end{eqnarray*} Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define SZ(x) (int(x.size())) const int N = 1e3 + 10 , mod = 1e9 + 7 ; int n , m , v [ N ], fac [ N ], inv [ N ], bit [ N ], fbit [ N ]; ll f [ N ][ N ]; char s [ N ]; ll qpow ( ll base , ll n ) { ll res = 1 ; while ( n ) { if ( n & 1 ) res = res * base % mod ; base = base * base % mod ; n >>= 1 ; } return res ; } ll C ( int n , int m ) { return 1l l * fac [ n ] * inv [ m ] % mod * inv [ n - m ] % mod ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); fac [ 0 ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) fac [ i ] = 1l l * fac [ i - 1 ] * i % mod ; inv [ N - 1 ] = qpow ( fac [ N - 1 ], mod - 2 ); for ( int i = N - 1 ; i >= 1 ; -- i ) inv [ i - 1 ] = 1l l * inv [ i ] * i % mod ; bit [ 0 ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) bit [ i ] = 1l l * bit [ i - 1 ] * 26 % mod ; fbit [ 0 ] = 1 ; fbit [ 1 ] = qpow ( 26 , mod - 2 ); for ( int i = 2 ; i < N ; ++ i ) fbit [ i ] = 1l l * fbit [ i - 1 ] * fbit [ 1 ] % mod ; f [ 0 ][ 0 ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) { for ( int j = 0 ; j <= i ; ++ j ) { if ( ! j ) { f [ i ][ j ] += f [ i - 1 ][ 0 ] + f [ i - 1 ][ 1 ]; f [ i ][ j ] %= mod ; } else if ( j < i ) { f [ i ][ j ] += f [ i - 1 ][ j - 1 ] * 26 + f [ i - 1 ][ j + 1 ]; f [ i ][ j ] %= mod ; } else if ( j == i ) { f [ i ][ j ] += f [ i - 1 ][ j - 1 ] * 26 % mod ; f [ i ][ j ] %= mod ; } } } cin >> n >> m ; vector < string > vec ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) cin >> vec [ i ] >> v [ i ]; ll res = 0 ; for ( int i = 1 ; i <= m ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { int len = SZ ( vec [ j ]); if ( i >= len ) { res += f [ m ][ i ] * ( i - len + 1 ) % mod * v [ j ] % mod * fbit [ len ] % mod ; res %= mod ; } } } printf ( \"%lld \\n \" , res ); return 0 ; }","title":"I. \u53e4\u8001\u7684\u6253\u5b57\u673a"},{"location":"trainings/random-trainings/18th-SHU-CPC/#j-\u80fd\u5230\u8fbe\u5417","text":"UpSolved By Dup4. \u601d\u8def\uff1a \u8003\u8651\u66b4\u529b\u600e\u4e48\u505a\uff0c\u6bcf\u4e2a\u70b9\u5f80\u56db\u5468\u5408\u5e76\uff0c\u4e00\u4e2a\u8054\u901a\u5757\u7684\u8d21\u732e\u662f \\displaystyle {n \\choose 2} + n \\displaystyle {n \\choose 2} + n \u3002 \u90a3\u4e48\u5bf9\u4e8e n \\cdot m n \\cdot m \u7684\u56fe\uff0c\u6309\u884c\u679a\u4e3e\uff0c\u6bcf\u4e00\u884c\u8fde\u7eed\u7684\u7a7a\u5730\u7f29\u6210\u4e00\u4e2a\u70b9\uff0c\u8fd9\u6837\u5bf9\u4e8e\u5355\u7ec4\u6570\u636e\u7684\u590d\u6742\u5ea6\u662f\u5bf9\u7684\u3002 \u4f46\u662f\u8fd9\u91cc\u662f T T \u7ec4\u6570\u636e\uff0c\u6240\u4ee5\u4e0d\u80fd\u6309\u884c\u679a\u4e3e\uff0c\u53ea\u80fd\u679a\u4e3e\u6709\u969c\u788d\u7269\u7684\u884c\uff0c\u5bf9\u4e8e\u8fde\u7eed\u7684\u6574\u884c\u90fd\u662f\u7a7a\u5730\u7684\u884c\u4e5f\u8981\u7f29\u70b9\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; using pII = pair < int , int > ; #define fi first #define se second #define SZ(x) (int(x.size())) #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 2e6 + 10 , M = 2e5 + 10 ; const int mod = 1e9 + 7 , inv2 = ( mod + 1 ) / 2 ; int n , m , K ; struct UFS { int fa [ N ]; ll sze [ N ]; int tot ; void init () { tot = 0 ; } int newnode ( ll _sze ) { ++ tot ; fa [ tot ] = 0 ; sze [ tot ] = _sze ; return tot ; } int find ( int x ) { return fa [ x ] == 0 ? x : fa [ x ] = find ( fa [ x ]); } bool merge ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( fx != fy ) { if ( sze [ fx ] > sze [ fy ]) swap ( fx , fy ); fa [ fx ] = fy ; sze [ fy ] += sze [ fx ]; return true ; } return false ; } } ufs ; inline ll C ( ll n ) { return ( 1l l * ( n % mod ) * (( n - 1 ) % mod ) % mod * inv2 % mod + n % mod ) % mod ; } struct E { int l , r , id ; bool cross ( const E & other ) const { if (( l >= other . l && l <= other . r ) || ( r >= other . l && r <= other . r ) || ( other . l >= l && other . l <= r ) || ( other . r >= l && other . r <= r )) return 1 ; return 0 ; } }; vector < vector < int >> vec ( M ); vector < vector < E >> seg ( M ); vector < int > has ; void gao () { if ( K == 0 ) { ll res = C ( 1l l * n * m ); printf ( \"%lld \\n \" , res ); return ; } ufs . init (); sort ( has . begin (), has . end ()); has . erase ( unique ( has . begin (), has . end ()), has . end ()); for ( int i = 0 ; i < SZ ( has ); ++ i ) { int p = has [ i ]; int pre = 0 ; sort ( vec [ p ]. begin (), vec [ p ]. end ()); for ( auto & it : vec [ p ]) { if ( it - 1 > pre ) { E tmp = { pre + 1 , it - 1 , ufs . newnode ( it - 1 - pre )}; // dbg(tmp.l, tmp.r, tmp.id, ufs.sze[tmp.id]); seg [ p ]. push_back ( tmp ); } pre = it ; } if ( pre < m ) { E tmp = { pre + 1 , m , ufs . newnode ( m - pre )}; seg [ p ]. push_back ( tmp ); } // for (auto &it : seg[p]) { // dbg(it.l, it.r); // } if ( i == 0 ) { if ( p > 1 ) { int node = ufs . newnode ( 1l l * ( p - 1 ) * m ); for ( auto & it : seg [ p ]) { ufs . merge ( node , it . id ); } } } else { int preP = has [ i - 1 ]; if ( preP + 1 < p ) { int node = ufs . newnode ( 1l l * ( p - preP - 1 ) * m ); for ( auto & it : seg [ p ]) { ufs . merge ( node , it . id ); } for ( auto & it : seg [ preP ]) { ufs . merge ( node , it . id ); } } else { int pos = 0 ; for ( auto & it : seg [ p ]) { while ( pos < SZ ( seg [ preP ])) { E it2 = seg [ preP ][ pos ]; if ( it . cross ( it2 )) { ufs . merge ( it . id , it2 . id ); } if ( it2 . r <= it . r ) ++ pos ; else break ; } } } } if ( i == SZ ( has ) - 1 ) { if ( p < n ) { int node = ufs . newnode ( 1l l * ( n - p ) * m ); // dbg(ufs.sze[node]); for ( auto & it : seg [ p ]) { ufs . merge ( node , it . id ); // dbg(it.l, it.r, it.id, ufs.sze[node]); } } } } for ( auto & it : has ) { vec [ it ]. clear (); seg [ it ]. clear (); } ll res = 0 ; for ( int i = 1 ; i <= ufs . tot ; ++ i ) { if ( ufs . fa [ i ] == 0 ) { // dbg(i, ufs.sze[i]); res += C ( ufs . sze [ i ]); res %= mod ; } } printf ( \"%lld \\n \" , res ); } int main () { int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d%d%d\" , & n , & m , & K ); has . clear (); for ( int i = 1 , x , y ; i <= K ; ++ i ) { scanf ( \"%d%d\" , & x , & y ); has . push_back ( x ); vec [ x ]. push_back ( y ); } gao (); } return 0 ; }","title":"J. \u80fd\u5230\u8fbe\u5417"},{"location":"trainings/random-trainings/18th-SHU-CPC/#k-\u8ff7\u5bab","text":"Solved By Dup4. 3:36(+3) \u601d\u8def\uff1a \u4ece\u8d77\u70b9\u548c\u7ec8\u70b9\u5206\u522b bfs \u5230\u6bcf\u4e2a\u70b9\u7684\u6700\u77ed\u8def\uff0c\u7136\u540e\u679a\u4e3e\u4e00\u4e2a\u70b9\uff0c\u76f8\u5f53\u4e8e\u627e\u77e9\u5f62\u6846\u5185\u7684\u6700\u5c0f\u503c\u3002 \u6ce8\u610f\u5230\u77e9\u5f62\u6846\u5927\u5c0f\u4e00\u81f4\uff0c\u8003\u8651\u4ece\u4e0a\u5f80\u4e0b\u679a\u4e3e\uff0c\u6bcf\u6b21\u591a\u4e00\u884c\uff0c\u7528 m m \u4e2a\u5355\u8c03\u961f\u5217\u7ef4\u62a4\u6bcf\u4e00\u5217 2d 2d \u4e2a\u5143\u7d20\u7684\u6700\u5c0f\u503c\uff0c\u7136\u540e\u4ece\u5de6\u5f80\u53f3\u679a\u4e3e\u7684\u65f6\u5019\uff0c\u518d\u6765\u4e00\u4e2a\u5355\u8c03\u961f\u5217\u3002 \u8d5b\u65f6\u6bd4\u8f83\u8822\uff0c\u65e0\u8111\u4e86\u4e00\u4e2a\u7ebf\u6bb5\u6811\uff0c\u4f46\u5b9e\u9645\u4e0a\u51fa\u9898\u4eba\u53ef\u4ee5\u76f4\u63a5\u5361\u5230 O(nm) O(nm) \u3002 Code #include <bits/stdc++.h> using namespace std ; using pII = pair < int , int > ; #define SZ(x) (int(x.size())) #define fi first #define se second #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 2e3 + 10 , INF = 1e9 ; int n , m , d , sx , sy , ex , ey , a [ N ]; pII b [ N ]; char G [ N ][ N ]; int Move [][ 2 ] = { 1 , 0 , -1 , 0 , 0 , 1 , 0 , -1 }; struct BFS { int dis [ N ][ N ]; pII pre [ N ][ N ]; bool ok ( int x , int y ) { if ( x < 1 || x > n || y < 1 || y > m || G [ x ][ y ] == 'X' ) return 0 ; return 1 ; } void gao ( int sx , int sy ) { for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { dis [ i ][ j ] = INF ; pre [ i ][ j ] = pII ( -1 , -1 ); } } dis [ sx ][ sy ] = 0 ; queue < pII > que ; que . push ( pII ( sx , sy )); while ( ! que . empty ()) { int x = que . front (). fi , y = que . front (). se ; que . pop (); for ( int i = 0 ; i < 4 ; ++ i ) { int nx = x + Move [ i ][ 0 ]; int ny = y + Move [ i ][ 1 ]; if ( ok ( nx , ny ) && dis [ nx ][ ny ] > dis [ x ][ y ] + 1 ) { dis [ nx ][ ny ] = dis [ x ][ y ] + 1 ; pre [ nx ][ ny ] = pII ( x , y ); que . push ( pII ( nx , ny )); } } } } } f , g ; struct DEQUE { int que [ N ], head , tail ; void init () { head = 1 , tail = 0 ; } } q [ N ]; struct SEG { struct node { int Min ; pII pos ; node () { Min = INF ; pos = pII ( -1 , -1 ); } node operator + ( const node & other ) const { node res = node (); if ( Min < other . Min ) { res . Min = Min ; res . pos = pos ; } else { res . Min = other . Min ; res . pos = other . pos ; } return res ; } } t [ N << 2 ], res ; void build ( int id , int l , int r ) { t [ id ] = node (); if ( l == r ) { t [ id ]. Min = a [ l ]; t [ id ]. pos = b [ l ]; return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); t [ id ] = t [ id << 1 ] + t [ id << 1 | 1 ]; } // void update(int id, int l, int r, int pos, int v) { // if (l == r) { // t[id].Min = v; // return; // } // int mid = (l + r) >> 1; // if (pos <= mid) update(id << 1, l, mid, ql, qr, v); // else update(id << 1 | 1, mid + 1, r, ql, qr, v); // t[id] = t[id << 1] + t[id << 1 | 1]; // } void query ( int id , int l , int r , int ql , int qr ) { if ( l >= ql && r <= qr ) { res = res + t [ id ]; return ; } int mid = ( l + r ) >> 1 ; if ( ql <= mid ) query ( id << 1 , l , mid , ql , qr ); if ( qr > mid ) query ( id << 1 | 1 , mid + 1 , r , ql , qr ); } } seg ; int main () { scanf ( \"%d%d%d\" , & n , & m , & d ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%s\" , G [ i ] + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( G [ i ][ j ] == 'S' ) { sx = i , sy = j ; } else if ( G [ i ][ j ] == 'T' ) { ex = i , ey = j ; } } } // dbg(sx, sy, ex, ey); f . gao ( sx , sy ); g . gao ( ex , ey ); // for (int i = 1; i <= n; ++i) { // for (int j = 1; j <= m; ++j) { // dbg(i, j, f.dis[i][j]); // } // } // for (int i = 1; i <= n; ++i) { // for (int j = 1; j <= m; ++j) { // dbg(i, j, g.dis[i][j]); // } // } for ( int i = 1 ; i <= m ; ++ i ) q [ i ]. init (); int up = 1 , down = 0 ; pII A = pII ( ex , ey ), B = pII ( -1 , -1 ); int dis = f . dis [ ex ][ ey ]; for ( int i = 1 ; i <= n ; ++ i ) { up = max ( 1 , i - d ); int _down = min ( n , i + d ); while ( down < _down ) { ++ down ; for ( int j = 1 ; j <= m ; ++ j ) { while ( q [ j ]. head <= q [ j ]. tail && g . dis [ q [ j ]. que [ q [ j ]. tail ]][ j ] >= g . dis [ down ][ j ]) -- q [ j ]. tail ; q [ j ]. que [ ++ q [ j ]. tail ] = down ; } } for ( int j = 1 ; j <= m ; ++ j ) { while ( q [ j ]. head <= q [ j ]. tail && q [ j ]. que [ q [ j ]. head ] < up ) ++ q [ j ]. head ; a [ j ] = g . dis [ q [ j ]. que [ q [ j ]. head ]][ j ]; b [ j ] = pII ( q [ j ]. que [ q [ j ]. head ], j ); } seg . build ( 1 , 1 , m ); for ( int j = 1 ; j <= m ; ++ j ) if ( G [ i ][ j ] != 'X' ) { int l = max ( 1 , j - d ); int r = min ( m , j + d ); seg . res = SEG :: node (); seg . query ( 1 , 1 , m , l , r ); pII _A = pII ( i , j ); pII _B = seg . res . pos ; int _dis = f . dis [ i ][ j ] + seg . res . Min + 1 ; if ( _dis <= dis ) { // dbg(i, j, f.dis[i][j], g.dis[_B.fi][_B.se], _B.fi, _B.se); dis = _dis ; A = _A ; B = _B ; } } } if ( dis >= INF ) puts ( \"-1\" ); else { printf ( \"%d \\n \" , dis ); vector < pII > vecA , vecB ; while ( A != pII ( -1 , -1 )) { vecA . push_back ( A ); A = f . pre [ A . fi ][ A . se ]; } while ( B != pII ( -1 , -1 )) { vecB . push_back ( B ); B = g . pre [ B . fi ][ B . se ]; } reverse ( vecA . begin (), vecA . end ()); for ( int i = 0 ; i < SZ ( vecA ); ++ i ) { printf ( \"%d %d \\n \" , vecA [ i ]. fi - 1 , vecA [ i ]. se - 1 ); } for ( int i = 0 ; i < SZ ( vecB ); ++ i ) { printf ( \"%d %d \\n \" , vecB [ i ]. fi - 1 , vecB [ i ]. se - 1 ); } } return 0 ; }","title":"K. \u8ff7\u5bab"},{"location":"trainings/random-trainings/18th-SHU-CPC/#l-\u52a8\u7269\u68ee\u53cb\u4f1a","text":"Solved By Hsueh-. 3:11(+) \u601d\u8def\uff1a \u8003\u8651\u4e8c\u5206\u65f6\u95f4\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u77e5\u9053\u4e86\u6bcf\u4e2a\u65e5\u5b50\u6709\u51e0\u5929\uff0c\u5efa\u7acb\u7f51\u7edc\u6d41\u53bb\u5224\u65ad\uff0c\u5176\u4e2d\u5de6\u8fb9\u4e3a\u4efb\u52a1\uff0c\u5411\u53f3\u8fb9\u7684\u661f\u671f\u51e0\u6d41\u9700\u8981\u7684\u9700\u6c42 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const ll INF = 0x3f3f3f3f3f3f3f3f ; template < class Type > struct Dinic { static const int M = 1e6 + 10 ; static const int N = 1e5 + 10 ; struct Edge { int to , nxt ; Type flow ; Edge () {} Edge ( int to , int nxt , Type flow ) : to ( to ), nxt ( nxt ), flow ( flow ) {} } edge [ M ]; int S , T ; int head [ N ], tot ; int dep [ N ]; void init () { memset ( head , -1 , sizeof head ); tot = 0 ; } void set ( int S , int T ) { this -> S = S ; this -> T = T ; } void addedge ( int u , int v , ll w , ll rw = 0 ) { // dbg(u, v, w); edge [ tot ] = Edge ( v , head [ u ], w ); head [ u ] = tot ++ ; edge [ tot ] = Edge ( u , head [ v ], rw ); head [ v ] = tot ++ ; } bool BFS () { memset ( dep , -1 , sizeof dep ); queue < int > q ; q . push ( S ); dep [ S ] = 1 ; while ( ! q . empty ()) { int u = q . front (); q . pop (); for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { if ( edge [ i ]. flow && dep [ edge [ i ]. to ] == -1 ) { dep [ edge [ i ]. to ] = dep [ u ] + 1 ; q . push ( edge [ i ]. to ); } } } return dep [ T ] >= 0 ; } Type DFS ( int u , Type f ) { if ( u == T || f == 0 ) return f ; Type w , used = 0 ; for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { if ( edge [ i ]. flow && dep [ edge [ i ]. to ] == dep [ u ] + 1 ) { w = DFS ( edge [ i ]. to , min ( f - used , edge [ i ]. flow )); edge [ i ]. flow -= w ; edge [ i ^ 1 ]. flow += w ; used += w ; if ( used == f ) return f ; } } if ( ! used ) dep [ u ] = -1 ; return used ; } Type solve () { Type ans = 0 ; while ( BFS ()) { ans += DFS ( S , INF ); } return ans ; } }; Dinic < ll > dinic ; const int N = 1e3 + 10 ; int n , e ; ll sum ; ll cnt [ 20 ]; ll c [ N ]; int a [ N ][ 10 ]; bool ok ( int x ) { memset ( cnt , 0 , sizeof cnt ); for ( int i = 1 ; i <= 7 ; ++ i ) { cnt [ i ] = x / 7 ; if ( x % 7 >= i ) cnt [ i ] ++ ; } dinic . init (); int S = 0 , T = n + 10 ; dinic . set ( S , T ); for ( int i = 1 ; i <= n ; ++ i ) { dinic . addedge ( S , i , c [ i ]); for ( int j = 1 ; j <= a [ i ][ 0 ]; ++ j ) { dinic . addedge ( i , n + a [ i ][ j ], c [ i ]); } } for ( int i = 1 ; i <= 7 ; ++ i ) { dinic . addedge ( n + i , T , cnt [ i ] * e ); } ll res = dinic . solve (); // dbg(res, sum); return res >= sum ; } int main () { scanf ( \"%d %d\" , & n , & e ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld %d\" , c + i , & a [ i ][ 0 ]); for ( int j = 1 ; j <= a [ i ][ 0 ]; ++ j ) { scanf ( \"%d\" , & a [ i ][ j ]); } sum += c [ i ]; } ll l = 0 , r = 1e9 , res = -1 ; // ok(5); while ( r - l >= 0 ) { ll mid = ( l + r ) >> 1 ; if ( ok ( mid )) { r = mid - 1 ; res = mid ; } else { l = mid + 1 ; } } printf ( \"%lld \\n \" , res ); return 0 ; }","title":"L. \u52a8\u7269\u68ee\u53cb\u4f1a"},{"location":"trainings/random-trainings/2016-2017-ACM-ICPC-NEERC-Southern-Subregional-Contest/","text":"2016-2017 ACM-ICPC, NEERC, Southern Subregional Contest Contents Contest Info Solutions A. Toda 2 B. Minimum and Maximum C. Bulmart D. Running Over The Bridges E. Award Ceremony F. Ber Patio G. Car Repair Shop H. Delete Them I. Olympiad in Programming and Sports J. Bottles K. Roads Orientation Problem L. Expression Queries Contest Info Practice Link Solved A B C D E F G H I J K L 9/12 O O O O O - O O O O - - O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5 Solutions A. Toda 2 Solved By Hsueh-. 0:39(+) \u9898\u610f\uff1a \u6bcf\u6b21\u9009 2-5 \u4e2a\u4eba\u51cf\u4e00\u5206\uff0c\u95ee\u6240\u6709\u4eba\u540c\u5206\u65f6\u5019\u7684\u6700\u5927\u5206\u6570\u3002 \u601d\u8def\uff1a \u6a21\u62df\u9898\uff0c\u663e\u7136\u6bcf\u6b21\u53ea\u7528 2-3 \u4eba\uff0c\u90a3\u4e48\uff1a \u5982\u679c\u53ea\u6709\u4e00\u4e2a\u6700\u5927\u7684\u5c31\u548c\u6b21\u5927\u7684\u4e00\u8d77\u51cf\u4e00\u5206\u3002 \u5982\u679c\u662f\u5076\u6570\u5219\u9009\u62e9\u4e24\u4e2a\u51cf\u4e00\u5206\u3002 \u5982\u679c\u662f\u5947\u6570\u5219\u9009\u62e9\u4e09\u4e2a\u51cf\u4e00\u5206\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e2 + 10 , M = 1e4 + 10 ; struct E { int id , v ; E () {} E ( int id , int v ) : id ( id ), v ( v ) {} bool operator < ( const E & other ) const { return v < other . v ; } } a [ N ]; int n ; int f [ M ][ N ]; priority_queue < E > q ; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , & a [ i ]. v ); a [ i ]. id = i ; q . push ( a [ i ]); } for ( int cas = 1 ;; ++ cas ) { vector < E > vec ; vec . push_back ( q . top ()); q . pop (); while ( ! q . empty ()) { if ( q . top (). v == vec [ 0 ]. v ) { vec . push_back ( q . top ()); q . pop (); } else { break ; } } if ( vec . size () == n ) { printf ( \"%d \\n \" , vec [ 0 ]. v ); printf ( \"%d \\n \" , cas - 1 ); for ( int i = 1 ; i < cas ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { printf ( \"%d\" , f [ i ][ j ]); } puts ( \"\" ); } break ; } if ( vec . size () == 1 ) { E tmp = q . top (); q . pop (); tmp . v = max ( tmp . v - 1 , 0 ); f [ cas ][ tmp . id ] = 1 ; q . push ( tmp ); vec [ 0 ]. v = max ( vec [ 0 ]. v - 1 , 0 ); f [ cas ][ vec [ 0 ]. id ] = 1 ; q . push ( vec [ 0 ]); } else if ( vec . size () % 2 == 0 ) { vec [ 0 ]. v = max ( vec [ 0 ]. v - 1 , 0 ); vec [ 1 ]. v = max ( vec [ 1 ]. v - 1 , 0 ); f [ cas ][ vec [ 0 ]. id ] = 1 ; f [ cas ][ vec [ 1 ]. id ] = 1 ; for ( auto it : vec ) { q . push ( it ); } } else { vec [ 0 ]. v = max ( vec [ 0 ]. v - 1 , 0 ); vec [ 1 ]. v = max ( vec [ 1 ]. v - 1 , 0 ); vec [ 2 ]. v = max ( vec [ 2 ]. v - 1 , 0 ); f [ cas ][ vec [ 0 ]. id ] = 1 ; f [ cas ][ vec [ 1 ]. id ] = 1 ; f [ cas ][ vec [ 2 ]. id ] = 1 ; for ( auto it : vec ) { q . push ( it ); } } } return 0 ; } B. Minimum and Maximum Solved By Hsueh-. 1:05(+) \u9898\u610f\uff1a \u7ed9\u5b9a\u6570\u7ec4\u957f\u5ea6\uff0c\u6bcf\u6b21\u53ef\u4ee5\u8be2\u95ee a_i, a_j a_i, a_j \u7684\u5927\u5c0f\u5173\u7cfb\u3002 \u5728\u53ea\u80fd\u8be2\u95ee \\frac{3n}{2}-2 \\frac{3n}{2}-2 \u6b21\u7684\u60c5\u51b5\u4e0b\u5f97\u51fa\u7684\u6700\u5927\u503c\u4e0b\u6807\u548c\u6700\u5c0f\u503c\u4e0b\u6807\u3002 \u601d\u8def\uff1a \u5148\u8be2\u95ee\u76f8\u90bb\u7684\u4e24\u4e2a\uff0c\u5927\u7684\u653e\u5728 Big \u91cc\uff0c\u5c0f\u7684\u653e\u5728 Small \u91cc\u9762\uff0c\u90a3\u4e48\u8fd9\u65f6\u5019\u8be2\u95ee\u4e86 \\frac{n}{2} \\frac{n}{2} \u6b21\uff0c\u6bcf\u4e2a\u6570\u7ec4\u53ea\u6709 \\frac{n}{2} \\frac{n}{2} \u4e2a\u5143\u7d20\u3002 \u63a5\u4e0b\u6765\u6700\u5927\u503c\u53bb Big \u91cc\u9762\u627e\uff0c\u6700\u5c0f\u503c\u53bb Small \u91cc\u627e\uff0c\u5206\u522b\u9700\u8981 \\frac{n}{2}-1 \\frac{n}{2}-1 \u6b21\uff0c\u5c31\u53ef\u4ee5\u4e86\u3002 Code #include <bits/stdc++.h> using namespace std ; int n ; int ask ( int x , int y ) { if ( x == y ) return 0 ; printf ( \"? %d %d \\n \" , x + 1 , y + 1 ); fflush ( stdout ); char op [ 10 ]; scanf ( \"%s\" , op ); if ( op [ 0 ] == '<' ) return -1 ; else if ( op [ 1 ] == '=' ) return 0 ; else return 1 ; } int main () { int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d\" , & n ); vector < int > big , small ; for ( int i = 0 ; i < n / 2 ; ++ i ) { if ( ask ( 2 * i , 2 * i + 1 ) < 0 ) { big . push_back ( 2 * i + 1 ); small . push_back ( 2 * i ); } else { small . push_back ( 2 * i + 1 ); big . push_back ( 2 * i ); } } if ( n & 1 ) { big . push_back ( n - 1 ); small . push_back ( n - 1 ); } int Min = small [ 0 ], Max = big [ 0 ]; for ( int i = 1 , len = small . size (); i < len ; ++ i ) { if ( ask ( Min , small [ i ]) > 0 ) { Min = small [ i ]; } } for ( int i = 1 , len = big . size (); i < len ; ++ i ) { if ( ask ( Max , big [ i ]) < 0 ) { Max = big [ i ]; } } printf ( \"! %d %d \\n \" , Min + 1 , Max + 1 ); fflush ( stdout ); } return 0 ; } C. Bulmart Solved By Hsueh- & Dup4. 3:09(+3) \u9898\u610f\uff1a \u6709 n n \u4e2a\u57ce\u5e02\uff0c m m \u6761\u65e0\u5411\u8fb9\uff0c\u6709 w w \u4e2a\u5546\u5e97\uff0c\u7b2c i i \u4e2a\u5546\u5e97\u5ea7\u843d\u5728\u7b2c i i \u4e2a\u57ce\u5e02\uff0c\u62e5\u6709 k_i k_i \u4ef6\u5546\u54c1\uff0c\u5546\u54c1\u7684\u5355\u4ef7\u4e3a p_i p_i . \u73b0\u5728\u6709 q q \u6b21\u8be2\u95ee\uff0c\u6bcf\u6b21\u8be2\u95ee\u7ed9\u51fa g_j, r_j, a_j g_j, r_j, a_j \uff0c\u8868\u793a\u67d0\u4eba\u5728 g_j g_j \u90a3\u4e2a\u57ce\u5e02\uff0c\u9700\u8981\u4e70\u5165\u81f3\u5c11 r_j r_j \u4ef6\u7269\u54c1\uff0c\u603b\u82b1\u8d39\u4e0d\u8d85\u8fc7 a_j a_j \uff0c\u95ee\u6700\u5c11\u7684\u65f6\u95f4\u3002 \u8fd9\u91cc\u7684\u8d2d\u4e70\u53ef\u4ee5\u8ba9\u5176\u4ed6\u57ce\u5e02\u90ae\u5bc4\u8fc7\u6765\uff0c\u65f6\u95f4\u662f\u82b1\u8d39\u6700\u957f\u7684\u90a3\u4e2a\u5305\u88f9\uff0c\u8fb9\u6743\u4e3a 1 1 \u3002 \u601d\u8def\uff1a \u5148\u9884\u5904\u7406\u51fa\u6bcf\u4e2a\u70b9\u5230\u5176\u4ed6\u4efb\u610f\u4e00\u70b9\u7684\u6700\u5c0f\u8ddd\u79bb\u3002 \u7136\u540e\u5c06\u6bcf\u4e2a\u5546\u5e97\u6309\u7167\u5355\u4ef7\u6392\u5e8f\uff0c\u5bf9\u4e8e\u6bcf\u6b21\u8be2\u95ee\uff0c\u4e8c\u5206 t t \uff0c\u7136\u540e\u8d2a\u5fc3\u53bb\u7b26\u5408\u8981\u6c42\u7684\u5546\u5e97\u8d2d\u4e70\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(nm + nw \\log n) O(nm + nw \\log n) \u3002 \u5176\u5b9e\u5806\u4f18\u5316\u53ef\u64a4\u9500\u8d2a\u5fc3\u4e5f\u662f\u53ef\u4ee5\u7684\uff0c\u8d5b\u540e\u8fc7\u4e86( Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define SZ(x) (int((x).size())) const int N = 2e5 + 10 ; int n ; ll r , l [ N ], t [ N ]; int main () { scanf ( \"%d%lld\" , & n , & r ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld\" , l + i ); } for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld\" , t + i ); if ( l [ i ] > t [ i ]) { puts ( \"-1\" ); return 0 ; } } vector < ll > vec ; int limit = 1e5 ; ll res = 0 , pre = 0 , T = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( pre >= l [ i ]) { pre -= l [ i ]; T += l [ i ]; continue ; } l [ i ] -= pre ; t [ i ] -= pre ; T += pre ; pre = 0 ; ll need = l [ i ] * 2 - t [ i ]; if ( need <= 0 ) { T += l [ i ] * 2 ; } else { ll cnt = need / r ; ll mod = need % r ; res += cnt ; res += ( mod > 0 ); for ( ll j = 1 , k = T ; j <= cnt && SZ ( vec ) < limit ; ++ j , k += r ) { vec . push_back ( k ); } T += r * cnt ; l [ i ] -= r * cnt ; l [ i ] -= mod ; T += l [ i ] * 2 ; if ( mod ) { vec . push_back ( T ); pre = r - mod ; } T += mod ; } } printf ( \"%lld \\n \" , res ); if ( res <= limit ) { for ( int i = 0 ; i < SZ ( vec ); ++ i ) { printf ( \"%lld%c\" , vec [ i ], \" \\n \" [ i == SZ ( vec ) - 1 ]); } } else { puts ( \"\" ); } return 0 ; } D. Running Over The Bridges Solved By Dup4 & Hsueh-. 4:09(+3) \u9898\u610f\uff1a \u6709 n n \u5ea7\u6865, \u7b2c i i \u5ea7\u6865\u7684\u957f\u5ea6\u4e3a l_i l_i \uff0c\u5728\u7b2c i i \u5ea7\u6865\u4e0a\u6700\u591a\u7684\u505c\u7559\u65f6\u95f4\u4e3a t_i t_i \uff0c\u73b0\u5728\u6709\u4e00\u4e2a\u4eba\u8981\u4ece\u7b2c 1 1 \u5ea7\u6865\u6309\u987a\u5e8f\u7ecf\u8fc7\u8fd9 n n \u5ea7\u6865\uff0c\u5b83\u7684\u901f\u5ea6\u662f 2s 2s \u8d70\u4e00\u4e2a\u5355\u4f4d\u957f\u5ea6\uff0c\u4f46\u662f\u6709\u4e00\u79cd\u836f\u6c34\uff0c\u6bcf\u6b21\u559d\u4e0b\u540e\u6301\u7eed r r \u4e2a\u65f6\u95f4\u5355\u4f4d\uff0c\u4f7f\u5f97\u5b83\u80fd\u591f 1s 1s \u8d70\u4e00\u4e2a\u5355\u4f4d\u957f\u5ea6\uff0c\u95ee\u8fd9\u4e2a\u4eba\u6700\u5c11\u8981\u559d\u591a\u5c11\u6b21\u836f\u6c34\uff0c\u4f7f\u5f97\u80fd\u8d70\u5b8c\u8fd9 n n \u5ea7\u6865\uff0c\u5728\u6ee1\u8db3\u4e0a\u8ff0\u9650\u5236\u7684\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u559d\u7684\u6b21\u6570\u5c0f\u4e8e\u7b49\u4e8e 10^5 10^5 , \u90a3\u4e48\u8981\u8f93\u51fa\u559d\u836f\u6c34\u7684\u65f6\u523b\u3002 \u601d\u8def\uff1a \u8d2a\u5fc3\uff0c\u5bf9\u4e8e\u6bcf\u5ea7\u6865\uff0c\u8003\u8651\u5bf9\u4e8e\u8fd9\u5ea7\u6865\u6700\u5c11\u8981\u559d\u51e0\u6b21\uff0c\u7136\u540e\u6700\u540e\u4e00\u6b21\u559d\u836f\u6c34\uff0c\u5c3d\u91cf\u9760\u540e\uff0c\u628a\u836f\u6c34\u7684\u6536\u76ca\u7559\u7ed9\u4e0b\u4e00\u5ea7\u6865\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define SZ(x) (int((x).size())) const int N = 2e5 + 10 ; int n ; ll r , l [ N ], t [ N ]; int main () { scanf ( \"%d%lld\" , & n , & r ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld\" , l + i ); } for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld\" , t + i ); if ( l [ i ] > t [ i ]) { puts ( \"-1\" ); return 0 ; } } vector < ll > vec ; int limit = 1e5 ; ll res = 0 , pre = 0 , T = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( pre >= l [ i ]) { pre -= l [ i ]; T += l [ i ]; continue ; } l [ i ] -= pre ; t [ i ] -= pre ; T += pre ; pre = 0 ; ll need = l [ i ] * 2 - t [ i ]; if ( need <= 0 ) { T += l [ i ] * 2 ; } else { ll cnt = need / r ; ll mod = need % r ; res += cnt ; res += ( mod > 0 ); for ( ll j = 1 , k = T ; j <= cnt && SZ ( vec ) < limit ; ++ j , k += r ) { vec . push_back ( k ); } T += r * cnt ; l [ i ] -= r * cnt ; l [ i ] -= mod ; T += l [ i ] * 2 ; if ( mod ) { vec . push_back ( T ); pre = r - mod ; } T += mod ; } } printf ( \"%lld \\n \" , res ); if ( res <= limit ) { for ( int i = 0 ; i < SZ ( vec ); ++ i ) { printf ( \"%lld%c\" , vec [ i ], \" \\n \" [ i == SZ ( vec ) - 1 ]); } } else { puts ( \"\" ); } return 0 ; } E. Award Ceremony Solved By Hsueh- & ltslts. 3:50(+) \u9898\u610f\uff1a \u6bcf\u4e2a\u4eba\u6709\u4e00\u4e2a\u8d77\u59cb\u7684\u5206\u6570 a_i a_i \u4ee5\u53ca\u4e00\u4e2a\u7b49\u5f85\u63ed\u6653\u7684\u5206\u6570 d_i d_i \u3002 \u5047\u8bbe\u63ed\u5f00\u67d0\u4eba\u540e\uff0c\u4ed6\u7684\u6392\u540d\u53d8\u5316 t t \u3002 \u5b89\u6392\u4e00\u4e2a\u63ed\u5f00\u5206\u6570\u7684\u987a\u5e8f\u4f7f\u5f97 \\sum t \\sum t \u6700\u5927\u3002 \u601d\u8def\uff1a \u663e\u7136\u5bf9\u6bcf\u4e24\u4e2a\u4eba\u7684\u6392\u540d\u5148\u540e\u987a\u5e8f\u53d8\u5316\u7814\u7a76\uff0c\u7136\u540e\u6c42 sum \u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e2 + 10 ; struct E { int id , a , d ; bool operator < ( const E & other ) const { if ( a != other . a ) { return a > other . a ; } else { return id < other . id ; } } } a [ N ]; int n ; int f ( int x , int y ) { E startX = a [ x ], startY = a [ y ]; E endX = a [ x ], endY = a [ y ]; endX . a += endX . d ; endY . a += endY . d ; if ( startX < startY && endY < endX ) return 1 ; if ( startY < startX && endX < endY ) return 1 ; if ( startX < startY && endY < startX && endX < endY ) return 2 ; if ( startX < startY && startY < endX && endX < endY ) return 2 ; if ( startY < startX && startX < endY && endY < endX ) return 2 ; if ( startY < startX && endX < startY && endY < endX ) return 2 ; return 0 ; } int main () { #ifdef LOCAL_JUDGE freopen ( \"input\" , \"r\" , stdin ); #endif scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d %d\" , & a [ i ]. a , & a [ i ]. d ); a [ i ]. id = i ; } int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i + 1 ; j <= n ; ++ j ) { res += f ( i , j ); } } printf ( \"%d \\n \" , res ); return 0 ; } F. Ber Patio UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a G. Car Repair Shop Solved By Dup4. 0:54(+) \u9898\u610f\uff1a \u6709\u4e00\u4e2a\u4fee\u8f66\u5e97\uff0c\u6bcf\u4e00\u65f6\u523b\u53ea\u80fd\u4fee\u4e00\u8f86\u8f66\u3002 \u73b0\u5728\u6709 n n \u8f86\u8f66\uff0c\u6bcf\u8f86\u8f66\u6709 s_i, d_i s_i, d_i \uff0c\u8868\u793a\u987e\u5ba2\u5e0c\u671b\u4ece s_i s_i \u65f6\u523b\u5f00\u59cb\u4fee\uff0c d_i d_i \u8868\u793a\u8fd9\u8f86\u8f66\u9700\u8981\u4fee d_i d_i \u65f6\u95f4\u3002 \u73b0\u5728\u5bf9\u4e8e\u6bcf\u8f86\u8f66\uff1a \u5982\u679c [s_i, s_i + d_i - 1] [s_i, s_i + d_i - 1] \u8fd9\u4e2a\u65f6\u95f4\u6bb5\u6ca1\u88ab\u5360\u7528\uff0c\u90a3\u4e48\u8fd9\u8f86\u8f66\u5c31\u88ab\u5b89\u6392\u5728\u8fd9\u4e2a\u65f6\u95f4\u6bb5\u4fee\u3002 \u5426\u5219\uff0c\u627e\u4e00\u4e2a\u6700\u5c0f\u7684\u6b63\u6574\u6570 x x \uff0c\u6ee1\u8db3 [x, x + d_i - 1] [x, x + d_i - 1] \u8fd9\u4e2a\u65f6\u95f4\u6bb5\u6ca1\u6709\u6c7d\u8f66\u4fee\uff0c\u8fd9\u4e2a\u65f6\u5019 x \\leq s_i x \\leq s_i \u662f\u88ab\u5141\u8bb8\u7684\u3002 \u601d\u8def\uff1a \u7528\u4e2a\u5bb9\u5668\u7ef4\u62a4\u4e00\u4e2a\u4e8c\u5143\u7ec4\uff0c\u7136\u540e\u95ee\u9898\u5c31\u76f8\u5f53\u4e8e\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u76f8\u4ea4\u3002 \u5bf9\u4e8e\u7b2c\u4e8c\u79cd\u64cd\u4f5c\uff0c\u5bb9\u6613\u53d1\u73b0\u8d2a\u5fc3\u7684\u9009 x x \uff0c\u53ef\u53d6\u7684\u503c\u5e76\u4e0d\u591a\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; using pLL = pair < ll , ll > ; #define fi first #define se second const int N = 210 ; int n ; ll s [ N ], d [ N ]; vector < pLL > vec ; bool cross ( pLL x , pLL y ) { if (( x . fi <= y . fi && x . se >= y . fi ) || ( x . fi <= y . se && x . se >= y . se ) || ( y . fi <= x . fi && y . se >= x . fi ) || ( y . fi <= x . se && y . fi >= x . se )) return true ; return false ; } bool ok ( ll l , ll r ) { for ( auto & it : vec ) { if ( cross ( pLL ( l , r ), it )) { return false ; } } return true ; } pLL get ( ll d ) { if ( ok ( 1 , 1 + d - 1 )) return pLL ( 1 , 1 + d - 1 ); for ( auto & it : vec ) { if ( ok ( it . se + 1 , it . se + d )) { return pLL ( it . se + 1 , it . se + d ); } } } int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld%lld\" , s + i , d + i ); } for ( int i = 1 ; i <= n ; ++ i ) { pLL tmp = pLL ( s [ i ], s [ i ] + d [ i ] - 1 ); if ( ! ok ( s [ i ], s [ i ] + d [ i ] - 1 )) { tmp = get ( d [ i ]); } vec . push_back ( tmp ); sort ( vec . begin (), vec . end ()); printf ( \"%lld %lld \\n \" , tmp . fi , tmp . se ); } return 0 ; } H. Delete Them Solved By Dup4. 0:41(+) \u9898\u610f\uff1a \u6709 n n \u4e2a\u5b57\u7b26\u4e32\uff0c\u73b0\u5728\u9009\u51fa m m \u4e2a\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u8981\u6784\u9020\u4e00\u4e2a\u6a21\u5f0f\u4e32\uff0c\u4f7f\u5f97\u6a21\u5f0f\u4e32\u80fd\u5339\u914d\u4e0a\u8fd9 m m \u4e2a\u5b57\u7b26\u4e32\uff0c\u4f46\u662f\u4e0d\u80fd\u5339\u914d\u4e0a\u5269\u4e0b\u7684 n - m n - m \u4e2a\u5b57\u7b26\u4e32\uff0c\u6a21\u5f0f\u4e32\u4e2d\u53ef\u4ee5\u6709 ? \uff0c\u4f46\u662f\u6ca1\u6709 * \u3002 \u601d\u8def\uff1a \u5bf9\u4e8e m m \u4e2a\u5b57\u7b26\u4e32\uff0c\u6309\u4f4d\u8003\u8651\uff0c\u5982\u679c\u5f53\u524d\u4f4d\u76f8\u540c\uff0c\u5c31\u653e\u7279\u5b9a\u5b57\u7b26\uff0c\u5426\u5219\u653e ? \u3002 \u7136\u540e\u62ff\u8fd9\u4e2a\u6a21\u5f0f\u4e32\u53bb\u5339\u914d\u5269\u4e0b\u7684 n - m n - m \u4e2a\uff0c\u5982\u679c\u80fd\u5339\u914d\u4e0a\u5c31\u65e0\u89e3\u3002 Code #include <bits/stdc++.h> using namespace std ; #define SZ(x) (int(x.size())) const int N = 1e2 + 10 ; int n , m , vis [ N ]; vector < string > s ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n >> m ; s . clear (); s . resize ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { cin >> s [ i ]; } vector < int > vec ( m ); for ( auto & it : vec ) cin >> it , vis [ it ] = 1 ; string t = \"\" ; int len = SZ ( s [ vec [ 0 ]]); for ( int i = 1 ; i < m ; ++ i ) { if ( SZ ( s [ vec [ i ]]) != len ) { cout << \"No \\n \" ; return 0 ; } } for ( int i = 0 ; i < len ; ++ i ) { char ch = s [ vec [ 0 ]][ i ]; int ok = 1 ; for ( int j = 1 ; j < m ; ++ j ) { if ( s [ vec [ j ]][ i ] != ch ) { ok = 0 ; break ; } } if ( ok ) t += ch ; else t += \"?\" ; } for ( int i = 1 ; i <= n ; ++ i ) if ( vis [ i ] == 0 && SZ ( s [ i ]) == len ) { int ok = 1 ; for ( int j = 0 ; j < len ; ++ j ) { if ( s [ i ][ j ] != t [ j ] && t [ j ] != '?' ) { ok = 0 ; break ; } } if ( ok ) { cout << \"No \\n \" ; return 0 ; } } cout << \"Yes \\n \" ; cout << t << \" \\n \" ; return 0 ; } I. Olympiad in Programming and Sports Solved By Hsueh-. 2:49(+7) \u9898\u610f\uff1a \u6709 n n \u4e2a\u5b66\u751f\uff0c\u4e24\u4e2a\u793e\u56e2 A, B A, B \uff0c\u7b2c i i \u4e2a\u5b66\u751f\u52a0\u5165 A A \u793e\u56e2\uff0c\u80fd\u7ed9 A A \u793e\u56e2\u5e26\u6765 a_i a_i \u70b9\u5c5e\u6027\u503c\uff0c\u52a0\u5165 B B \u793e\u56e2\u80fd\u5e26\u6765 b_i b_i \u70b9\u5c5e\u6027\uff0c\u73b0\u5728\u8981\u6311\u9009 p p \u4e2a\u5b66\u751f\u52a0\u5165 A A \u793e\u56e2\uff0c s s \u4e2a\u5b66\u751f\u52a0\u5165 B B \u793e\u56e2\uff0c\u4f7f\u5f97\u5e26\u6765\u7684\u5c5e\u6027\u548c\u6700\u5927\u3002 \u95ee\u6700\u5927\u5c5e\u6027\u548c\u3002 \u601d\u8def\uff1a \u8d39\u7528\u6d41\u3002 \u6e90\u70b9\u5411\u6bcf\u4e2a\u4eba\u6d41\u6d41\u91cf 1 \uff0c\u8d39\u7528 0 \u7684\u8fb9\u3002 \u6bcf\u4e2a\u4eba\u5411 A , B \u7ec4\u6d41\u6d41\u91cf 1 \uff0c\u8d39\u7528\u4e3a -a_i/-b_i -a_i/-b_i \u7684\u8fb9\u3002 A , B \u7ec4\u5206\u522b\u5411\u6c47\u70b9\u6d41 p , s \u7684\u8fb9\u3002 Code #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } struct Min_Cost_Max_Flow { static const int N = 1e4 + 10 ; static const int M = 1e6 + 10 ; const int INF = 0x3f3f3f3f ; struct E { int to , nxt , cap , flow , cost ; } edge [ M << 1 ]; int head [ N ], tot ; int pre [ N ], dis [ N ]; int vis [ N ]; int n ; void init ( int _n ) { n = _n ; tot = 0 ; memset ( head , -1 , sizeof head ); } void addedge ( int u , int v , int cap , int cost ) { edge [ tot ] = { v , head [ u ], cap , 0 , cost }; head [ u ] = tot ++ ; edge [ tot ] = { u , head [ v ], 0 , 0 , - cost }; head [ v ] = tot ++ ; } bool SPFA ( int s , int t ) { queue < int > q ; for ( int i = 1 ; i <= n ; ++ i ) { dis [ i ] = INF ; vis [ i ] = false ; pre [ i ] = -1 ; } dis [ s ] = 0 ; vis [ s ] = true ; q . push ( s ); while ( ! q . empty ()) { int u = q . front (); q . pop (); vis [ u ] = false ; for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { int v = edge [ i ]. to ; if ( edge [ i ]. cap > edge [ i ]. flow && dis [ v ] > dis [ u ] + edge [ i ]. cost ) { dis [ v ] = dis [ u ] + edge [ i ]. cost ; pre [ v ] = i ; if ( ! vis [ v ]) { vis [ v ] = true ; q . push ( v ); } } } } if ( pre [ t ] == -1 ) return false ; else return true ; } int gao ( int s , int t , int & cost ) { int flow = 0 ; cost = 0 ; while ( SPFA ( s , t )) { int Min = INF ; for ( int i = pre [ t ]; i != -1 ; i = pre [ edge [ i ^ 1 ]. to ]) { if ( Min > edge [ i ]. cap - edge [ i ]. flow ) { Min = edge [ i ]. cap - edge [ i ]. flow ; } } for ( int i = pre [ t ]; i != -1 ; i = pre [ edge [ i ^ 1 ]. to ]) { edge [ i ]. flow += Min ; edge [ i ^ 1 ]. flow -= Min ; cost += edge [ i ]. cost * Min ; } flow += Min ; } return flow ; } } MSMF ; const int N = 3e3 + 10 ; int n , s , p ; int a [ N ], b [ N ]; int main () { #ifdef LOCAL_JUDGE freopen ( \"input\" , \"r\" , stdin ); #endif scanf ( \"%d %d %d\" , & n , & p , & s ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); } for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , b + i ); } int A = n + 1 , B = n + 2 , S = n + 3 , T = n + 4 ; MSMF . init ( T + 10 ); for ( int i = 1 ; i <= n ; ++ i ) { MSMF . addedge ( S , i , 1 , 0 ); MSMF . addedge ( i , A , 1 , - a [ i ]); MSMF . addedge ( i , B , 1 , - b [ i ]); } MSMF . addedge ( A , T , p , 0 ); MSMF . addedge ( B , T , s , 0 ); int cost = 0 ; int flow = MSMF . gao ( S , T , cost ); assert ( flow == p + s ); vector < int > vec_A , vec_B ; for ( int u = 1 ; u <= n ; ++ u ) { for ( int i = MSMF . head [ u ]; ~ i ; i = MSMF . edge [ i ]. nxt ) { if ( MSMF . edge [ i ]. cap == MSMF . edge [ i ]. flow && MSMF . edge [ i ]. to == A ) { vec_A . push_back ( u ); break ; } if ( MSMF . edge [ i ]. cap == MSMF . edge [ i ]. flow && MSMF . edge [ i ]. to == B ) { vec_B . push_back ( u ); break ; } } } // assert(vec_A.size() == p && vec_B.size() == s); printf ( \"%d \\n \" , - cost ); for ( int i = 0 , len = vec_A . size (); i < len ; ++ i ) { printf ( \"%d%c\" , vec_A [ i ], \" \\n \" [ i == len - 1 ]); } for ( int i = 0 , len = vec_B . size (); i < len ; ++ i ) { printf ( \"%d%c\" , vec_B [ i ], \" \\n \" [ i == len - 1 ]); } return 0 ; } J. Bottles Solved By Dup4. 1:25(+1) \u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u74f6\u5b50\uff0c\u6bcf\u4e2a\u74f6\u5b50\u91cc\u9762\u6709 a_i a_i \u5347\u6c34\uff0c\u6bcf\u4e2a\u74f6\u5b50\u7684\u5bb9\u91cf\u662f b_i b_i \uff0c\u4fdd\u8bc1 a_i \\leq b_i a_i \\leq b_i , \u73b0\u5728\u53ef\u4ee5\u5c06\u4e00\u4e2a\u74f6\u5b50\u7684\u6c34\u5012\u5165\u53e6\u4e00\u4e2a\u74f6\u5b50\u7684\u6c34\uff0c\u5012\u5165 1 1 \u5347\u6c34\u9700\u8981\u4e00\u4e2a\u5355\u4f4d\u65f6\u95f4\u3002 \u73b0\u5728\u8981\u5c06\u6240\u6709\u6c34\u5b58\u653e\u5728 k k \u4e2a\u74f6\u5b50\u4e2d\uff0c\u4f7f\u5f97 k k \u6700\u5c11\uff0c\u5176\u6b21\u4fdd\u8bc1\u6240\u7528\u65f6\u95f4 T T \u6700\u5c11\u3002 \u601d\u8def\uff1a \u663e\u7136\uff0c\u9898\u76ee\u8981\u6c42\u627e k k \u4e2a\u74f6\u5b50\uff0c\u4f7f\u5f97\u8fd9 k k \u4e2a\u74f6\u5b50\u7684\u5bb9\u91cf\u548c\u5927\u4e8e\u7b49\u4e8e\u6240\u6709\u6c34\u7684\u4f53\u79ef\uff0c\u5e76\u4e14\u6ee1\u8db3\u5269\u4e0b n - k n - k \u4e2a\u74f6\u5b50\u91cc\u88c5\u7684\u6c34\u6700\u5c11\uff0c\u5373\u8f6c\u79fb\u7684\u6c34\u6700\u5c11\uff0c\u90a3\u4e48\u5c31\u662f\u9009\u4e2d\u7684 k k \u4e2a\u74f6\u5b50\u91cc\u88c5\u7684\u6c34\u8d8a\u591a\u3002 f[i][j] f[i][j] \u8868\u793a\u7528\u4e86 i i \u4e2a\u74f6\u5b50\uff0c\u4f53\u79ef\u4e3a j j \u65f6\u6240\u62e5\u6709\u7684\u6c34\u4f53\u79ef\u7684\u6700\u5927\u503c\uff0c\u7136\u540e\u80cc\u5305\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using pII = pair < int , int > ; #define fi first #define se second #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 110 ; int n , f [ N ][ N * N ]; pII a [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , & a [ i ]. fi ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , & a [ i ]. se ); sort ( a + 1 , a + 1 + n , [ & ]( pII x , pII y ) { return x . se > y . se ; }); int all = 0 , vol = 0 , K = -1 ; for ( int i = 1 ; i <= n ; ++ i ) { all += a [ i ]. fi ; } for ( int i = 1 ; i <= n ; ++ i ) { vol += a [ i ]. se ; if ( K == -1 && vol >= all ) { K = i ; } } memset ( f , -0x3f , sizeof f ); f [ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = K ; j >= 1 ; -- j ) { for ( int k = vol - a [ i ]. se ; k >= 0 ; -- k ) { // dbg(i, j, k); f [ j ][ k + a [ i ]. se ] = max ( f [ j ][ k + a [ i ]. se ], f [ j - 1 ][ k ] + a [ i ]. fi ); } } } int Max = 0 ; for ( int i = all ; i <= vol ; ++ i ) { Max = max ( Max , f [ K ][ i ]); } printf ( \"%d %d \\n \" , K , all - Max ); return 0 ; } K. Roads Orientation Problem UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a L. Expression Queries UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"2016-2017 ACM-ICPC, NEERC, Southern Subregional Contest"},{"location":"trainings/random-trainings/2016-2017-ACM-ICPC-NEERC-Southern-Subregional-Contest/#contest-info","text":"Practice Link Solved A B C D E F G H I J K L 9/12 O O O O O - O O O O - - O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5","title":"Contest Info"},{"location":"trainings/random-trainings/2016-2017-ACM-ICPC-NEERC-Southern-Subregional-Contest/#solutions","text":"","title":"Solutions"},{"location":"trainings/random-trainings/2016-2017-ACM-ICPC-NEERC-Southern-Subregional-Contest/#a-toda-2","text":"Solved By Hsueh-. 0:39(+) \u9898\u610f\uff1a \u6bcf\u6b21\u9009 2-5 \u4e2a\u4eba\u51cf\u4e00\u5206\uff0c\u95ee\u6240\u6709\u4eba\u540c\u5206\u65f6\u5019\u7684\u6700\u5927\u5206\u6570\u3002 \u601d\u8def\uff1a \u6a21\u62df\u9898\uff0c\u663e\u7136\u6bcf\u6b21\u53ea\u7528 2-3 \u4eba\uff0c\u90a3\u4e48\uff1a \u5982\u679c\u53ea\u6709\u4e00\u4e2a\u6700\u5927\u7684\u5c31\u548c\u6b21\u5927\u7684\u4e00\u8d77\u51cf\u4e00\u5206\u3002 \u5982\u679c\u662f\u5076\u6570\u5219\u9009\u62e9\u4e24\u4e2a\u51cf\u4e00\u5206\u3002 \u5982\u679c\u662f\u5947\u6570\u5219\u9009\u62e9\u4e09\u4e2a\u51cf\u4e00\u5206\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e2 + 10 , M = 1e4 + 10 ; struct E { int id , v ; E () {} E ( int id , int v ) : id ( id ), v ( v ) {} bool operator < ( const E & other ) const { return v < other . v ; } } a [ N ]; int n ; int f [ M ][ N ]; priority_queue < E > q ; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , & a [ i ]. v ); a [ i ]. id = i ; q . push ( a [ i ]); } for ( int cas = 1 ;; ++ cas ) { vector < E > vec ; vec . push_back ( q . top ()); q . pop (); while ( ! q . empty ()) { if ( q . top (). v == vec [ 0 ]. v ) { vec . push_back ( q . top ()); q . pop (); } else { break ; } } if ( vec . size () == n ) { printf ( \"%d \\n \" , vec [ 0 ]. v ); printf ( \"%d \\n \" , cas - 1 ); for ( int i = 1 ; i < cas ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { printf ( \"%d\" , f [ i ][ j ]); } puts ( \"\" ); } break ; } if ( vec . size () == 1 ) { E tmp = q . top (); q . pop (); tmp . v = max ( tmp . v - 1 , 0 ); f [ cas ][ tmp . id ] = 1 ; q . push ( tmp ); vec [ 0 ]. v = max ( vec [ 0 ]. v - 1 , 0 ); f [ cas ][ vec [ 0 ]. id ] = 1 ; q . push ( vec [ 0 ]); } else if ( vec . size () % 2 == 0 ) { vec [ 0 ]. v = max ( vec [ 0 ]. v - 1 , 0 ); vec [ 1 ]. v = max ( vec [ 1 ]. v - 1 , 0 ); f [ cas ][ vec [ 0 ]. id ] = 1 ; f [ cas ][ vec [ 1 ]. id ] = 1 ; for ( auto it : vec ) { q . push ( it ); } } else { vec [ 0 ]. v = max ( vec [ 0 ]. v - 1 , 0 ); vec [ 1 ]. v = max ( vec [ 1 ]. v - 1 , 0 ); vec [ 2 ]. v = max ( vec [ 2 ]. v - 1 , 0 ); f [ cas ][ vec [ 0 ]. id ] = 1 ; f [ cas ][ vec [ 1 ]. id ] = 1 ; f [ cas ][ vec [ 2 ]. id ] = 1 ; for ( auto it : vec ) { q . push ( it ); } } } return 0 ; }","title":"A. Toda 2"},{"location":"trainings/random-trainings/2016-2017-ACM-ICPC-NEERC-Southern-Subregional-Contest/#b-minimum-and-maximum","text":"Solved By Hsueh-. 1:05(+) \u9898\u610f\uff1a \u7ed9\u5b9a\u6570\u7ec4\u957f\u5ea6\uff0c\u6bcf\u6b21\u53ef\u4ee5\u8be2\u95ee a_i, a_j a_i, a_j \u7684\u5927\u5c0f\u5173\u7cfb\u3002 \u5728\u53ea\u80fd\u8be2\u95ee \\frac{3n}{2}-2 \\frac{3n}{2}-2 \u6b21\u7684\u60c5\u51b5\u4e0b\u5f97\u51fa\u7684\u6700\u5927\u503c\u4e0b\u6807\u548c\u6700\u5c0f\u503c\u4e0b\u6807\u3002 \u601d\u8def\uff1a \u5148\u8be2\u95ee\u76f8\u90bb\u7684\u4e24\u4e2a\uff0c\u5927\u7684\u653e\u5728 Big \u91cc\uff0c\u5c0f\u7684\u653e\u5728 Small \u91cc\u9762\uff0c\u90a3\u4e48\u8fd9\u65f6\u5019\u8be2\u95ee\u4e86 \\frac{n}{2} \\frac{n}{2} \u6b21\uff0c\u6bcf\u4e2a\u6570\u7ec4\u53ea\u6709 \\frac{n}{2} \\frac{n}{2} \u4e2a\u5143\u7d20\u3002 \u63a5\u4e0b\u6765\u6700\u5927\u503c\u53bb Big \u91cc\u9762\u627e\uff0c\u6700\u5c0f\u503c\u53bb Small \u91cc\u627e\uff0c\u5206\u522b\u9700\u8981 \\frac{n}{2}-1 \\frac{n}{2}-1 \u6b21\uff0c\u5c31\u53ef\u4ee5\u4e86\u3002 Code #include <bits/stdc++.h> using namespace std ; int n ; int ask ( int x , int y ) { if ( x == y ) return 0 ; printf ( \"? %d %d \\n \" , x + 1 , y + 1 ); fflush ( stdout ); char op [ 10 ]; scanf ( \"%s\" , op ); if ( op [ 0 ] == '<' ) return -1 ; else if ( op [ 1 ] == '=' ) return 0 ; else return 1 ; } int main () { int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d\" , & n ); vector < int > big , small ; for ( int i = 0 ; i < n / 2 ; ++ i ) { if ( ask ( 2 * i , 2 * i + 1 ) < 0 ) { big . push_back ( 2 * i + 1 ); small . push_back ( 2 * i ); } else { small . push_back ( 2 * i + 1 ); big . push_back ( 2 * i ); } } if ( n & 1 ) { big . push_back ( n - 1 ); small . push_back ( n - 1 ); } int Min = small [ 0 ], Max = big [ 0 ]; for ( int i = 1 , len = small . size (); i < len ; ++ i ) { if ( ask ( Min , small [ i ]) > 0 ) { Min = small [ i ]; } } for ( int i = 1 , len = big . size (); i < len ; ++ i ) { if ( ask ( Max , big [ i ]) < 0 ) { Max = big [ i ]; } } printf ( \"! %d %d \\n \" , Min + 1 , Max + 1 ); fflush ( stdout ); } return 0 ; }","title":"B. Minimum and Maximum"},{"location":"trainings/random-trainings/2016-2017-ACM-ICPC-NEERC-Southern-Subregional-Contest/#c-bulmart","text":"Solved By Hsueh- & Dup4. 3:09(+3) \u9898\u610f\uff1a \u6709 n n \u4e2a\u57ce\u5e02\uff0c m m \u6761\u65e0\u5411\u8fb9\uff0c\u6709 w w \u4e2a\u5546\u5e97\uff0c\u7b2c i i \u4e2a\u5546\u5e97\u5ea7\u843d\u5728\u7b2c i i \u4e2a\u57ce\u5e02\uff0c\u62e5\u6709 k_i k_i \u4ef6\u5546\u54c1\uff0c\u5546\u54c1\u7684\u5355\u4ef7\u4e3a p_i p_i . \u73b0\u5728\u6709 q q \u6b21\u8be2\u95ee\uff0c\u6bcf\u6b21\u8be2\u95ee\u7ed9\u51fa g_j, r_j, a_j g_j, r_j, a_j \uff0c\u8868\u793a\u67d0\u4eba\u5728 g_j g_j \u90a3\u4e2a\u57ce\u5e02\uff0c\u9700\u8981\u4e70\u5165\u81f3\u5c11 r_j r_j \u4ef6\u7269\u54c1\uff0c\u603b\u82b1\u8d39\u4e0d\u8d85\u8fc7 a_j a_j \uff0c\u95ee\u6700\u5c11\u7684\u65f6\u95f4\u3002 \u8fd9\u91cc\u7684\u8d2d\u4e70\u53ef\u4ee5\u8ba9\u5176\u4ed6\u57ce\u5e02\u90ae\u5bc4\u8fc7\u6765\uff0c\u65f6\u95f4\u662f\u82b1\u8d39\u6700\u957f\u7684\u90a3\u4e2a\u5305\u88f9\uff0c\u8fb9\u6743\u4e3a 1 1 \u3002 \u601d\u8def\uff1a \u5148\u9884\u5904\u7406\u51fa\u6bcf\u4e2a\u70b9\u5230\u5176\u4ed6\u4efb\u610f\u4e00\u70b9\u7684\u6700\u5c0f\u8ddd\u79bb\u3002 \u7136\u540e\u5c06\u6bcf\u4e2a\u5546\u5e97\u6309\u7167\u5355\u4ef7\u6392\u5e8f\uff0c\u5bf9\u4e8e\u6bcf\u6b21\u8be2\u95ee\uff0c\u4e8c\u5206 t t \uff0c\u7136\u540e\u8d2a\u5fc3\u53bb\u7b26\u5408\u8981\u6c42\u7684\u5546\u5e97\u8d2d\u4e70\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(nm + nw \\log n) O(nm + nw \\log n) \u3002 \u5176\u5b9e\u5806\u4f18\u5316\u53ef\u64a4\u9500\u8d2a\u5fc3\u4e5f\u662f\u53ef\u4ee5\u7684\uff0c\u8d5b\u540e\u8fc7\u4e86( Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define SZ(x) (int((x).size())) const int N = 2e5 + 10 ; int n ; ll r , l [ N ], t [ N ]; int main () { scanf ( \"%d%lld\" , & n , & r ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld\" , l + i ); } for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld\" , t + i ); if ( l [ i ] > t [ i ]) { puts ( \"-1\" ); return 0 ; } } vector < ll > vec ; int limit = 1e5 ; ll res = 0 , pre = 0 , T = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( pre >= l [ i ]) { pre -= l [ i ]; T += l [ i ]; continue ; } l [ i ] -= pre ; t [ i ] -= pre ; T += pre ; pre = 0 ; ll need = l [ i ] * 2 - t [ i ]; if ( need <= 0 ) { T += l [ i ] * 2 ; } else { ll cnt = need / r ; ll mod = need % r ; res += cnt ; res += ( mod > 0 ); for ( ll j = 1 , k = T ; j <= cnt && SZ ( vec ) < limit ; ++ j , k += r ) { vec . push_back ( k ); } T += r * cnt ; l [ i ] -= r * cnt ; l [ i ] -= mod ; T += l [ i ] * 2 ; if ( mod ) { vec . push_back ( T ); pre = r - mod ; } T += mod ; } } printf ( \"%lld \\n \" , res ); if ( res <= limit ) { for ( int i = 0 ; i < SZ ( vec ); ++ i ) { printf ( \"%lld%c\" , vec [ i ], \" \\n \" [ i == SZ ( vec ) - 1 ]); } } else { puts ( \"\" ); } return 0 ; }","title":"C. Bulmart"},{"location":"trainings/random-trainings/2016-2017-ACM-ICPC-NEERC-Southern-Subregional-Contest/#d-running-over-the-bridges","text":"Solved By Dup4 & Hsueh-. 4:09(+3) \u9898\u610f\uff1a \u6709 n n \u5ea7\u6865, \u7b2c i i \u5ea7\u6865\u7684\u957f\u5ea6\u4e3a l_i l_i \uff0c\u5728\u7b2c i i \u5ea7\u6865\u4e0a\u6700\u591a\u7684\u505c\u7559\u65f6\u95f4\u4e3a t_i t_i \uff0c\u73b0\u5728\u6709\u4e00\u4e2a\u4eba\u8981\u4ece\u7b2c 1 1 \u5ea7\u6865\u6309\u987a\u5e8f\u7ecf\u8fc7\u8fd9 n n \u5ea7\u6865\uff0c\u5b83\u7684\u901f\u5ea6\u662f 2s 2s \u8d70\u4e00\u4e2a\u5355\u4f4d\u957f\u5ea6\uff0c\u4f46\u662f\u6709\u4e00\u79cd\u836f\u6c34\uff0c\u6bcf\u6b21\u559d\u4e0b\u540e\u6301\u7eed r r \u4e2a\u65f6\u95f4\u5355\u4f4d\uff0c\u4f7f\u5f97\u5b83\u80fd\u591f 1s 1s \u8d70\u4e00\u4e2a\u5355\u4f4d\u957f\u5ea6\uff0c\u95ee\u8fd9\u4e2a\u4eba\u6700\u5c11\u8981\u559d\u591a\u5c11\u6b21\u836f\u6c34\uff0c\u4f7f\u5f97\u80fd\u8d70\u5b8c\u8fd9 n n \u5ea7\u6865\uff0c\u5728\u6ee1\u8db3\u4e0a\u8ff0\u9650\u5236\u7684\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u559d\u7684\u6b21\u6570\u5c0f\u4e8e\u7b49\u4e8e 10^5 10^5 , \u90a3\u4e48\u8981\u8f93\u51fa\u559d\u836f\u6c34\u7684\u65f6\u523b\u3002 \u601d\u8def\uff1a \u8d2a\u5fc3\uff0c\u5bf9\u4e8e\u6bcf\u5ea7\u6865\uff0c\u8003\u8651\u5bf9\u4e8e\u8fd9\u5ea7\u6865\u6700\u5c11\u8981\u559d\u51e0\u6b21\uff0c\u7136\u540e\u6700\u540e\u4e00\u6b21\u559d\u836f\u6c34\uff0c\u5c3d\u91cf\u9760\u540e\uff0c\u628a\u836f\u6c34\u7684\u6536\u76ca\u7559\u7ed9\u4e0b\u4e00\u5ea7\u6865\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define SZ(x) (int((x).size())) const int N = 2e5 + 10 ; int n ; ll r , l [ N ], t [ N ]; int main () { scanf ( \"%d%lld\" , & n , & r ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld\" , l + i ); } for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld\" , t + i ); if ( l [ i ] > t [ i ]) { puts ( \"-1\" ); return 0 ; } } vector < ll > vec ; int limit = 1e5 ; ll res = 0 , pre = 0 , T = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( pre >= l [ i ]) { pre -= l [ i ]; T += l [ i ]; continue ; } l [ i ] -= pre ; t [ i ] -= pre ; T += pre ; pre = 0 ; ll need = l [ i ] * 2 - t [ i ]; if ( need <= 0 ) { T += l [ i ] * 2 ; } else { ll cnt = need / r ; ll mod = need % r ; res += cnt ; res += ( mod > 0 ); for ( ll j = 1 , k = T ; j <= cnt && SZ ( vec ) < limit ; ++ j , k += r ) { vec . push_back ( k ); } T += r * cnt ; l [ i ] -= r * cnt ; l [ i ] -= mod ; T += l [ i ] * 2 ; if ( mod ) { vec . push_back ( T ); pre = r - mod ; } T += mod ; } } printf ( \"%lld \\n \" , res ); if ( res <= limit ) { for ( int i = 0 ; i < SZ ( vec ); ++ i ) { printf ( \"%lld%c\" , vec [ i ], \" \\n \" [ i == SZ ( vec ) - 1 ]); } } else { puts ( \"\" ); } return 0 ; }","title":"D. Running Over The Bridges"},{"location":"trainings/random-trainings/2016-2017-ACM-ICPC-NEERC-Southern-Subregional-Contest/#e-award-ceremony","text":"Solved By Hsueh- & ltslts. 3:50(+) \u9898\u610f\uff1a \u6bcf\u4e2a\u4eba\u6709\u4e00\u4e2a\u8d77\u59cb\u7684\u5206\u6570 a_i a_i \u4ee5\u53ca\u4e00\u4e2a\u7b49\u5f85\u63ed\u6653\u7684\u5206\u6570 d_i d_i \u3002 \u5047\u8bbe\u63ed\u5f00\u67d0\u4eba\u540e\uff0c\u4ed6\u7684\u6392\u540d\u53d8\u5316 t t \u3002 \u5b89\u6392\u4e00\u4e2a\u63ed\u5f00\u5206\u6570\u7684\u987a\u5e8f\u4f7f\u5f97 \\sum t \\sum t \u6700\u5927\u3002 \u601d\u8def\uff1a \u663e\u7136\u5bf9\u6bcf\u4e24\u4e2a\u4eba\u7684\u6392\u540d\u5148\u540e\u987a\u5e8f\u53d8\u5316\u7814\u7a76\uff0c\u7136\u540e\u6c42 sum \u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e2 + 10 ; struct E { int id , a , d ; bool operator < ( const E & other ) const { if ( a != other . a ) { return a > other . a ; } else { return id < other . id ; } } } a [ N ]; int n ; int f ( int x , int y ) { E startX = a [ x ], startY = a [ y ]; E endX = a [ x ], endY = a [ y ]; endX . a += endX . d ; endY . a += endY . d ; if ( startX < startY && endY < endX ) return 1 ; if ( startY < startX && endX < endY ) return 1 ; if ( startX < startY && endY < startX && endX < endY ) return 2 ; if ( startX < startY && startY < endX && endX < endY ) return 2 ; if ( startY < startX && startX < endY && endY < endX ) return 2 ; if ( startY < startX && endX < startY && endY < endX ) return 2 ; return 0 ; } int main () { #ifdef LOCAL_JUDGE freopen ( \"input\" , \"r\" , stdin ); #endif scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d %d\" , & a [ i ]. a , & a [ i ]. d ); a [ i ]. id = i ; } int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i + 1 ; j <= n ; ++ j ) { res += f ( i , j ); } } printf ( \"%d \\n \" , res ); return 0 ; }","title":"E. Award Ceremony"},{"location":"trainings/random-trainings/2016-2017-ACM-ICPC-NEERC-Southern-Subregional-Contest/#f-ber-patio","text":"UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"F. Ber Patio"},{"location":"trainings/random-trainings/2016-2017-ACM-ICPC-NEERC-Southern-Subregional-Contest/#g-car-repair-shop","text":"Solved By Dup4. 0:54(+) \u9898\u610f\uff1a \u6709\u4e00\u4e2a\u4fee\u8f66\u5e97\uff0c\u6bcf\u4e00\u65f6\u523b\u53ea\u80fd\u4fee\u4e00\u8f86\u8f66\u3002 \u73b0\u5728\u6709 n n \u8f86\u8f66\uff0c\u6bcf\u8f86\u8f66\u6709 s_i, d_i s_i, d_i \uff0c\u8868\u793a\u987e\u5ba2\u5e0c\u671b\u4ece s_i s_i \u65f6\u523b\u5f00\u59cb\u4fee\uff0c d_i d_i \u8868\u793a\u8fd9\u8f86\u8f66\u9700\u8981\u4fee d_i d_i \u65f6\u95f4\u3002 \u73b0\u5728\u5bf9\u4e8e\u6bcf\u8f86\u8f66\uff1a \u5982\u679c [s_i, s_i + d_i - 1] [s_i, s_i + d_i - 1] \u8fd9\u4e2a\u65f6\u95f4\u6bb5\u6ca1\u88ab\u5360\u7528\uff0c\u90a3\u4e48\u8fd9\u8f86\u8f66\u5c31\u88ab\u5b89\u6392\u5728\u8fd9\u4e2a\u65f6\u95f4\u6bb5\u4fee\u3002 \u5426\u5219\uff0c\u627e\u4e00\u4e2a\u6700\u5c0f\u7684\u6b63\u6574\u6570 x x \uff0c\u6ee1\u8db3 [x, x + d_i - 1] [x, x + d_i - 1] \u8fd9\u4e2a\u65f6\u95f4\u6bb5\u6ca1\u6709\u6c7d\u8f66\u4fee\uff0c\u8fd9\u4e2a\u65f6\u5019 x \\leq s_i x \\leq s_i \u662f\u88ab\u5141\u8bb8\u7684\u3002 \u601d\u8def\uff1a \u7528\u4e2a\u5bb9\u5668\u7ef4\u62a4\u4e00\u4e2a\u4e8c\u5143\u7ec4\uff0c\u7136\u540e\u95ee\u9898\u5c31\u76f8\u5f53\u4e8e\u5224\u65ad\u7ebf\u6bb5\u662f\u5426\u76f8\u4ea4\u3002 \u5bf9\u4e8e\u7b2c\u4e8c\u79cd\u64cd\u4f5c\uff0c\u5bb9\u6613\u53d1\u73b0\u8d2a\u5fc3\u7684\u9009 x x \uff0c\u53ef\u53d6\u7684\u503c\u5e76\u4e0d\u591a\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; using pLL = pair < ll , ll > ; #define fi first #define se second const int N = 210 ; int n ; ll s [ N ], d [ N ]; vector < pLL > vec ; bool cross ( pLL x , pLL y ) { if (( x . fi <= y . fi && x . se >= y . fi ) || ( x . fi <= y . se && x . se >= y . se ) || ( y . fi <= x . fi && y . se >= x . fi ) || ( y . fi <= x . se && y . fi >= x . se )) return true ; return false ; } bool ok ( ll l , ll r ) { for ( auto & it : vec ) { if ( cross ( pLL ( l , r ), it )) { return false ; } } return true ; } pLL get ( ll d ) { if ( ok ( 1 , 1 + d - 1 )) return pLL ( 1 , 1 + d - 1 ); for ( auto & it : vec ) { if ( ok ( it . se + 1 , it . se + d )) { return pLL ( it . se + 1 , it . se + d ); } } } int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld%lld\" , s + i , d + i ); } for ( int i = 1 ; i <= n ; ++ i ) { pLL tmp = pLL ( s [ i ], s [ i ] + d [ i ] - 1 ); if ( ! ok ( s [ i ], s [ i ] + d [ i ] - 1 )) { tmp = get ( d [ i ]); } vec . push_back ( tmp ); sort ( vec . begin (), vec . end ()); printf ( \"%lld %lld \\n \" , tmp . fi , tmp . se ); } return 0 ; }","title":"G. Car Repair Shop"},{"location":"trainings/random-trainings/2016-2017-ACM-ICPC-NEERC-Southern-Subregional-Contest/#h-delete-them","text":"Solved By Dup4. 0:41(+) \u9898\u610f\uff1a \u6709 n n \u4e2a\u5b57\u7b26\u4e32\uff0c\u73b0\u5728\u9009\u51fa m m \u4e2a\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u8981\u6784\u9020\u4e00\u4e2a\u6a21\u5f0f\u4e32\uff0c\u4f7f\u5f97\u6a21\u5f0f\u4e32\u80fd\u5339\u914d\u4e0a\u8fd9 m m \u4e2a\u5b57\u7b26\u4e32\uff0c\u4f46\u662f\u4e0d\u80fd\u5339\u914d\u4e0a\u5269\u4e0b\u7684 n - m n - m \u4e2a\u5b57\u7b26\u4e32\uff0c\u6a21\u5f0f\u4e32\u4e2d\u53ef\u4ee5\u6709 ? \uff0c\u4f46\u662f\u6ca1\u6709 * \u3002 \u601d\u8def\uff1a \u5bf9\u4e8e m m \u4e2a\u5b57\u7b26\u4e32\uff0c\u6309\u4f4d\u8003\u8651\uff0c\u5982\u679c\u5f53\u524d\u4f4d\u76f8\u540c\uff0c\u5c31\u653e\u7279\u5b9a\u5b57\u7b26\uff0c\u5426\u5219\u653e ? \u3002 \u7136\u540e\u62ff\u8fd9\u4e2a\u6a21\u5f0f\u4e32\u53bb\u5339\u914d\u5269\u4e0b\u7684 n - m n - m \u4e2a\uff0c\u5982\u679c\u80fd\u5339\u914d\u4e0a\u5c31\u65e0\u89e3\u3002 Code #include <bits/stdc++.h> using namespace std ; #define SZ(x) (int(x.size())) const int N = 1e2 + 10 ; int n , m , vis [ N ]; vector < string > s ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); cin >> n >> m ; s . clear (); s . resize ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { cin >> s [ i ]; } vector < int > vec ( m ); for ( auto & it : vec ) cin >> it , vis [ it ] = 1 ; string t = \"\" ; int len = SZ ( s [ vec [ 0 ]]); for ( int i = 1 ; i < m ; ++ i ) { if ( SZ ( s [ vec [ i ]]) != len ) { cout << \"No \\n \" ; return 0 ; } } for ( int i = 0 ; i < len ; ++ i ) { char ch = s [ vec [ 0 ]][ i ]; int ok = 1 ; for ( int j = 1 ; j < m ; ++ j ) { if ( s [ vec [ j ]][ i ] != ch ) { ok = 0 ; break ; } } if ( ok ) t += ch ; else t += \"?\" ; } for ( int i = 1 ; i <= n ; ++ i ) if ( vis [ i ] == 0 && SZ ( s [ i ]) == len ) { int ok = 1 ; for ( int j = 0 ; j < len ; ++ j ) { if ( s [ i ][ j ] != t [ j ] && t [ j ] != '?' ) { ok = 0 ; break ; } } if ( ok ) { cout << \"No \\n \" ; return 0 ; } } cout << \"Yes \\n \" ; cout << t << \" \\n \" ; return 0 ; }","title":"H. Delete Them"},{"location":"trainings/random-trainings/2016-2017-ACM-ICPC-NEERC-Southern-Subregional-Contest/#i-olympiad-in-programming-and-sports","text":"Solved By Hsueh-. 2:49(+7) \u9898\u610f\uff1a \u6709 n n \u4e2a\u5b66\u751f\uff0c\u4e24\u4e2a\u793e\u56e2 A, B A, B \uff0c\u7b2c i i \u4e2a\u5b66\u751f\u52a0\u5165 A A \u793e\u56e2\uff0c\u80fd\u7ed9 A A \u793e\u56e2\u5e26\u6765 a_i a_i \u70b9\u5c5e\u6027\u503c\uff0c\u52a0\u5165 B B \u793e\u56e2\u80fd\u5e26\u6765 b_i b_i \u70b9\u5c5e\u6027\uff0c\u73b0\u5728\u8981\u6311\u9009 p p \u4e2a\u5b66\u751f\u52a0\u5165 A A \u793e\u56e2\uff0c s s \u4e2a\u5b66\u751f\u52a0\u5165 B B \u793e\u56e2\uff0c\u4f7f\u5f97\u5e26\u6765\u7684\u5c5e\u6027\u548c\u6700\u5927\u3002 \u95ee\u6700\u5927\u5c5e\u6027\u548c\u3002 \u601d\u8def\uff1a \u8d39\u7528\u6d41\u3002 \u6e90\u70b9\u5411\u6bcf\u4e2a\u4eba\u6d41\u6d41\u91cf 1 \uff0c\u8d39\u7528 0 \u7684\u8fb9\u3002 \u6bcf\u4e2a\u4eba\u5411 A , B \u7ec4\u6d41\u6d41\u91cf 1 \uff0c\u8d39\u7528\u4e3a -a_i/-b_i -a_i/-b_i \u7684\u8fb9\u3002 A , B \u7ec4\u5206\u522b\u5411\u6c47\u70b9\u6d41 p , s \u7684\u8fb9\u3002 Code #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } struct Min_Cost_Max_Flow { static const int N = 1e4 + 10 ; static const int M = 1e6 + 10 ; const int INF = 0x3f3f3f3f ; struct E { int to , nxt , cap , flow , cost ; } edge [ M << 1 ]; int head [ N ], tot ; int pre [ N ], dis [ N ]; int vis [ N ]; int n ; void init ( int _n ) { n = _n ; tot = 0 ; memset ( head , -1 , sizeof head ); } void addedge ( int u , int v , int cap , int cost ) { edge [ tot ] = { v , head [ u ], cap , 0 , cost }; head [ u ] = tot ++ ; edge [ tot ] = { u , head [ v ], 0 , 0 , - cost }; head [ v ] = tot ++ ; } bool SPFA ( int s , int t ) { queue < int > q ; for ( int i = 1 ; i <= n ; ++ i ) { dis [ i ] = INF ; vis [ i ] = false ; pre [ i ] = -1 ; } dis [ s ] = 0 ; vis [ s ] = true ; q . push ( s ); while ( ! q . empty ()) { int u = q . front (); q . pop (); vis [ u ] = false ; for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { int v = edge [ i ]. to ; if ( edge [ i ]. cap > edge [ i ]. flow && dis [ v ] > dis [ u ] + edge [ i ]. cost ) { dis [ v ] = dis [ u ] + edge [ i ]. cost ; pre [ v ] = i ; if ( ! vis [ v ]) { vis [ v ] = true ; q . push ( v ); } } } } if ( pre [ t ] == -1 ) return false ; else return true ; } int gao ( int s , int t , int & cost ) { int flow = 0 ; cost = 0 ; while ( SPFA ( s , t )) { int Min = INF ; for ( int i = pre [ t ]; i != -1 ; i = pre [ edge [ i ^ 1 ]. to ]) { if ( Min > edge [ i ]. cap - edge [ i ]. flow ) { Min = edge [ i ]. cap - edge [ i ]. flow ; } } for ( int i = pre [ t ]; i != -1 ; i = pre [ edge [ i ^ 1 ]. to ]) { edge [ i ]. flow += Min ; edge [ i ^ 1 ]. flow -= Min ; cost += edge [ i ]. cost * Min ; } flow += Min ; } return flow ; } } MSMF ; const int N = 3e3 + 10 ; int n , s , p ; int a [ N ], b [ N ]; int main () { #ifdef LOCAL_JUDGE freopen ( \"input\" , \"r\" , stdin ); #endif scanf ( \"%d %d %d\" , & n , & p , & s ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); } for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , b + i ); } int A = n + 1 , B = n + 2 , S = n + 3 , T = n + 4 ; MSMF . init ( T + 10 ); for ( int i = 1 ; i <= n ; ++ i ) { MSMF . addedge ( S , i , 1 , 0 ); MSMF . addedge ( i , A , 1 , - a [ i ]); MSMF . addedge ( i , B , 1 , - b [ i ]); } MSMF . addedge ( A , T , p , 0 ); MSMF . addedge ( B , T , s , 0 ); int cost = 0 ; int flow = MSMF . gao ( S , T , cost ); assert ( flow == p + s ); vector < int > vec_A , vec_B ; for ( int u = 1 ; u <= n ; ++ u ) { for ( int i = MSMF . head [ u ]; ~ i ; i = MSMF . edge [ i ]. nxt ) { if ( MSMF . edge [ i ]. cap == MSMF . edge [ i ]. flow && MSMF . edge [ i ]. to == A ) { vec_A . push_back ( u ); break ; } if ( MSMF . edge [ i ]. cap == MSMF . edge [ i ]. flow && MSMF . edge [ i ]. to == B ) { vec_B . push_back ( u ); break ; } } } // assert(vec_A.size() == p && vec_B.size() == s); printf ( \"%d \\n \" , - cost ); for ( int i = 0 , len = vec_A . size (); i < len ; ++ i ) { printf ( \"%d%c\" , vec_A [ i ], \" \\n \" [ i == len - 1 ]); } for ( int i = 0 , len = vec_B . size (); i < len ; ++ i ) { printf ( \"%d%c\" , vec_B [ i ], \" \\n \" [ i == len - 1 ]); } return 0 ; }","title":"I. Olympiad in Programming and Sports"},{"location":"trainings/random-trainings/2016-2017-ACM-ICPC-NEERC-Southern-Subregional-Contest/#j-bottles","text":"Solved By Dup4. 1:25(+1) \u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u74f6\u5b50\uff0c\u6bcf\u4e2a\u74f6\u5b50\u91cc\u9762\u6709 a_i a_i \u5347\u6c34\uff0c\u6bcf\u4e2a\u74f6\u5b50\u7684\u5bb9\u91cf\u662f b_i b_i \uff0c\u4fdd\u8bc1 a_i \\leq b_i a_i \\leq b_i , \u73b0\u5728\u53ef\u4ee5\u5c06\u4e00\u4e2a\u74f6\u5b50\u7684\u6c34\u5012\u5165\u53e6\u4e00\u4e2a\u74f6\u5b50\u7684\u6c34\uff0c\u5012\u5165 1 1 \u5347\u6c34\u9700\u8981\u4e00\u4e2a\u5355\u4f4d\u65f6\u95f4\u3002 \u73b0\u5728\u8981\u5c06\u6240\u6709\u6c34\u5b58\u653e\u5728 k k \u4e2a\u74f6\u5b50\u4e2d\uff0c\u4f7f\u5f97 k k \u6700\u5c11\uff0c\u5176\u6b21\u4fdd\u8bc1\u6240\u7528\u65f6\u95f4 T T \u6700\u5c11\u3002 \u601d\u8def\uff1a \u663e\u7136\uff0c\u9898\u76ee\u8981\u6c42\u627e k k \u4e2a\u74f6\u5b50\uff0c\u4f7f\u5f97\u8fd9 k k \u4e2a\u74f6\u5b50\u7684\u5bb9\u91cf\u548c\u5927\u4e8e\u7b49\u4e8e\u6240\u6709\u6c34\u7684\u4f53\u79ef\uff0c\u5e76\u4e14\u6ee1\u8db3\u5269\u4e0b n - k n - k \u4e2a\u74f6\u5b50\u91cc\u88c5\u7684\u6c34\u6700\u5c11\uff0c\u5373\u8f6c\u79fb\u7684\u6c34\u6700\u5c11\uff0c\u90a3\u4e48\u5c31\u662f\u9009\u4e2d\u7684 k k \u4e2a\u74f6\u5b50\u91cc\u88c5\u7684\u6c34\u8d8a\u591a\u3002 f[i][j] f[i][j] \u8868\u793a\u7528\u4e86 i i \u4e2a\u74f6\u5b50\uff0c\u4f53\u79ef\u4e3a j j \u65f6\u6240\u62e5\u6709\u7684\u6c34\u4f53\u79ef\u7684\u6700\u5927\u503c\uff0c\u7136\u540e\u80cc\u5305\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using pII = pair < int , int > ; #define fi first #define se second #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 110 ; int n , f [ N ][ N * N ]; pII a [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , & a [ i ]. fi ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , & a [ i ]. se ); sort ( a + 1 , a + 1 + n , [ & ]( pII x , pII y ) { return x . se > y . se ; }); int all = 0 , vol = 0 , K = -1 ; for ( int i = 1 ; i <= n ; ++ i ) { all += a [ i ]. fi ; } for ( int i = 1 ; i <= n ; ++ i ) { vol += a [ i ]. se ; if ( K == -1 && vol >= all ) { K = i ; } } memset ( f , -0x3f , sizeof f ); f [ 0 ][ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = K ; j >= 1 ; -- j ) { for ( int k = vol - a [ i ]. se ; k >= 0 ; -- k ) { // dbg(i, j, k); f [ j ][ k + a [ i ]. se ] = max ( f [ j ][ k + a [ i ]. se ], f [ j - 1 ][ k ] + a [ i ]. fi ); } } } int Max = 0 ; for ( int i = all ; i <= vol ; ++ i ) { Max = max ( Max , f [ K ][ i ]); } printf ( \"%d %d \\n \" , K , all - Max ); return 0 ; }","title":"J. Bottles"},{"location":"trainings/random-trainings/2016-2017-ACM-ICPC-NEERC-Southern-Subregional-Contest/#k-roads-orientation-problem","text":"UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"K. Roads Orientation Problem"},{"location":"trainings/random-trainings/2016-2017-ACM-ICPC-NEERC-Southern-Subregional-Contest/#l-expression-queries","text":"UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"L. Expression Queries"},{"location":"trainings/random-trainings/2017-2018-ACM-ICPC-NEERC-Southern-Subregional-Contest/","text":"2017-2018 ACM-ICPC, NEERC, Southern Subregional Contest Contents Contest Info Solutions A. Automatic Door B. Berland Army C. Downloading B++ D. Packmen Strike Back E. Field of Wonders F. Lost in Transliteration G. Orientation of Edges H. Palindromic Cu I. Photo Processing J. Renovation K. Road Widening L. Berland.Taxi M. Quadcopter Competition Contest Info Practice Link Solved A B C D E F G H I J K L M 10/13 - - \u00d8 O O O O O O O O - O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5 Solutions A. Automatic Door UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a B. Berland Army UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a C. Downloading B++ UpSolved by Dup4. \u9898\u610f\uff1a \u8981\u4e0b\u8f7d\u4e00\u4e2a\u8f6f\u4ef6\uff0c\u9ed8\u8ba4\u7684\u4e0b\u8f7d\u901f\u5ea6\u662f t_0 s/byte t_0 s/byte , \u53ef\u4ee5\u82b1\u8d39 p_1 p_1 \u5143\uff0c\u4e70\u52a0\u901f\u5305\uff0c\u80fd\u591f\u4ee5 t_1 s/byte t_1 s/byte \u4e0b\u8f7d a_1 byte a_1 byte \uff0c\u6216\u8005\u82b1\u8d39 p_2 p_2 \u5143\uff0c\u80fd\u591f\u4ee5 t_2 s/byte t_2 s/byte \u4e0b\u8f7d a_2 byte a_2 byte \uff0c\u95ee\u5728 T T \u65f6\u95f4\u5185\u4e0b\u8f7d\u5b8c\uff0c\u6700\u5c11\u9700\u8981\u82b1\u591a\u5c11\u94b1\u3002 \u601d\u8def\uff1a \u679a\u4e3e\u4e00\u4e2a\u52a0\u901f\u5305\u7684\u7528\u91cf\uff0c\u4e8c\u5206\u53e6\u4e00\u4e2a\u52a0\u901f\u5305\u7684\u7528\u91cf\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const ll INF = 1e18 ; ll f , T , t0 , a1 , t1 , p1 , a2 , p2 , t2 ; inline ll ceil ( ll x , ll y ) { return ( x + y - 1 ) / y ; } inline void chmin ( ll & x , ll y ) { if ( x > y ) x = y ; } struct E { ll a , t , p ; bool operator < ( const E & other ) const { if ( t != other . t ) return t < other . t ; return p < other . p ; } } e [ 3 ]; ll calc ( ll remind , ll x , E e ) { ll _remind = remind - e . a * x ; if ( _remind < 0 ) _remind = 0 ; ll useT = e . t * ( remind - _remind ); return useT + _remind * t0 ; } ll gao () { if ( t0 * f <= T ) return 0 ; ll res = INF ; int n = ceil ( f , e [ 1 ]. a ); for ( int i = 0 ; i <= n ; ++ i ) { ll now = e [ 1 ]. p * i ; ll remind = f - e [ 1 ]. a * i ; if ( remind < 0 ) remind = 0 ; ll useT = e [ 1 ]. t * ( f - remind ); if ( useT > T ) break ; ll _T = T - useT ; // dbg(i, remind, f - remind, useT, now, _T); if ( remind * e [ 0 ]. t <= _T ) { chmin ( res , now ); // dbg(i, remind, remind * e[0].t, now); } else { if ( remind * e [ 2 ]. t > _T ) continue ; int _n = ceil ( remind , e [ 2 ]. a ); int l = 0 , r = _n , tar = _n ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; // dbg(mid, calc(remind, mid, e[2])); if ( calc ( remind , mid , e [ 2 ]) <= _T ) { tar = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } // dbg(i, tar, _n); chmin ( res , now + e [ 2 ]. p * tar ); } } if ( res >= INF ) return -1 ; return res ; } int main () { scanf ( \"%lld%lld%lld\" , & f , & T , & t0 ); scanf ( \"%lld%lld%lld\" , & a1 , & t1 , & p1 ); scanf ( \"%lld%lld%lld\" , & a2 , & t2 , & p2 ); e [ 0 ] = { 1 , t0 , 0 }; e [ 1 ] = { a1 , t1 , p1 }; e [ 2 ] = { a2 , t2 , p2 }; sort ( e + 1 , e + 3 ); printf ( \"%lld \\n \" , gao ()); return 0 ; } D. Packmen Strike Back Solved By Hsueh-. 4:29(+) \u9898\u610f\uff1a \u4e00\u4e2a 1 \\cdot n 1 \\cdot n \u7684\u56fe\uff0c\u7ed9\u4e0a\u9762\u7684\u6bcf\u4e2a P \u89c4\u5b9a\u4e00\u4e2a\u65b9\u5411\uff0c\u4e00\u65e6\u65b9\u5411\u786e\u5b9a\u5c31\u4e0d\u80fd\u66f4\u6539\uff0c\u95ee\u5403\u5230\u6700\u5927\u7684 * \u7684\u6700\u4e0b\u65f6\u95f4\u3002 \u601d\u8def\uff1a \u5f53 P \u7684\u4e2a\u6570\u5927\u4e8e\u7b49\u4e8e 2 2 \u7684\u65f6\u5019\u53ef\u4ee5\u5403\u5230\u6240\u6709\u7684 * \u3002 \u90a3\u4e48\u4e8c\u5206\u7b54\u6848\u53bb check\u3002 f_i f_i \u8868\u793a\u524d i i \u4e2a P P \u80fd\u8986\u76d6\u7684\u6700\u5927\u7684 1 - f_i 1 - f_i \u3002 \u5bf9\u4e8e i i \u4e2a P P \u6709\u4e09\u79cd\u8f6c\u79fb\uff0c\u5206\u522b\u662f\u5411\u5de6\uff0c\u5411\u53f3\u6216\u8005 i - 1 i - 1 \u5411\u5de6 i i \u5411\u53f3\uff0c dp dp \u53bb check\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e6 + 10 ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } int n ; char s [ N ]; int a [ N ]; int f [ N ]; int P [ N ], tot ; bool ok ( int l , int r ) { if ( l > r ) return 1 ; else return a [ r ] - a [ l - 1 ] == 0 ; } bool check ( int x ) { memset ( f , 0 , sizeof f ); for ( int i = 1 ; i <= tot ; ++ i ) { // left if ( ok ( f [ i - 1 ] + 1 , P [ i ] - x - 1 )) f [ i ] = max ( f [ i ], P [ i ]); // right if ( ok ( f [ i - 1 ] + 1 , P [ i ] - 1 )) f [ i ] = max ( f [ i ], P [ i ] + x ); // left right if ( i >= 2 && ok ( f [ i - 2 ] + 1 , P [ i ] - x - 1 )) f [ i ] = max ( f [ i ], P [ i - 1 ] + x ); } // dbg(f[1], f[2]); return ok ( f [ tot ] + 1 , n ); } int main () { scanf ( \"%d\" , & n ); scanf ( \"%s\" , s + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { a [ i ] = a [ i - 1 ] + ( s [ i ] == '*' ); } for ( int i = 1 ; i <= n ; ++ i ) { if ( s [ i ] == 'P' ) { P [ ++ tot ] = i ; } } if ( tot == 1 ) { int cnt1 = 0 , cnt2 = 0 , pos = P [ 1 ], l = 0 , r = 0 ; for ( int i = pos - 1 ; i >= 1 ; -- i ) { if ( s [ i ] == '*' ) { ++ cnt1 ; l = i ; } } for ( int i = pos + 1 ; i <= n ; ++ i ) { if ( s [ i ] == '*' ) { ++ cnt2 ; r = i ; } } int res1 = 0 , res2 = 0 ; if ( cnt1 > cnt2 ) { res1 = cnt1 , res2 = pos - l ; } else if ( cnt2 > cnt1 ) { res1 = cnt2 , res2 = r - pos ; } else { res1 = cnt1 , res2 = min ( pos - l , r - pos ); } printf ( \"%d %d \\n \" , res1 , res2 ); } else { printf ( \"%d \" , a [ n ]); // check(4); int l = 0 , r = n , res = -1 ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( check ( mid )) { r = mid - 1 ; res = mid ; } else { l = mid + 1 ; } } printf ( \"%d \\n \" , res ); } return 0 ; } E. Field of Wonders Solved By Hsueh-. 1:39(+) \u9898\u610f\uff1a \u957f\u5ea6\u4e3a n n \u7684\u5b57\u7b26\u4e32\uff0c\u5176\u4e2d\u6709\u51e0\u4e2a\u4f4d\u7f6e\u662f\u4e0d\u786e\u5b9a\u7684\uff0c\u4f46\u662f\u7b54\u6848\u53ea\u6709 m m \u79cd\uff0c\u95ee\u4e00\u5b9a\u53ef\u4ee5\u6210\u4e3a * \u7684\u5b57\u7b26\u6709\u51e0\u4e2a\u3002 \u601d\u8def\uff1a \u6a21\u62df\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 ; int n , m ; string s ; string str [ N ]; int vis [ N ], cnt [ N ]; int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ), cout . tie ( nullptr ); cin >> n >> s ; for ( auto it : s ) { vis [ it ] ++ ; } cin >> m ; for ( int i = 1 ; i <= m ; ++ i ) { cin >> str [ i ]; } int res = 0 ; for ( int i = 'a' ; i <= 'z' ; ++ i ) { char c = i ; if ( vis [ i ]) continue ; bool F = true ; for ( int j = 1 ; j <= m ; ++ j ) { memset ( cnt , 0 , sizeof cnt ); bool FF = true ; for ( int k = 0 ; k < n ; ++ k ) { if ( s [ k ] == '*' && vis [ str [ j ][ k ]]) { FF = false ; break ; } if ( s [ k ] == '*' ) { cnt [ str [ j ][ k ]] ++ ; } else if ( s [ k ] != str [ j ][ k ]) { FF = false ; break ; } } if ( FF && ! cnt [ c ]) { F = false ; break ; } } res += F ; } cout << res << \" \\n \" ; return 0 ; } F. Lost in Transliteration Solved By Hsueh-. 0:32(+) \u9898\u610f\uff1a u \u53ef\u4ee5\u53d8\u6210 oo \u3002 h \u53ef\u4ee5\u53d8\u6210 kh \u3002 \u95ee\u6709\u51e0\u79cd\u5b57\u7b26\u4e32\uff1f \u601d\u8def\uff1a u \u53d8\u6210 oo \u3002 \u9047\u5230 h \u5220\u53bb\u524d\u9762\u7684 k \u3002 \u7136\u540e\u53bb\u91cd\u7edf\u8ba1\u4e2a\u6570\u3002 Code #include <bits/stdc++.h> using namespace std ; int n ; string s ; map < string , int > mp ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ), cout . tie ( nullptr ); cin >> n ; int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { cin >> s ; string t = \"\" ; for ( int j = 0 , len = s . size (); j < len ; ++ j ) { if ( s [ j ] == 'u' ) t += \"oo\" ; else { if ( s [ j ] == 'h' ) { while ( ! t . empty () && t [ t . size () - 1 ] == 'k' ) { t . pop_back (); } } t += s [ j ]; } } if ( ! mp . count ( t )) { mp [ t ] ++ ; ++ res ; } } cout << res << \" \\n \" ; return 0 ; } G. Orientation of Edges Solved By Hsueh-. 2:38(+) \u9898\u610f\uff1a \u4e00\u5f20\u6df7\u5408\u56fe\uff0c\u6709\u4e00\u4e9b\u6709\u5411\u8fb9\u548c\u65e0\u5411\u8fb9\uff0c\u7ed9\u5b9a\u4e00\u4e2a\u8d77\u70b9\uff0c\u5206\u522b\u7ed9\u65e0\u5411\u8fb9\u5b9a\u5411\u4f7f\u5f97 S \u5230\u8fbe\u7684\u70b9\u6700\u591a\u6700\u5c0f\uff0c\u72ec\u7acb\u56de\u7b54\u6700\u5927\u6700\u5c0f\u503c\u3002 \u601d\u8def\uff1a \u6700\u5927\u503c\uff0c\u8d2a\u5fc3\u7684\u62d3\u5c55\u5230\u6ca1\u5230\u8fbe\u7684\u70b9\u3002 \u6700\u5c0f\u503c\uff0c\u8d2a\u5fc3\u7684\u4e0d\u62d3\u5c55\u5230\u5176\u4ed6\u70b9\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 3e5 + 10 ; struct Edge { int to , id , val ; Edge () {} Edge ( int to , int id , int val ) : to ( to ), id ( id ), val ( val ) {} }; int n , m , s , tot ; vector < vector < Edge >> G , und ; int res [ N ], vis [ N ]; void gao1 () { int cnt = 1 ; memset ( vis , 0 , sizeof vis ); memset ( res , 0 , sizeof res ); queue < int > q ; q . push ( s ); vis [ s ] = 1 ; while ( ! q . empty ()) { int u = q . front (); q . pop (); for ( auto it : G [ u ]) { int v = it . to ; if ( ! vis [ v ]) { ++ cnt ; vis [ v ] = true ; q . push ( v ); } } for ( auto it : und [ u ]) { int v = it . to , id = it . id , val = it . val ; if ( ! vis [ v ] && ! res [ id ]) { res [ id ] = val ; ++ cnt ; vis [ v ] = true ; q . push ( v ); } } } printf ( \"%d \\n \" , cnt ); for ( int i = 1 ; i <= tot ; ++ i ) { if ( res [ i ] == 1 ) putchar ( '+' ); else putchar ( '-' ); } puts ( \"\" ); } void gao2 () { int cnt = 1 ; memset ( vis , 0 , sizeof vis ); memset ( res , 0 , sizeof res ); queue < int > q ; q . push ( s ); vis [ s ] = 1 ; while ( ! q . empty ()) { int u = q . front (); q . pop (); for ( auto it : G [ u ]) { int v = it . to ; if ( ! vis [ v ]) { ++ cnt ; vis [ v ] = true ; q . push ( v ); } } for ( auto it : und [ u ]) { int v = it . to , id = it . id , val = it . val ; if ( ! res [ id ]) { res [ id ] = - val ; } } } printf ( \"%d \\n \" , cnt ); for ( int i = 1 ; i <= tot ; ++ i ) { if ( res [ i ] == 1 ) putchar ( '+' ); else putchar ( '-' ); } puts ( \"\" ); } int main () { scanf ( \"%d %d %d\" , & n , & m , & s ); G . clear (); G . resize ( n + 1 ); und . clear (); und . resize ( n + 1 ); for ( int i = 1 , op , u , v ; i <= m ; ++ i ) { scanf ( \"%d %d %d\" , & op , & u , & v ); if ( op == 1 ) { G [ u ]. push_back ( Edge ( v , 1 , 1 )); } else { und [ u ]. push_back ( Edge ( v , ++ tot , 1 )); und [ v ]. push_back ( Edge ( u , tot , -1 )); } } gao1 (); gao2 (); return 0 ; } H. Palindromic Cu Solved By Dup4. 2:01(+1) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32 S S \uff0c\u53ef\u4ee5\u5c06\u5176\u4e2d\u7684\u5b57\u7b26\u91cd\u65b0\u6392\u5217\uff0c\u95ee\u80fd\u591f\u5206\u6210\u82e5\u5e72\u4e2a\u7b49\u957f\u7684\u56de\u6587\u4e32\uff0c\u6c42\u5206\u5f97\u7684\u6700\u5c0f\u6570\u91cf\u548c\u65b9\u6848\u3002 \u601d\u8def\uff1a \u8003\u8651\u4e32\u7684\u4e2a\u6570 k k \u662f n n \u7684\u56e0\u5b50\uff0c\u7136\u540e\u66b4\u529b\u679a\u4e3e\u3002 \u5982\u4f55\u5224\u65ad\u662f\u5426\u5408\u6cd5\uff1f \u4ee4 a = \\mbox{\u51fa\u73b0\u5947\u6570\u6b21\u5b57\u7b26\u4e2a\u6570}, len = \\frac{n}{k} a = \\mbox{\u51fa\u73b0\u5947\u6570\u6b21\u5b57\u7b26\u4e2a\u6570}, len = \\frac{n}{k} \uff1a \u5982\u679c a = 0 a = 0 \uff0c\u90a3\u4e48\u8f93\u51fa\u539f\u4e32\u3002 \u5426\u5219\u9700\u8981\u6ee1\u8db3 k \\geq a k \\geq a \uff0c (len - 1) (len - 1) \u662f\u5076\u6570\uff0c\u5e76\u4e14 (k - a) (k - a) \u4e5f\u662f\u5076\u6570\u3002 Code #include <bits/stdc++.h> using namespace std ; #define SZ(x) (int(x.size())) #define mkp make_pair const int N = 4e5 + 10 ; int n ; char s [ N ]; int cnt [ 320 ]; void gao ( int k ) { cout << k << \" \\n \" ; vector < string > pre ( k , \"\" ), mid ( k , \"\" ); vector < char > DB ; if (( n / k ) % 2 ) { vector < char > single ; for ( int i = 1 ; i < 255 ; ++ i ) { if ( cnt [ i ] & 1 ) { single . push_back ( char ( i )); -- cnt [ i ]; } } for ( int i = 1 ; i < 255 ; ++ i ) { while ( cnt [ i ] > 0 && SZ ( single ) + 2 <= k ) { cnt [ i ] -= 2 ; single . push_back ( char ( i )); single . push_back ( char ( i )); } } for ( int i = 0 ; i < k ; ++ i ) { mid [ i ] += single . back (); single . pop_back (); } } for ( int i = 1 ; i < 255 ; ++ i ) { assert ( cnt [ i ] % 2 == 0 ); while ( cnt [ i ] >= 2 ) { cnt [ i ] -= 2 ; DB . push_back ( char ( i )); } } for ( int i = 0 ; i < k ; ++ i ) { while ( SZ ( pre [ i ]) * 2 + SZ ( mid [ i ]) + 2 <= n / k ) { pre [ i ] += char ( DB . back ()); DB . pop_back (); } } for ( int i = 0 ; i < k ; ++ i ) { assert ( SZ ( pre [ i ]) + SZ ( mid [ i ]) + SZ ( pre [ i ]) == n / k ); if ( SZ ( pre [ i ])) cout << pre [ i ]; if ( SZ ( mid [ i ])) cout << mid [ i ]; if ( SZ ( pre [ i ])) { reverse ( pre [ i ]. begin (), pre [ i ]. end ()); cout << pre [ i ]; } cout << \" \\n \" [ i == k - 1 ]; } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); memset ( cnt , 0 , sizeof cnt ); cin >> n >> ( s + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { assert ( int ( s [ i ]) <= 255 ); ++ cnt [ int ( s [ i ])]; } int a = 0 ; for ( int i = 1 ; i < 255 ; ++ i ) if ( cnt [ i ] & 1 ) ++ a ; for ( int i = 1 ; i <= n ; ++ i ) if ( n % i == 0 ) { if ( i == n ) { gao ( i ); break ; } if ( a == 0 && ( n / i ) % 2 == 0 ) { gao ( i ); break ; } if ( a > 0 && i >= a && ( i - a ) % 2 == 0 && (( n / i ) - 1 ) % 2 == 0 ) { gao ( i ); break ; } } return 0 ; } I. Photo Processing Solved By Dup4 & Hsueh-. 2:28(+1) \u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u7269\u54c1\uff0c\u7b2c i i \u4e2a\u7269\u54c1\u7684\u6743\u503c\u4e3a a_i a_i \uff0c\u73b0\u5728\u8003\u8651\u5c06\u5b83\u4eec\u5206\u7ec4\uff0c\u6bcf\u7ec4\u7269\u54c1\u4e2a\u6570\u4e0d\u5c11\u4e8e k k \u4e2a\uff0c\u4e00\u7ec4\u7269\u54c1\u7684\u4ee3\u4ef7\u4e3a\u5176\u7269\u54c1\u7684\u6781\u5dee\uff0c\u8003\u8651\u5982\u4f55\u5206\u7ec4\u4f7f\u5f97\u6700\u5927\u6781\u5dee\u6700\u5c0f\u3002 \u8f93\u51fa\u8fd9\u4e2a\u6700\u5c0f\u7684\u6700\u5927\u6781\u5dee\u3002 \u601d\u8def\uff1a \u5148\u4e8c\u5206 x x \uff0c\u8f6c\u4e3a\u5224\u5b9a\u6027\u95ee\u9898\uff0c\u7136\u540e f[i] f[i] \u8868\u793a\u524d i i \u4e2a\u7269\u54c1\u662f\u5426\u80fd\u591f\u88ab\u5206\u6210\u82e5\u5e72\u7ec4\uff0c\u5e76\u4e14\u6bcf\u7ec4\u7684\u6781\u5dee\u5c0f\u4e8e x x \uff0c\u7136\u540e\u8f6c\u79fb\u5373\u53ef\uff0c\u8f6c\u79fb\u90e8\u5206\u76f8\u5f53\u4e8e\u67e5\u8be2\u533a\u95f4\u548c\uff0c\u4ee5\u53ca\u5355\u70b9\u4fee\u6539\uff0c\u4f46\u662f\u6ce8\u610f\u5230\u66f4\u65b0\u7684\u70b9\u548c\u67e5\u8be2\u7684\u533a\u95f4\u70b9\u6709\u5355\u8c03\u6027\uff0c\u76f4\u63a5\u52a8\u6001\u5904\u7406\u524d\u7f00\u548c\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 3e5 + 10 ; int n , K , a [ N ], f [ N ], S [ N ]; int ok ( int x ) { // dbg(x); memset ( f , 0 , sizeof f ); S [ 0 ] = 0 ; int l = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { while ( a [ i ] - a [ l ] > x ) ++ l ; int r = i - K + 1 ; // dbg(i, l, r); if (( l <= r && ( l - 1 <= 0 || S [ r - 1 ] - S [ l - 2 ] > 0 ))) f [ i ] = 1 ; S [ i ] = S [ i - 1 ] + f [ i ]; } return f [ n ]; } int main () { scanf ( \"%d%d\" , & n , & K ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); sort ( a + 1 , a + 1 + n ); int l = 0 , r = a [ n ] - a [ 1 ], res = r ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( ok ( mid )) { r = mid - 1 ; res = mid ; } else { l = mid + 1 ; } } printf ( \"%d \\n \" , res ); return 0 ; } J. Renovation Solved By Dup4. 4:47(+1) \u9898\u610f\uff1a \u6709 n n \u4e2a\u6708\u4efd\uff0c\u6709 m m \u4e2a\u57ce\u5e02\u8981\u62c6\uff0c\u6bcf\u4e2a\u57ce\u5e02\u6709\u4e24\u4e2a\u5c5e\u6027 b_i, p_i b_i, p_i \uff0c\u6bcf\u4e2a\u6708\u4efd\u4f1a\u83b7\u5f97 a_i a_i \u5143\u94b1\uff0c\u4e00\u4e2a\u57ce\u5e02\u80fd\u5728\u7b2c i i \u4e2a\u6708\u4efd\u88ab\u62c6\u9664\u5f53\u4e14\u4ec5\u5f53 b_i \\geq a_i b_i \\geq a_i \uff0c\u5e76\u4e14\uff1a p_i \\geq \\sum\\limits_{i = 1}^n - \\sum [j \\in \\mbox{\u5df2\u7ecf\u88ab\u62c6\u9664\u57ce\u5e02}] \\cdot p_j p_i \\geq \\sum\\limits_{i = 1}^n - \\sum [j \\in \\mbox{\u5df2\u7ecf\u88ab\u62c6\u9664\u57ce\u5e02}] \\cdot p_j \u6c42\u6700\u591a\u80fd\u62c6\u51e0\u5ea7\u57ce\u5e02\u3002 \u601d\u8def\uff1a \u4f7f\u52b2\u513f\u8d2a\u5fc3\u3002 \u4e00\u5ea7\u57ce\u5e02\u5982\u679c\u5b83\u8981\u88ab\u62c6\uff0c\u90a3\u4e48\u62c6\u7684\u8d8a\u665a\uff0c\u7b54\u6848\u80af\u5b9a\u4e0d\u4f1a\u66f4\u5dee\u3002 \u90a3\u4e48\u9884\u5904\u7406\u51fa\u6bcf\u5ea7\u57ce\u5e02\u6700\u665a\u4ec0\u4e48\u65f6\u5019\u88ab\u62c6\u3002 \u7136\u540e\u5c06\u57ce\u5e02\u6309 p_i p_i \u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u4e00\u4e00\u51b3\u7b56\uff0c\u5047\u8bbe\u5f53\u524d\u8fd9\u5ea7\u57ce\u5e02\u80fd\u591f\u88ab\u62c6\uff0c\u90a3\u4e48\u4e00\u5b9a\u62c6\u3002 \u600e\u4e48\u6837\u80fd\u88ab\u62c6\uff1f \u5047\u8bbe\u8fd9\u5ea7\u57ce\u5e02\u6700\u665a\u88ab\u62c6\u7684\u65f6\u95f4\u4e3a j j \uff0c\u90a3\u4e48\u524d j j \u4e2a\u6708\u4efd\u8fd8\u5269\u4e0b\u7684\u94b1\u8981\u5927\u4e8e\u7b49\u4e8e p_i p_i \uff0c\u7136\u540e\u6211\u4eec\u8003\u8651\u82b1\u54ea\u4e2a\u6708\u4efd\u7684\u94b1\uff0c\u80af\u5b9a\u662f\u5c0f\u4e8e j j \uff0c\u5e76\u4e14\u79bb j j \u8d8a\u8fd1\u7684\u90a3\u4e2a\u6708\u4efd\uff0c\u8fd9\u4e2a\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e00\u4e0b\uff0c\u7136\u540e\u66b4\u529b\u53bb\u6263\u94b1\uff0c\u4e00\u4e2a\u6bcf\u4e2a\u6708\u4efd\u53ea\u4f1a\u88ab\u6263\u5149\u4e00\u6b21\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; using pII = pair < int , int > ; #define fi first #define se second #define SZ(x) (int(x.size())) #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 1e5 + 10 ; int n , m , a [ N ]; struct E { int b , p , id ; bool operator < ( const E & other ) const { if ( p != other . p ) return p < other . p ; return b < other . b ; } } e [ N ]; struct SEG { struct node { ll val ; int pos ; node () { val = 0 , pos = -1 ; } node operator + ( const node & other ) const { node res = node (); res . val = val + other . val ; res . pos = max ( pos , other . pos ); return res ; } } t [ N << 2 ]; void build ( int id , int l , int r ) { t [ id ] = node (); if ( l == r ) { t [ id ]. val = a [ l ]; if ( t [ id ]. val == 0 ) t [ id ]. pos = -1 ; else t [ id ]. pos = l ; // dbg(id, l, r, t[id].pos, t[id].val); return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); t [ id ] = t [ id << 1 ] + t [ id << 1 | 1 ]; } void update ( int id , int l , int r , int pos , int v ) { if ( l == r ) { t [ id ]. val += v ; if ( t [ id ]. val == 0 ) t [ id ]. pos = -1 ; else t [ id ]. pos = l ; return ; } int mid = ( l + r ) >> 1 ; if ( pos <= mid ) update ( id << 1 , l , mid , pos , v ); else update ( id << 1 | 1 , mid + 1 , r , pos , v ); t [ id ] = t [ id << 1 ] + t [ id << 1 | 1 ]; } ll query ( int id , int l , int r , int ql , int qr ) { if ( l >= ql && r <= qr ) return t [ id ]. val ; int mid = ( l + r ) >> 1 ; ll res = 0 ; if ( ql <= mid ) res += query ( id << 1 , l , mid , ql , qr ); if ( qr > mid ) res += query ( id << 1 | 1 , mid + 1 , r , ql , qr ); return res ; } int queryPos ( int id , int l , int r , int ql , int qr ) { if ( l >= ql && r <= qr ) return t [ id ]. pos ; int mid = ( l + r ) >> 1 ; int pos = -1 ; if ( ql <= mid ) pos = max ( pos , queryPos ( id << 1 , l , mid , ql , qr )); if ( qr > mid ) pos = max ( pos , queryPos ( id << 1 | 1 , mid + 1 , r , ql , qr )); return pos ; } } seg ; int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); for ( int i = 1 ; i <= m ; ++ i ) scanf ( \"%d\" , & e [ i ]. b ); for ( int i = 1 ; i <= m ; ++ i ) scanf ( \"%d\" , & e [ i ]. p ); vector < pII > vec ; for ( int i = 1 ; i <= n ; ++ i ) { while ( SZ ( vec ) && a [ i ] >= vec . back (). fi ) vec . pop_back (); vec . push_back ( pII ( a [ i ], i )); } reverse ( vec . begin (), vec . end ()); for ( int i = 1 ; i <= m ; ++ i ) { auto pos = lower_bound ( vec . begin (), vec . end (), pII ( e [ i ]. b , -1 )); if ( pos == vec . end ()) e [ i ]. id = -1 ; else e [ i ]. id = pos -> se ; // dbg(i, e[i].id); } sort ( e + 1 , e + 1 + m ); int res = 0 ; seg . build ( 1 , 1 , n ); for ( int i = 1 ; i <= m ; ++ i ) if ( e [ i ]. id != -1 ) { int id = e [ i ]. id ; if ( seg . query ( 1 , 1 , n , 1 , id ) >= e [ i ]. p ) { ++ res ; int need = e [ i ]. p ; while ( need > 0 ) { int pos = seg . queryPos ( 1 , 1 , n , 1 , id ); if ( a [ pos ] >= need ) { a [ pos ] -= need ; seg . update ( 1 , 1 , n , pos , - need ); need = 0 ; } else { need -= a [ pos ]; seg . update ( 1 , 1 , n , pos , - a [ pos ]); a [ pos ] = 0 ; } } } } printf ( \"%d \\n \" , res ); return 0 ; } K. Road Widening Solved By Hsueh-. 1:05(+) \u9898\u610f\uff1a n n \u6761\u8def\uff0c\u6bcf\u6761\u8def\u5206\u4e3a\u4e24\u79cd\uff0c\u53ef\u4ee5\u5c06\u7b2c\u4e8c\u79cd\u53d8\u6210\u7b2c\u4e00\u79cd\uff0c\u4f7f\u5f97\u6ee1\u8db3 |s_i-s_{i-1}| \\leq 1 |s_i-s_{i-1}| \\leq 1 \uff0c\u95ee\u505a\u5927\u7684\u53d8\u5316\u957f\u5ea6\u3002 \u601d\u8def\uff1a \u6b63\u7740\u63a8\u4e00\u904d\uff0c\u5012\u7740\u63a8\u4e00\u904d\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 2e5 + 10 ; int n ; ll a [ N ], b [ N ], f [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld %lld\" , a + i , b + i ); f [ i ] = a [ i ] + b [ i ]; } for ( int i = 2 ; i <= n ; ++ i ) { f [ i ] = min ( f [ i - 1 ] + 1 , f [ i ]); } for ( int i = n - 1 ; i >= 1 ; -- i ) { f [ i ] = min ( f [ i + 1 ] + 1 , f [ i ]); } for ( int i = 1 ; i <= n ; ++ i ) { if ( f [ i ] < a [ i ]) { puts ( \"-1\" ); return 0 ; } } ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { res += f [ i ] - a [ i ]; } printf ( \"%lld \\n \" , res ); for ( int i = 1 ; i <= n ; ++ i ) { printf ( \"%lld%c\" , f [ i ], \" \\n \" [ i == n ]); } return 0 ; } L. Berland.Taxi UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a M. Quadcopter Competition Solved By Dup4. 0:17(+) \u9898\u610f\uff1a \u5728\u4e8c\u7ef4\u5e73\u9762\u4e0a\u7ed9\u51fa\u4e00\u4e2a\u8d77\u70b9\u548c\u4e00\u4e2a flag \uff0c\u7136\u540e\u8981\u6c42\u4ece\u8d77\u70b9\u51fa\u53d1\u7ed5\u4e00\u5708\u56de\u6765\uff0c\u4f7f\u5f97 flag \u4e25\u683c\u88ab\u5305\u542b\u4e8e\u8fd9\u4e2a\u5708\u5b50\u3002 \u601d\u8def\uff1a \u5206\u5171\u7ebf\u548c\u4e0d\u5171\u7ebf\u8ba8\u8bba\uff0c\u5176\u5b9e\u4e5f\u53ef\u4ee5\u5f52\u5e76\u6210\u4e00\u6761\u3002 Code #include <bits/stdc++.h> using namespace std ; int x [ 2 ], y [ 2 ]; int dis ( int x , int y , int x1 , int y1 ) { return abs ( x - x1 ) + abs ( y - y1 ); } int main () { scanf ( \"%d%d%d%d\" , x , y , x + 1 , y + 1 ); int Dis = dis ( x [ 0 ], y [ 0 ], x [ 1 ], y [ 1 ]); if ( x [ 0 ] == x [ 1 ] || y [ 0 ] == y [ 1 ]) printf ( \"%d \\n \" , Dis * 2 + 6 ); else printf ( \"%d \\n \" , Dis * 2 + 4 ); return 0 ; }","title":"2017-2018 ACM-ICPC, NEERC, Southern Subregional Contest"},{"location":"trainings/random-trainings/2017-2018-ACM-ICPC-NEERC-Southern-Subregional-Contest/#contest-info","text":"Practice Link Solved A B C D E F G H I J K L M 10/13 - - \u00d8 O O O O O O O O - O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5","title":"Contest Info"},{"location":"trainings/random-trainings/2017-2018-ACM-ICPC-NEERC-Southern-Subregional-Contest/#solutions","text":"","title":"Solutions"},{"location":"trainings/random-trainings/2017-2018-ACM-ICPC-NEERC-Southern-Subregional-Contest/#a-automatic-door","text":"UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"A. Automatic Door"},{"location":"trainings/random-trainings/2017-2018-ACM-ICPC-NEERC-Southern-Subregional-Contest/#b-berland-army","text":"UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"B. Berland Army"},{"location":"trainings/random-trainings/2017-2018-ACM-ICPC-NEERC-Southern-Subregional-Contest/#c-downloading-b","text":"UpSolved by Dup4. \u9898\u610f\uff1a \u8981\u4e0b\u8f7d\u4e00\u4e2a\u8f6f\u4ef6\uff0c\u9ed8\u8ba4\u7684\u4e0b\u8f7d\u901f\u5ea6\u662f t_0 s/byte t_0 s/byte , \u53ef\u4ee5\u82b1\u8d39 p_1 p_1 \u5143\uff0c\u4e70\u52a0\u901f\u5305\uff0c\u80fd\u591f\u4ee5 t_1 s/byte t_1 s/byte \u4e0b\u8f7d a_1 byte a_1 byte \uff0c\u6216\u8005\u82b1\u8d39 p_2 p_2 \u5143\uff0c\u80fd\u591f\u4ee5 t_2 s/byte t_2 s/byte \u4e0b\u8f7d a_2 byte a_2 byte \uff0c\u95ee\u5728 T T \u65f6\u95f4\u5185\u4e0b\u8f7d\u5b8c\uff0c\u6700\u5c11\u9700\u8981\u82b1\u591a\u5c11\u94b1\u3002 \u601d\u8def\uff1a \u679a\u4e3e\u4e00\u4e2a\u52a0\u901f\u5305\u7684\u7528\u91cf\uff0c\u4e8c\u5206\u53e6\u4e00\u4e2a\u52a0\u901f\u5305\u7684\u7528\u91cf\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const ll INF = 1e18 ; ll f , T , t0 , a1 , t1 , p1 , a2 , p2 , t2 ; inline ll ceil ( ll x , ll y ) { return ( x + y - 1 ) / y ; } inline void chmin ( ll & x , ll y ) { if ( x > y ) x = y ; } struct E { ll a , t , p ; bool operator < ( const E & other ) const { if ( t != other . t ) return t < other . t ; return p < other . p ; } } e [ 3 ]; ll calc ( ll remind , ll x , E e ) { ll _remind = remind - e . a * x ; if ( _remind < 0 ) _remind = 0 ; ll useT = e . t * ( remind - _remind ); return useT + _remind * t0 ; } ll gao () { if ( t0 * f <= T ) return 0 ; ll res = INF ; int n = ceil ( f , e [ 1 ]. a ); for ( int i = 0 ; i <= n ; ++ i ) { ll now = e [ 1 ]. p * i ; ll remind = f - e [ 1 ]. a * i ; if ( remind < 0 ) remind = 0 ; ll useT = e [ 1 ]. t * ( f - remind ); if ( useT > T ) break ; ll _T = T - useT ; // dbg(i, remind, f - remind, useT, now, _T); if ( remind * e [ 0 ]. t <= _T ) { chmin ( res , now ); // dbg(i, remind, remind * e[0].t, now); } else { if ( remind * e [ 2 ]. t > _T ) continue ; int _n = ceil ( remind , e [ 2 ]. a ); int l = 0 , r = _n , tar = _n ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; // dbg(mid, calc(remind, mid, e[2])); if ( calc ( remind , mid , e [ 2 ]) <= _T ) { tar = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } // dbg(i, tar, _n); chmin ( res , now + e [ 2 ]. p * tar ); } } if ( res >= INF ) return -1 ; return res ; } int main () { scanf ( \"%lld%lld%lld\" , & f , & T , & t0 ); scanf ( \"%lld%lld%lld\" , & a1 , & t1 , & p1 ); scanf ( \"%lld%lld%lld\" , & a2 , & t2 , & p2 ); e [ 0 ] = { 1 , t0 , 0 }; e [ 1 ] = { a1 , t1 , p1 }; e [ 2 ] = { a2 , t2 , p2 }; sort ( e + 1 , e + 3 ); printf ( \"%lld \\n \" , gao ()); return 0 ; }","title":"C. Downloading B++"},{"location":"trainings/random-trainings/2017-2018-ACM-ICPC-NEERC-Southern-Subregional-Contest/#d-packmen-strike-back","text":"Solved By Hsueh-. 4:29(+) \u9898\u610f\uff1a \u4e00\u4e2a 1 \\cdot n 1 \\cdot n \u7684\u56fe\uff0c\u7ed9\u4e0a\u9762\u7684\u6bcf\u4e2a P \u89c4\u5b9a\u4e00\u4e2a\u65b9\u5411\uff0c\u4e00\u65e6\u65b9\u5411\u786e\u5b9a\u5c31\u4e0d\u80fd\u66f4\u6539\uff0c\u95ee\u5403\u5230\u6700\u5927\u7684 * \u7684\u6700\u4e0b\u65f6\u95f4\u3002 \u601d\u8def\uff1a \u5f53 P \u7684\u4e2a\u6570\u5927\u4e8e\u7b49\u4e8e 2 2 \u7684\u65f6\u5019\u53ef\u4ee5\u5403\u5230\u6240\u6709\u7684 * \u3002 \u90a3\u4e48\u4e8c\u5206\u7b54\u6848\u53bb check\u3002 f_i f_i \u8868\u793a\u524d i i \u4e2a P P \u80fd\u8986\u76d6\u7684\u6700\u5927\u7684 1 - f_i 1 - f_i \u3002 \u5bf9\u4e8e i i \u4e2a P P \u6709\u4e09\u79cd\u8f6c\u79fb\uff0c\u5206\u522b\u662f\u5411\u5de6\uff0c\u5411\u53f3\u6216\u8005 i - 1 i - 1 \u5411\u5de6 i i \u5411\u53f3\uff0c dp dp \u53bb check\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e6 + 10 ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } int n ; char s [ N ]; int a [ N ]; int f [ N ]; int P [ N ], tot ; bool ok ( int l , int r ) { if ( l > r ) return 1 ; else return a [ r ] - a [ l - 1 ] == 0 ; } bool check ( int x ) { memset ( f , 0 , sizeof f ); for ( int i = 1 ; i <= tot ; ++ i ) { // left if ( ok ( f [ i - 1 ] + 1 , P [ i ] - x - 1 )) f [ i ] = max ( f [ i ], P [ i ]); // right if ( ok ( f [ i - 1 ] + 1 , P [ i ] - 1 )) f [ i ] = max ( f [ i ], P [ i ] + x ); // left right if ( i >= 2 && ok ( f [ i - 2 ] + 1 , P [ i ] - x - 1 )) f [ i ] = max ( f [ i ], P [ i - 1 ] + x ); } // dbg(f[1], f[2]); return ok ( f [ tot ] + 1 , n ); } int main () { scanf ( \"%d\" , & n ); scanf ( \"%s\" , s + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { a [ i ] = a [ i - 1 ] + ( s [ i ] == '*' ); } for ( int i = 1 ; i <= n ; ++ i ) { if ( s [ i ] == 'P' ) { P [ ++ tot ] = i ; } } if ( tot == 1 ) { int cnt1 = 0 , cnt2 = 0 , pos = P [ 1 ], l = 0 , r = 0 ; for ( int i = pos - 1 ; i >= 1 ; -- i ) { if ( s [ i ] == '*' ) { ++ cnt1 ; l = i ; } } for ( int i = pos + 1 ; i <= n ; ++ i ) { if ( s [ i ] == '*' ) { ++ cnt2 ; r = i ; } } int res1 = 0 , res2 = 0 ; if ( cnt1 > cnt2 ) { res1 = cnt1 , res2 = pos - l ; } else if ( cnt2 > cnt1 ) { res1 = cnt2 , res2 = r - pos ; } else { res1 = cnt1 , res2 = min ( pos - l , r - pos ); } printf ( \"%d %d \\n \" , res1 , res2 ); } else { printf ( \"%d \" , a [ n ]); // check(4); int l = 0 , r = n , res = -1 ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( check ( mid )) { r = mid - 1 ; res = mid ; } else { l = mid + 1 ; } } printf ( \"%d \\n \" , res ); } return 0 ; }","title":"D. Packmen Strike Back"},{"location":"trainings/random-trainings/2017-2018-ACM-ICPC-NEERC-Southern-Subregional-Contest/#e-field-of-wonders","text":"Solved By Hsueh-. 1:39(+) \u9898\u610f\uff1a \u957f\u5ea6\u4e3a n n \u7684\u5b57\u7b26\u4e32\uff0c\u5176\u4e2d\u6709\u51e0\u4e2a\u4f4d\u7f6e\u662f\u4e0d\u786e\u5b9a\u7684\uff0c\u4f46\u662f\u7b54\u6848\u53ea\u6709 m m \u79cd\uff0c\u95ee\u4e00\u5b9a\u53ef\u4ee5\u6210\u4e3a * \u7684\u5b57\u7b26\u6709\u51e0\u4e2a\u3002 \u601d\u8def\uff1a \u6a21\u62df\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 ; int n , m ; string s ; string str [ N ]; int vis [ N ], cnt [ N ]; int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ), cout . tie ( nullptr ); cin >> n >> s ; for ( auto it : s ) { vis [ it ] ++ ; } cin >> m ; for ( int i = 1 ; i <= m ; ++ i ) { cin >> str [ i ]; } int res = 0 ; for ( int i = 'a' ; i <= 'z' ; ++ i ) { char c = i ; if ( vis [ i ]) continue ; bool F = true ; for ( int j = 1 ; j <= m ; ++ j ) { memset ( cnt , 0 , sizeof cnt ); bool FF = true ; for ( int k = 0 ; k < n ; ++ k ) { if ( s [ k ] == '*' && vis [ str [ j ][ k ]]) { FF = false ; break ; } if ( s [ k ] == '*' ) { cnt [ str [ j ][ k ]] ++ ; } else if ( s [ k ] != str [ j ][ k ]) { FF = false ; break ; } } if ( FF && ! cnt [ c ]) { F = false ; break ; } } res += F ; } cout << res << \" \\n \" ; return 0 ; }","title":"E. Field of Wonders"},{"location":"trainings/random-trainings/2017-2018-ACM-ICPC-NEERC-Southern-Subregional-Contest/#f-lost-in-transliteration","text":"Solved By Hsueh-. 0:32(+) \u9898\u610f\uff1a u \u53ef\u4ee5\u53d8\u6210 oo \u3002 h \u53ef\u4ee5\u53d8\u6210 kh \u3002 \u95ee\u6709\u51e0\u79cd\u5b57\u7b26\u4e32\uff1f \u601d\u8def\uff1a u \u53d8\u6210 oo \u3002 \u9047\u5230 h \u5220\u53bb\u524d\u9762\u7684 k \u3002 \u7136\u540e\u53bb\u91cd\u7edf\u8ba1\u4e2a\u6570\u3002 Code #include <bits/stdc++.h> using namespace std ; int n ; string s ; map < string , int > mp ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ), cout . tie ( nullptr ); cin >> n ; int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { cin >> s ; string t = \"\" ; for ( int j = 0 , len = s . size (); j < len ; ++ j ) { if ( s [ j ] == 'u' ) t += \"oo\" ; else { if ( s [ j ] == 'h' ) { while ( ! t . empty () && t [ t . size () - 1 ] == 'k' ) { t . pop_back (); } } t += s [ j ]; } } if ( ! mp . count ( t )) { mp [ t ] ++ ; ++ res ; } } cout << res << \" \\n \" ; return 0 ; }","title":"F. Lost in Transliteration"},{"location":"trainings/random-trainings/2017-2018-ACM-ICPC-NEERC-Southern-Subregional-Contest/#g-orientation-of-edges","text":"Solved By Hsueh-. 2:38(+) \u9898\u610f\uff1a \u4e00\u5f20\u6df7\u5408\u56fe\uff0c\u6709\u4e00\u4e9b\u6709\u5411\u8fb9\u548c\u65e0\u5411\u8fb9\uff0c\u7ed9\u5b9a\u4e00\u4e2a\u8d77\u70b9\uff0c\u5206\u522b\u7ed9\u65e0\u5411\u8fb9\u5b9a\u5411\u4f7f\u5f97 S \u5230\u8fbe\u7684\u70b9\u6700\u591a\u6700\u5c0f\uff0c\u72ec\u7acb\u56de\u7b54\u6700\u5927\u6700\u5c0f\u503c\u3002 \u601d\u8def\uff1a \u6700\u5927\u503c\uff0c\u8d2a\u5fc3\u7684\u62d3\u5c55\u5230\u6ca1\u5230\u8fbe\u7684\u70b9\u3002 \u6700\u5c0f\u503c\uff0c\u8d2a\u5fc3\u7684\u4e0d\u62d3\u5c55\u5230\u5176\u4ed6\u70b9\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 3e5 + 10 ; struct Edge { int to , id , val ; Edge () {} Edge ( int to , int id , int val ) : to ( to ), id ( id ), val ( val ) {} }; int n , m , s , tot ; vector < vector < Edge >> G , und ; int res [ N ], vis [ N ]; void gao1 () { int cnt = 1 ; memset ( vis , 0 , sizeof vis ); memset ( res , 0 , sizeof res ); queue < int > q ; q . push ( s ); vis [ s ] = 1 ; while ( ! q . empty ()) { int u = q . front (); q . pop (); for ( auto it : G [ u ]) { int v = it . to ; if ( ! vis [ v ]) { ++ cnt ; vis [ v ] = true ; q . push ( v ); } } for ( auto it : und [ u ]) { int v = it . to , id = it . id , val = it . val ; if ( ! vis [ v ] && ! res [ id ]) { res [ id ] = val ; ++ cnt ; vis [ v ] = true ; q . push ( v ); } } } printf ( \"%d \\n \" , cnt ); for ( int i = 1 ; i <= tot ; ++ i ) { if ( res [ i ] == 1 ) putchar ( '+' ); else putchar ( '-' ); } puts ( \"\" ); } void gao2 () { int cnt = 1 ; memset ( vis , 0 , sizeof vis ); memset ( res , 0 , sizeof res ); queue < int > q ; q . push ( s ); vis [ s ] = 1 ; while ( ! q . empty ()) { int u = q . front (); q . pop (); for ( auto it : G [ u ]) { int v = it . to ; if ( ! vis [ v ]) { ++ cnt ; vis [ v ] = true ; q . push ( v ); } } for ( auto it : und [ u ]) { int v = it . to , id = it . id , val = it . val ; if ( ! res [ id ]) { res [ id ] = - val ; } } } printf ( \"%d \\n \" , cnt ); for ( int i = 1 ; i <= tot ; ++ i ) { if ( res [ i ] == 1 ) putchar ( '+' ); else putchar ( '-' ); } puts ( \"\" ); } int main () { scanf ( \"%d %d %d\" , & n , & m , & s ); G . clear (); G . resize ( n + 1 ); und . clear (); und . resize ( n + 1 ); for ( int i = 1 , op , u , v ; i <= m ; ++ i ) { scanf ( \"%d %d %d\" , & op , & u , & v ); if ( op == 1 ) { G [ u ]. push_back ( Edge ( v , 1 , 1 )); } else { und [ u ]. push_back ( Edge ( v , ++ tot , 1 )); und [ v ]. push_back ( Edge ( u , tot , -1 )); } } gao1 (); gao2 (); return 0 ; }","title":"G. Orientation of Edges"},{"location":"trainings/random-trainings/2017-2018-ACM-ICPC-NEERC-Southern-Subregional-Contest/#h-palindromic-cu","text":"Solved By Dup4. 2:01(+1) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32 S S \uff0c\u53ef\u4ee5\u5c06\u5176\u4e2d\u7684\u5b57\u7b26\u91cd\u65b0\u6392\u5217\uff0c\u95ee\u80fd\u591f\u5206\u6210\u82e5\u5e72\u4e2a\u7b49\u957f\u7684\u56de\u6587\u4e32\uff0c\u6c42\u5206\u5f97\u7684\u6700\u5c0f\u6570\u91cf\u548c\u65b9\u6848\u3002 \u601d\u8def\uff1a \u8003\u8651\u4e32\u7684\u4e2a\u6570 k k \u662f n n \u7684\u56e0\u5b50\uff0c\u7136\u540e\u66b4\u529b\u679a\u4e3e\u3002 \u5982\u4f55\u5224\u65ad\u662f\u5426\u5408\u6cd5\uff1f \u4ee4 a = \\mbox{\u51fa\u73b0\u5947\u6570\u6b21\u5b57\u7b26\u4e2a\u6570}, len = \\frac{n}{k} a = \\mbox{\u51fa\u73b0\u5947\u6570\u6b21\u5b57\u7b26\u4e2a\u6570}, len = \\frac{n}{k} \uff1a \u5982\u679c a = 0 a = 0 \uff0c\u90a3\u4e48\u8f93\u51fa\u539f\u4e32\u3002 \u5426\u5219\u9700\u8981\u6ee1\u8db3 k \\geq a k \\geq a \uff0c (len - 1) (len - 1) \u662f\u5076\u6570\uff0c\u5e76\u4e14 (k - a) (k - a) \u4e5f\u662f\u5076\u6570\u3002 Code #include <bits/stdc++.h> using namespace std ; #define SZ(x) (int(x.size())) #define mkp make_pair const int N = 4e5 + 10 ; int n ; char s [ N ]; int cnt [ 320 ]; void gao ( int k ) { cout << k << \" \\n \" ; vector < string > pre ( k , \"\" ), mid ( k , \"\" ); vector < char > DB ; if (( n / k ) % 2 ) { vector < char > single ; for ( int i = 1 ; i < 255 ; ++ i ) { if ( cnt [ i ] & 1 ) { single . push_back ( char ( i )); -- cnt [ i ]; } } for ( int i = 1 ; i < 255 ; ++ i ) { while ( cnt [ i ] > 0 && SZ ( single ) + 2 <= k ) { cnt [ i ] -= 2 ; single . push_back ( char ( i )); single . push_back ( char ( i )); } } for ( int i = 0 ; i < k ; ++ i ) { mid [ i ] += single . back (); single . pop_back (); } } for ( int i = 1 ; i < 255 ; ++ i ) { assert ( cnt [ i ] % 2 == 0 ); while ( cnt [ i ] >= 2 ) { cnt [ i ] -= 2 ; DB . push_back ( char ( i )); } } for ( int i = 0 ; i < k ; ++ i ) { while ( SZ ( pre [ i ]) * 2 + SZ ( mid [ i ]) + 2 <= n / k ) { pre [ i ] += char ( DB . back ()); DB . pop_back (); } } for ( int i = 0 ; i < k ; ++ i ) { assert ( SZ ( pre [ i ]) + SZ ( mid [ i ]) + SZ ( pre [ i ]) == n / k ); if ( SZ ( pre [ i ])) cout << pre [ i ]; if ( SZ ( mid [ i ])) cout << mid [ i ]; if ( SZ ( pre [ i ])) { reverse ( pre [ i ]. begin (), pre [ i ]. end ()); cout << pre [ i ]; } cout << \" \\n \" [ i == k - 1 ]; } } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ); cout . tie ( nullptr ); memset ( cnt , 0 , sizeof cnt ); cin >> n >> ( s + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { assert ( int ( s [ i ]) <= 255 ); ++ cnt [ int ( s [ i ])]; } int a = 0 ; for ( int i = 1 ; i < 255 ; ++ i ) if ( cnt [ i ] & 1 ) ++ a ; for ( int i = 1 ; i <= n ; ++ i ) if ( n % i == 0 ) { if ( i == n ) { gao ( i ); break ; } if ( a == 0 && ( n / i ) % 2 == 0 ) { gao ( i ); break ; } if ( a > 0 && i >= a && ( i - a ) % 2 == 0 && (( n / i ) - 1 ) % 2 == 0 ) { gao ( i ); break ; } } return 0 ; }","title":"H. Palindromic Cu"},{"location":"trainings/random-trainings/2017-2018-ACM-ICPC-NEERC-Southern-Subregional-Contest/#i-photo-processing","text":"Solved By Dup4 & Hsueh-. 2:28(+1) \u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u7269\u54c1\uff0c\u7b2c i i \u4e2a\u7269\u54c1\u7684\u6743\u503c\u4e3a a_i a_i \uff0c\u73b0\u5728\u8003\u8651\u5c06\u5b83\u4eec\u5206\u7ec4\uff0c\u6bcf\u7ec4\u7269\u54c1\u4e2a\u6570\u4e0d\u5c11\u4e8e k k \u4e2a\uff0c\u4e00\u7ec4\u7269\u54c1\u7684\u4ee3\u4ef7\u4e3a\u5176\u7269\u54c1\u7684\u6781\u5dee\uff0c\u8003\u8651\u5982\u4f55\u5206\u7ec4\u4f7f\u5f97\u6700\u5927\u6781\u5dee\u6700\u5c0f\u3002 \u8f93\u51fa\u8fd9\u4e2a\u6700\u5c0f\u7684\u6700\u5927\u6781\u5dee\u3002 \u601d\u8def\uff1a \u5148\u4e8c\u5206 x x \uff0c\u8f6c\u4e3a\u5224\u5b9a\u6027\u95ee\u9898\uff0c\u7136\u540e f[i] f[i] \u8868\u793a\u524d i i \u4e2a\u7269\u54c1\u662f\u5426\u80fd\u591f\u88ab\u5206\u6210\u82e5\u5e72\u7ec4\uff0c\u5e76\u4e14\u6bcf\u7ec4\u7684\u6781\u5dee\u5c0f\u4e8e x x \uff0c\u7136\u540e\u8f6c\u79fb\u5373\u53ef\uff0c\u8f6c\u79fb\u90e8\u5206\u76f8\u5f53\u4e8e\u67e5\u8be2\u533a\u95f4\u548c\uff0c\u4ee5\u53ca\u5355\u70b9\u4fee\u6539\uff0c\u4f46\u662f\u6ce8\u610f\u5230\u66f4\u65b0\u7684\u70b9\u548c\u67e5\u8be2\u7684\u533a\u95f4\u70b9\u6709\u5355\u8c03\u6027\uff0c\u76f4\u63a5\u52a8\u6001\u5904\u7406\u524d\u7f00\u548c\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 3e5 + 10 ; int n , K , a [ N ], f [ N ], S [ N ]; int ok ( int x ) { // dbg(x); memset ( f , 0 , sizeof f ); S [ 0 ] = 0 ; int l = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { while ( a [ i ] - a [ l ] > x ) ++ l ; int r = i - K + 1 ; // dbg(i, l, r); if (( l <= r && ( l - 1 <= 0 || S [ r - 1 ] - S [ l - 2 ] > 0 ))) f [ i ] = 1 ; S [ i ] = S [ i - 1 ] + f [ i ]; } return f [ n ]; } int main () { scanf ( \"%d%d\" , & n , & K ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); sort ( a + 1 , a + 1 + n ); int l = 0 , r = a [ n ] - a [ 1 ], res = r ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( ok ( mid )) { r = mid - 1 ; res = mid ; } else { l = mid + 1 ; } } printf ( \"%d \\n \" , res ); return 0 ; }","title":"I. Photo Processing"},{"location":"trainings/random-trainings/2017-2018-ACM-ICPC-NEERC-Southern-Subregional-Contest/#j-renovation","text":"Solved By Dup4. 4:47(+1) \u9898\u610f\uff1a \u6709 n n \u4e2a\u6708\u4efd\uff0c\u6709 m m \u4e2a\u57ce\u5e02\u8981\u62c6\uff0c\u6bcf\u4e2a\u57ce\u5e02\u6709\u4e24\u4e2a\u5c5e\u6027 b_i, p_i b_i, p_i \uff0c\u6bcf\u4e2a\u6708\u4efd\u4f1a\u83b7\u5f97 a_i a_i \u5143\u94b1\uff0c\u4e00\u4e2a\u57ce\u5e02\u80fd\u5728\u7b2c i i \u4e2a\u6708\u4efd\u88ab\u62c6\u9664\u5f53\u4e14\u4ec5\u5f53 b_i \\geq a_i b_i \\geq a_i \uff0c\u5e76\u4e14\uff1a p_i \\geq \\sum\\limits_{i = 1}^n - \\sum [j \\in \\mbox{\u5df2\u7ecf\u88ab\u62c6\u9664\u57ce\u5e02}] \\cdot p_j p_i \\geq \\sum\\limits_{i = 1}^n - \\sum [j \\in \\mbox{\u5df2\u7ecf\u88ab\u62c6\u9664\u57ce\u5e02}] \\cdot p_j \u6c42\u6700\u591a\u80fd\u62c6\u51e0\u5ea7\u57ce\u5e02\u3002 \u601d\u8def\uff1a \u4f7f\u52b2\u513f\u8d2a\u5fc3\u3002 \u4e00\u5ea7\u57ce\u5e02\u5982\u679c\u5b83\u8981\u88ab\u62c6\uff0c\u90a3\u4e48\u62c6\u7684\u8d8a\u665a\uff0c\u7b54\u6848\u80af\u5b9a\u4e0d\u4f1a\u66f4\u5dee\u3002 \u90a3\u4e48\u9884\u5904\u7406\u51fa\u6bcf\u5ea7\u57ce\u5e02\u6700\u665a\u4ec0\u4e48\u65f6\u5019\u88ab\u62c6\u3002 \u7136\u540e\u5c06\u57ce\u5e02\u6309 p_i p_i \u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u4e00\u4e00\u51b3\u7b56\uff0c\u5047\u8bbe\u5f53\u524d\u8fd9\u5ea7\u57ce\u5e02\u80fd\u591f\u88ab\u62c6\uff0c\u90a3\u4e48\u4e00\u5b9a\u62c6\u3002 \u600e\u4e48\u6837\u80fd\u88ab\u62c6\uff1f \u5047\u8bbe\u8fd9\u5ea7\u57ce\u5e02\u6700\u665a\u88ab\u62c6\u7684\u65f6\u95f4\u4e3a j j \uff0c\u90a3\u4e48\u524d j j \u4e2a\u6708\u4efd\u8fd8\u5269\u4e0b\u7684\u94b1\u8981\u5927\u4e8e\u7b49\u4e8e p_i p_i \uff0c\u7136\u540e\u6211\u4eec\u8003\u8651\u82b1\u54ea\u4e2a\u6708\u4efd\u7684\u94b1\uff0c\u80af\u5b9a\u662f\u5c0f\u4e8e j j \uff0c\u5e76\u4e14\u79bb j j \u8d8a\u8fd1\u7684\u90a3\u4e2a\u6708\u4efd\uff0c\u8fd9\u4e2a\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e00\u4e0b\uff0c\u7136\u540e\u66b4\u529b\u53bb\u6263\u94b1\uff0c\u4e00\u4e2a\u6bcf\u4e2a\u6708\u4efd\u53ea\u4f1a\u88ab\u6263\u5149\u4e00\u6b21\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n) O(n \\log n) \u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; using pII = pair < int , int > ; #define fi first #define se second #define SZ(x) (int(x.size())) #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 1e5 + 10 ; int n , m , a [ N ]; struct E { int b , p , id ; bool operator < ( const E & other ) const { if ( p != other . p ) return p < other . p ; return b < other . b ; } } e [ N ]; struct SEG { struct node { ll val ; int pos ; node () { val = 0 , pos = -1 ; } node operator + ( const node & other ) const { node res = node (); res . val = val + other . val ; res . pos = max ( pos , other . pos ); return res ; } } t [ N << 2 ]; void build ( int id , int l , int r ) { t [ id ] = node (); if ( l == r ) { t [ id ]. val = a [ l ]; if ( t [ id ]. val == 0 ) t [ id ]. pos = -1 ; else t [ id ]. pos = l ; // dbg(id, l, r, t[id].pos, t[id].val); return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); t [ id ] = t [ id << 1 ] + t [ id << 1 | 1 ]; } void update ( int id , int l , int r , int pos , int v ) { if ( l == r ) { t [ id ]. val += v ; if ( t [ id ]. val == 0 ) t [ id ]. pos = -1 ; else t [ id ]. pos = l ; return ; } int mid = ( l + r ) >> 1 ; if ( pos <= mid ) update ( id << 1 , l , mid , pos , v ); else update ( id << 1 | 1 , mid + 1 , r , pos , v ); t [ id ] = t [ id << 1 ] + t [ id << 1 | 1 ]; } ll query ( int id , int l , int r , int ql , int qr ) { if ( l >= ql && r <= qr ) return t [ id ]. val ; int mid = ( l + r ) >> 1 ; ll res = 0 ; if ( ql <= mid ) res += query ( id << 1 , l , mid , ql , qr ); if ( qr > mid ) res += query ( id << 1 | 1 , mid + 1 , r , ql , qr ); return res ; } int queryPos ( int id , int l , int r , int ql , int qr ) { if ( l >= ql && r <= qr ) return t [ id ]. pos ; int mid = ( l + r ) >> 1 ; int pos = -1 ; if ( ql <= mid ) pos = max ( pos , queryPos ( id << 1 , l , mid , ql , qr )); if ( qr > mid ) pos = max ( pos , queryPos ( id << 1 | 1 , mid + 1 , r , ql , qr )); return pos ; } } seg ; int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); for ( int i = 1 ; i <= m ; ++ i ) scanf ( \"%d\" , & e [ i ]. b ); for ( int i = 1 ; i <= m ; ++ i ) scanf ( \"%d\" , & e [ i ]. p ); vector < pII > vec ; for ( int i = 1 ; i <= n ; ++ i ) { while ( SZ ( vec ) && a [ i ] >= vec . back (). fi ) vec . pop_back (); vec . push_back ( pII ( a [ i ], i )); } reverse ( vec . begin (), vec . end ()); for ( int i = 1 ; i <= m ; ++ i ) { auto pos = lower_bound ( vec . begin (), vec . end (), pII ( e [ i ]. b , -1 )); if ( pos == vec . end ()) e [ i ]. id = -1 ; else e [ i ]. id = pos -> se ; // dbg(i, e[i].id); } sort ( e + 1 , e + 1 + m ); int res = 0 ; seg . build ( 1 , 1 , n ); for ( int i = 1 ; i <= m ; ++ i ) if ( e [ i ]. id != -1 ) { int id = e [ i ]. id ; if ( seg . query ( 1 , 1 , n , 1 , id ) >= e [ i ]. p ) { ++ res ; int need = e [ i ]. p ; while ( need > 0 ) { int pos = seg . queryPos ( 1 , 1 , n , 1 , id ); if ( a [ pos ] >= need ) { a [ pos ] -= need ; seg . update ( 1 , 1 , n , pos , - need ); need = 0 ; } else { need -= a [ pos ]; seg . update ( 1 , 1 , n , pos , - a [ pos ]); a [ pos ] = 0 ; } } } } printf ( \"%d \\n \" , res ); return 0 ; }","title":"J. Renovation"},{"location":"trainings/random-trainings/2017-2018-ACM-ICPC-NEERC-Southern-Subregional-Contest/#k-road-widening","text":"Solved By Hsueh-. 1:05(+) \u9898\u610f\uff1a n n \u6761\u8def\uff0c\u6bcf\u6761\u8def\u5206\u4e3a\u4e24\u79cd\uff0c\u53ef\u4ee5\u5c06\u7b2c\u4e8c\u79cd\u53d8\u6210\u7b2c\u4e00\u79cd\uff0c\u4f7f\u5f97\u6ee1\u8db3 |s_i-s_{i-1}| \\leq 1 |s_i-s_{i-1}| \\leq 1 \uff0c\u95ee\u505a\u5927\u7684\u53d8\u5316\u957f\u5ea6\u3002 \u601d\u8def\uff1a \u6b63\u7740\u63a8\u4e00\u904d\uff0c\u5012\u7740\u63a8\u4e00\u904d\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 2e5 + 10 ; int n ; ll a [ N ], b [ N ], f [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld %lld\" , a + i , b + i ); f [ i ] = a [ i ] + b [ i ]; } for ( int i = 2 ; i <= n ; ++ i ) { f [ i ] = min ( f [ i - 1 ] + 1 , f [ i ]); } for ( int i = n - 1 ; i >= 1 ; -- i ) { f [ i ] = min ( f [ i + 1 ] + 1 , f [ i ]); } for ( int i = 1 ; i <= n ; ++ i ) { if ( f [ i ] < a [ i ]) { puts ( \"-1\" ); return 0 ; } } ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { res += f [ i ] - a [ i ]; } printf ( \"%lld \\n \" , res ); for ( int i = 1 ; i <= n ; ++ i ) { printf ( \"%lld%c\" , f [ i ], \" \\n \" [ i == n ]); } return 0 ; }","title":"K. Road Widening"},{"location":"trainings/random-trainings/2017-2018-ACM-ICPC-NEERC-Southern-Subregional-Contest/#l-berlandtaxi","text":"UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"L. Berland.Taxi"},{"location":"trainings/random-trainings/2017-2018-ACM-ICPC-NEERC-Southern-Subregional-Contest/#m-quadcopter-competition","text":"Solved By Dup4. 0:17(+) \u9898\u610f\uff1a \u5728\u4e8c\u7ef4\u5e73\u9762\u4e0a\u7ed9\u51fa\u4e00\u4e2a\u8d77\u70b9\u548c\u4e00\u4e2a flag \uff0c\u7136\u540e\u8981\u6c42\u4ece\u8d77\u70b9\u51fa\u53d1\u7ed5\u4e00\u5708\u56de\u6765\uff0c\u4f7f\u5f97 flag \u4e25\u683c\u88ab\u5305\u542b\u4e8e\u8fd9\u4e2a\u5708\u5b50\u3002 \u601d\u8def\uff1a \u5206\u5171\u7ebf\u548c\u4e0d\u5171\u7ebf\u8ba8\u8bba\uff0c\u5176\u5b9e\u4e5f\u53ef\u4ee5\u5f52\u5e76\u6210\u4e00\u6761\u3002 Code #include <bits/stdc++.h> using namespace std ; int x [ 2 ], y [ 2 ]; int dis ( int x , int y , int x1 , int y1 ) { return abs ( x - x1 ) + abs ( y - y1 ); } int main () { scanf ( \"%d%d%d%d\" , x , y , x + 1 , y + 1 ); int Dis = dis ( x [ 0 ], y [ 0 ], x [ 1 ], y [ 1 ]); if ( x [ 0 ] == x [ 1 ] || y [ 0 ] == y [ 1 ]) printf ( \"%d \\n \" , Dis * 2 + 6 ); else printf ( \"%d \\n \" , Dis * 2 + 4 ); return 0 ; }","title":"M. Quadcopter Competition"},{"location":"trainings/random-trainings/2018-ACM-ICPC-Syrian-Collegiate-Programming-Contest/","text":"2018 ACM-ICPC, Syrian Collegiate Programming Contest Contents Contest Info Solutions A. Hello SCPC 2018! B. Binary Hamming C. Portals D. Carnival Slots E. 2Nodes F. Pretests G. Is Topo Logical? H. Bugged System I. Rise of the Robots J. Clarifications K. Tourists' Tour L. Sad Meals Contest Info Practice Link Solved A B C D E F G H I J K L 10/12 O O O O - O O O O O O - O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5 Solutions A. Hello SCPC 2018! Solved By Hsueh-. 0:04(+) \u9898\u610f\uff1a \u5224\u65ad\u5341\u4e8c\u4e2a\u6570\u5b57\u662f\u5426\u6ee1\u8db3\uff1b \u524d4\u4e2a\u9012\u589e \u540e\u97628\u4e2a\u4e25\u683c\u5927\u4e8e\u524d4\u4e2a \u601d\u8def\uff1a \u6a21\u62df\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int a [ N ]; int main () { freopen ( \"hello.in\" , \"r\" , stdin ); int T ; scanf ( \"%d\" , & T ); while ( T -- ) { for ( int i = 0 ; i < 12 ; ++ i ) { scanf ( \"%d\" , a + i ); } sort ( a + 4 , a + 12 ); bool F = true ; for ( int i = 1 ; i < 12 ; ++ i ) { if ( a [ i ] < a [ i - 1 ]) { F = false ; break ; } } puts ( F ? \"yes\" : \"no\" ); } return 0 ; } B. Binary Hamming Solved By Dup4. 0:10(+) \u9898\u610f\uff1a \u7ed9\u51fa\u4e24\u4e2a 01 \u4e32\uff0c\u53ef\u4ee5\u6253\u4e71\u5b57\u6bcd\u6392\u5217\u987a\u5e8f\uff0c\u4f7f\u5f97\u4e24\u4e2a 01 \u4e32\u7684\u6c49\u660e\u7801\u8ddd\u79bb\u6700\u5927\u3002 \u601d\u8def\uff1a \u5c3d\u53ef\u80fd\u8d2a\u5fc3\u653e 01 \u4f7f\u5f97\u540c\u4e00\u4f4d\u4e0d\u540c\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); freopen ( \"hamming.in\" , \"r\" , stdin ); int _T ; cin >> _T ; string s , t ; while ( _T -- ) { int n ; cin >> n ; cin >> s >> t ; int a [ 2 ] = { 0 , 0 }, b [ 2 ] = { 0 , 0 }; for ( auto & c : s ) ++ a [ c - '0' ]; for ( auto & c : t ) ++ b [ c - '0' ]; cout << min ( a [ 0 ], b [ 1 ]) + min ( a [ 1 ], b [ 0 ]) << \" \\n \" ; } return 0 ; } C. Portals Solved By Dup4. 1:00(+) \u9898\u610f\uff1a \u6709\u4e00\u4e2a 1 \\cdot n 1 \\cdot n \u7684\u8ff7\u5bab\uff0c . \u8868\u793a\u7a7a\u5730\uff0c # \u8868\u793a\u969c\u788d\u7269\uff0c o \u8868\u793a\u4f20\u9001\u95e8(\u5373\u542b\u6709 o \u7684\u683c\u5b50\u90fd\u53ef\u4ee5\u4e92\u76f8\u5230\u8fbe), s \u8868\u793a\u8d77\u70b9\uff0c e \u8868\u793a\u7ec8\u70b9\u3002 \u73b0\u5728\u53ef\u4ee5\u5c06 # \u8fb9\u6210 . \uff0c\u95ee\u6700\u5c11\u7684\u6b21\u6570\u4f7f\u5f97 s \u4e0d\u80fd\u5230\u8fbe e \u3002 \u601d\u8def\uff1a \u9700\u8981\u6700\u591a\u7684\u6b21\u6570\u662f 2 2 \uff0c\u5e76\u4e14\u53ef\u4ee5\u53d1\u73b0\u80af\u5b9a\u662f\u5c06\u79bb s \u6216\u8005 e \u6700\u8fd1\u7684 . \u66f4\u6539\u6389\uff0c\u5206\u7c7b\u8ba8\u8bba\u4e00\u4e0b\u7136\u540e\u5224\u8fde\u901a\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } #define SZ(x) (int(x.size())) const int N = 2e5 + 10 ; int n , st , ed ; char s [ N ]; struct UFS { int fa [ N ], rk [ N ]; void init ( int n ) { memset ( fa , 0 , sizeof ( fa [ 0 ]) * ( n + 5 )); memset ( rk , 0 , sizeof ( rk [ 0 ]) * ( n + 5 )); } int find ( int x ) { return fa [ x ] == 0 ? x : fa [ x ] = find ( fa [ x ]); } bool merge ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( fx != fy ) { if ( rk [ fx ] > rk [ fy ]) swap ( fx , fy ); fa [ fx ] = fy ; if ( rk [ fx ] == rk [ fy ]) ++ rk [ fy ]; return true ; } return false ; } bool same ( int x , int y ) { return find ( x ) == find ( y ); } } ufs ; bool ok () { ufs . init ( n ); vector < int > vec ; for ( int i = 1 ; i <= n ; ++ i ) { if ( s [ i ] == 'o' ) vec . push_back ( i ); } for ( int i = 2 ; i <= n ; ++ i ) if ( s [ i ] == '.' || s [ i ] == 'o' || s [ i ] == 's' || s [ i ] == 'e' ) { if ( s [ i - 1 ] == '.' || s [ i - 1 ] == 'o' || s [ i - 1 ] == 's' || s [ i - 1 ] == 'e' ) ufs . merge ( i - 1 , i ); } for ( int i = 1 ; i < SZ ( vec ); ++ i ) ufs . merge ( vec [ i - 1 ], vec [ i ]); return ! ufs . same ( st , ed ); } int gao1 ( int st ) { for ( int i = st - 1 ; i >= 1 ; -- i ) { if ( s [ i ] == '.' ) { s [ i ] = '#' ; if ( ok ()) return 1 ; s [ i ] = '.' ; break ; } } for ( int i = st + 1 ; i <= n ; ++ i ) { if ( s [ i ] == '.' ) { s [ i ] = '#' ; if ( ok ()) return 1 ; s [ i ] = '.' ; break ; } } return 0 ; } int gao2 ( int st ) { int i , j ; for ( i = st - 1 ; i >= 1 ; -- i ) { if ( s [ i ] == '.' ) { break ; } } for ( j = st + 1 ; j <= n ; ++ j ) { if ( s [ j ] == '.' ) { break ; } } // dbg(st, i, j); if ( i >= 1 && j <= n ) { s [ i ] = '#' ; s [ j ] = '#' ; if ( ok ()) return 1 ; s [ i ] = '.' ; s [ j ] = '.' ; } return 0 ; } int gao () { if ( ok ()) return 0 ; if ( gao1 ( st )) return 1 ; if ( gao1 ( ed )) return 1 ; if ( gao2 ( st )) return 2 ; if ( gao2 ( ed )) return 2 ; return -1 ; } int main () { freopen ( \"portals.in\" , \"r\" , stdin ); int _T ; cin >> _T ; while ( _T -- ) { scanf ( \"%d%s\" , & n , s + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { if ( s [ i ] == 's' ) st = i ; else if ( s [ i ] == 'e' ) ed = i ; } printf ( \"%d \\n \" , gao ()); } return 0 ; } D. Carnival Slots Solved By Heush-. 1:44(+) \u9898\u610f\uff1a \u4e00\u5f20 n \\cdot m n \\cdot m \u7684\u7684\u56fe\uff0c\u4f60\u53ef\u4ee5\u4efb\u610f\u4fee\u6539 \\ , / \u4f7f\u5f97\u6bcf\u5217\u6389\u4e0b\u6765\u7684\u6743\u503c\u6570\u91cf\u548c\u6700\u5927\u3002 \u601d\u8def\uff1a - \u8bb0\u5fc6\u5316\u641c\u7d22\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 5e2 + 10 ; int n , m ; char G [ N ][ N ]; int f [ N ][ N ], num [ N ], val [ N ]; int gao ( int x , int y ) { if ( x == n + 1 ) { return val [ y ]; } if ( f [ x ][ y ] != -1 ) return f [ x ][ y ]; int & res = f [ x ][ y ]; res = gao ( x + 1 , y ); if ( G [ x ][ y ] != '.' && y - 1 >= 1 ) res = max ( res , gao ( x + 1 , y - 1 )); if ( G [ x ][ y ] != '.' && y + 1 <= m ) res = max ( res , gao ( x + 1 , y + 1 )); return res ; } int main () { freopen ( \"balls.in\" , \"r\" , stdin ); int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d %d\" , & n , & m ); for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { f [ i ][ j ] = -1 ; } } for ( int i = 1 ; i <= m ; ++ i ) { scanf ( \"%d\" , num + i ); } for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%s\" , G [ i ] + 1 ); } for ( int i = 1 ; i <= m ; ++ i ) { scanf ( \"%d\" , val + i ); } ll res = 0 ; for ( int i = 1 ; i <= m ; ++ i ) { res += 1l l * gao ( 1 , i ) * num [ i ]; } printf ( \"%lld \\n \" , res ); } return 0 ; } E. 2Nodes UnSolved. \u9898\u610f\uff1a \u6709\u4e00\u68f5\u6811\uff0c\u6bcf\u4e2a\u70b9\u6709\u989c\u8272(\u767d\u3001\u7ea2\u3001\u84dd)\uff0c\u6bcf\u79d2\u949f\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u767d\u8272\u8282\u70b9\uff0c\u5982\u679c\u5b83\u76f8\u90bb\u7684\u8282\u70b9\u4e2d\u5b58\u5728\u975e\u767d\u8272\u7684\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u8282\u70b9\u67d3\u8272\u6210\u90a3\u4e2a\u8282\u70b9\u7684\u989c\u8272\uff0c\u5982\u679c\u6709\u591a\u4e2a\uff0c\u90a3\u4e48\u9009\u53d6\u6807\u53f7\u6700\u5c0f\u7684\u90a3\u4e2a\u70b9\u7684\u989c\u8272\u4f5c\u4e3a\u5f53\u524d\u70b9\u7684\u67d3\u8272\u3002 \u73b0\u5728\u6700\u591a\u80fd\u5c06 2 2 \u4e2a\u70b9\u53d8\u6210\u767d\u8272\uff0c\u95ee\u5982\u4f55\u53d8\u4f7f\u5f97\u6700\u7ec8\u7ea2\u8272\u70b9\u6700\u591a\uff1f \u601d\u8def\uff1a F. Pretests Solved By Dup4. 2:45(+2) \u9898\u610f\uff1a \u5bf9\u4e8e\u4e00\u4e2a\u9898\u76ee\uff0c\u6709 t t \u7ec4\u6570\u636e\uff0c\u6709 n n \u4efd\u5f85\u8bc4\u6d4b\u7684\u7a0b\u5e8f\uff0c\u6bcf\u4efd\u7a0b\u5e8f\u5982\u679c\u6302\u5728\u4e86\u7b2c k k \u4e2a\u70b9\uff0c\u90a3\u4e48\u5b83\u9700\u8981\u7684\u6d4b\u8bd5\u65f6\u95f4\u4e3a k k \uff0c\u5982\u679c\u901a\u8fc7\u6240\u6709\u6570\u636e\uff0c\u90a3\u4e48\u6d4b\u8bd5\u7684\u65f6\u95f4\u4e3a t t \uff0c\u73b0\u5728\u7ed9\u51fa\u6bcf\u4efd\u7a0b\u5e8f\u5bf9\u4e8e\u6bcf\u4e2a\u70b9\u7684\u901a\u8fc7\u60c5\u51b5\uff0c\u53ef\u4ee5\u91cd\u65b0\u5b89\u6392\u6d4b\u8bd5\u70b9\u7684\u987a\u5e8f\uff0c\u4f7f\u5f97\u603b\u7684\u6d4b\u8bd5\u65f6\u95f4\u6700\u5c0f\u3002 \u8f93\u51fa\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u65b9\u6848\u3002 \u601d\u8def\uff1a f[S] f[S] \u8868\u793a\u524d i i \u4e2a\u6d4b\u8bd5\u70b9\u7684\u96c6\u5408\u4e3a S S \uff0c\u9700\u8981\u7684\u6700\u5c11\u6d4b\u8bd5\u65f6\u95f4\uff0c\u7136\u540e\u679a\u4e3e\u4e00\u4e2a j j \u8fdb\u884c\u8f6c\u79fb\uff0c j j \u8981\u5305\u542b\u5728 S S \u4e2d\u3002 \u7136\u540e\u53d1\u73b0\u989d\u5916\u7684\u8d21\u732e\u662f\u6d4b\u8bd5\u7a0b\u5e8f\u7684\u901a\u8fc7\u6d4b\u8bd5\u70b9\u7684\u96c6\u5408\u662f S S \u7684\u8d85\u96c6\uff0c\u7136\u540e\u8fd9\u90e8\u5206\u8d21\u732e\u53ef\u4ee5\u7528\u9ad8\u7ef4\u524d\u7f00\u548c\u9884\u5904\u7406\u3002 \u603b\u65f6\u95f4\u590d\u6742\u5ea6 O(n \\cdot 2^n) O(n \\cdot 2^n) \uff0c\u5bf9\u4e8e\u5b57\u5178\u5e8f\uff0c\u76f4\u63a5\u8bb0\u5f55\u4e00\u4e2a string \u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 2e6 + 10 , INF = 0x3f3f3f3f ; int t , n , cnt [ N ], f [ N ]; char s [ 110 ]; vector < int > g [ N ]; inline void chmin ( int & x , int y ) { if ( x > y ) x = y ; } int main () { freopen ( \"tests.in\" , \"r\" , stdin ); int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d%d\" , & t , & n ); for ( int i = 0 ; i < ( 1 << t ); ++ i ) cnt [ i ] = 0 , f [ i ] = INF , g [ i ]. clear (); f [ 0 ] = 0 ; int more = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%s\" , s ); int res = 0 ; for ( int j = 0 ; j < t ; ++ j ) { if ( s [ j ] == '1' ) { res |= 1 << j ; } } if ( res == ( 1 << t ) - 1 ) more += t - 1 ; else ++ cnt [ res ]; } for ( int j = 0 ; j < t ; ++ j ) { for ( int i = 0 ; i < 1 << t ; ++ i ) { if ( ! ( i >> j & 1 )) cnt [ i ] += cnt [ i ^ ( 1 << j )]; } } for ( int i = 1 ; i < 1 << t ; ++ i ) { for ( int j = 0 ; j < t ; ++ j ) { if (( i >> j ) & 1 ) { int nx = i ^ ( 1 << j ); g [ nx ]. push_back ( j ); if ( f [ nx ] < f [ i ] || ( f [ nx ] == f [ i ] && g [ nx ] < g [ i ])) { f [ i ] = f [ nx ]; g [ i ] = g [ nx ]; } g [ nx ]. pop_back (); } } f [ i ] += cnt [ i ]; } printf ( \"%d \\n \" , f [( 1 << t ) - 1 ] + n + more ); for ( int i = 0 ; i < t ; ++ i ) printf ( \"%d%c\" , g [( 1 << t ) - 1 ][ i ] + 1 , \" \\n \" [ i == t - 1 ]); } return 0 ; } G. Is Topo Logical? Solved By Dup4. 3:22(+1) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a n n \u548c\u4e24\u4e2a\u5165\u5ea6\u6570\u7ec4 a, b a, b \uff0c\u8981\u6c42\u6784\u9020\u4e00\u4e2a n n \u4e2a\u70b9\u7684\u6709\u5411\u56fe\uff0c\u6ee1\u8db3\u521a\u5f00\u59cb\u65f6\u7b2c i i \u4e2a\u70b9\u7684\u5165\u5ea6\u4e3a a_i a_i \uff0c\u8dd1\u5b8c\u62d3\u6251\u6392\u5e8f\u540e\u7b2c i i \u4e2a\u70b9\u7684\u5ea6\u6570\u4e3a b_i b_i \u3002 \u601d\u8def\uff1a \u57fa\u4e8e b b \u6570\u7ec4\u4e2d\u662f\u5426\u4e3a 0 0 \u5c06\u70b9\u5206\u6210\u4e24\u90e8\u5206\uff0c\u4e3a 0 0 \u7684\u90a3\u90e8\u5206\u7ec4\u6210\u4e00\u6761\u94fe\uff0c\u4e0d\u4e3a 0 0 \u7684\u90a3\u90e8\u5206\u7ec4\u6210\u4e00\u4e2a\u73af\u3002 \u7136\u540e\u6839\u636e\u5165\u5ea6\u8fde\u8fb9\u5373\u53ef\uff0c\u6839\u636e a_i, b_i a_i, b_i \u8ba8\u8bba\u4e00\u4e0b\u5165\u5ea6\u7684\u6765\u6e90\u3002 Code #include <bits/stdc++.h> using namespace std ; #define SZ(x) (int(x.size())) #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 2e5 + 10 ; int n , a [ N ], b [ N ], need [ N ]; vector < vector < int >> G ; bool gao () { G . clear (); G . resize ( n + 1 ); vector < int > A , B ; for ( int i = 1 ; i <= n ; ++ i ) { need [ i ] = a [ i ] - b [ i ]; if ( ! b [ i ]) A . push_back ( i ); else B . push_back ( i ); } if ( SZ ( B ) == 1 ) return 0 ; for ( int i = 0 ; i < SZ ( B ); ++ i ) { if ( ! i ) G [ B . back ()]. push_back ( B [ i ]); else G [ B [ i - 1 ]]. push_back ( B [ i ]); -- b [ B [ i ]]; } for ( int i = 0 ; i < SZ ( B ); ++ i ) { for ( int j = 0 ; b [ B [ i ]] && j < SZ ( B ); ++ j ) if ( i != j ) { if ( i == 0 && j == SZ ( B ) - 1 ) continue ; if ( i != 0 && j == i - 1 ) continue ; -- b [ B [ i ]]; G [ B [ j ]]. push_back ( B [ i ]); } if ( b [ B [ i ]]) return 0 ; for ( int j = 0 ; need [ B [ i ]] && j < SZ ( A ); ++ j ) { -- need [ B [ i ]]; G [ A [ j ]]. push_back ( B [ i ]); } if ( need [ B [ i ]]) return 0 ; } sort ( A . begin (), A . end (), [ & ]( int x , int y ) { return a [ x ] < a [ y ]; }); for ( int i = 0 ; i < SZ ( A ); ++ i ) { if ( a [ A [ i ]] > i ) return 0 ; for ( int j = 0 ; a [ A [ i ]] && j < i ; ++ j ) { -- a [ A [ i ]]; G [ A [ j ]]. push_back ( A [ i ]); } } int sze = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sze += SZ ( G [ i ]); printf ( \"%d \\n \" , sze ); for ( int i = 1 ; i <= n ; ++ i ) { for ( auto & it : G [ i ]) { printf ( \"%d %d \\n \" , i , it ); } } return 1 ; } int main () { freopen ( \"topo.in\" , \"r\" , stdin ); int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , b + i ); if ( ! gao ()) printf ( \"-1 \\n \" ); } return 0 ; } H. Bugged System Solved By Hsueh-. 1:29(+4) \u9898\u610f\uff1a \u4e00\u4e2a\u5730\u94c1\u7ad9\uff0c\u6709 n n \u4e2a\u7ad9\uff0c\u4f46\u662f\u5b58\u5728\u4e00\u4e2a bug\uff0c\u5982\u679c\u4e00\u4e2a\u4eba\u4ece a a \u7ad9\u8fdb\u7ad9 b b \u7ad9\u51fa\u6765\u5219\u4e0d\u7528\u94b1\uff0c\u4eba\u4eec\u53ef\u4ee5\u4ea4\u6362\u5730\u94c1\u5361\u3002 \u95ee n n \u4e2a\u4eba\u5206\u522b\u4ece s_i s_i \u8fdb\u7ad9\uff0c d_i d_i \u51fa\u7ad9\uff0c\u662f\u5426\u5b58\u5728\u4e00\u4e2a\u65b9\u6848\u4f7f\u5f97\u5927\u5bb6\u4e0d\u82b1\u94b1\u3002 \u5982\u679c\u5b58\u5728\u5219\u8f93\u51fa\u6700\u5c0f\u884c\u52a8\u8ddd\u79bb\u548c\u3002 \u601d\u8def\uff1a \u5f88\u663e\u7136\u5982\u679c\u5b58\u5728\u5219\u662f\u4e00\u4e2a\u73af\uff0c\u90a3\u4e48\u6bcf\u4e2a\u7ad9\u7684\u8fdb\u7ad9\u6570\u91cf\u7b49\u4e8e\u51fa\u7ad9\u6570\u91cf\uff0c\u8ddd\u79bb\u5c31\u662f\u6bcf\u4e2a\u4eba\u7684\u884c\u52a8\u8ddd\u79bb Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 2e6 + 10 ; int n , m ; ll a [ N ]; int vis [ N ]; int main () { freopen ( \"bugged.in\" , \"r\" , stdin ); int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d %d\" , & n , & m ); for ( int i = 1 ; i <= n ; ++ i ) { vis [ i ] = 0 ; } for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld\" , a + i ); } ll res = 0 ; for ( int i = 1 , s , d ; i <= m ; ++ i ) { scanf ( \"%d %d\" , & s , & d ); vis [ s ] ++ ; vis [ d ] -- ; res += abs ( a [ s ] - a [ d ]); } for ( int i = 1 ; i <= n ; ++ i ) { if ( vis [ i ]) { res = -1 ; break ; } } printf ( \"%lld \\n \" , res ); } return 0 ; } I. Rise of the Robots Solved By Hsueh-. 2:34(+3) \u9898\u610f\uff1a \u4e00\u4e2a\u534a\u5f84\u4e3a R R \u7684\u56fe\uff0c\u4e00\u4e2a\u534a\u5f84\u4e3a r r \u673a\u5668\u4eba\uff0c\u7ecf\u8fc7 n n \u6b21\u64cd\u4f5c\uff0c\u6bcf\u6b21\u64cd\u4f5c\u90fd\u4ece (x,y) (x,y) \u5230 (x+dx_i, y+dy_i) (x+dx_i, y+dy_i) \uff0c\u95ee\u662f\u5426\u5b58\u5728\u4e00\u4e2a\u8d77\u70b9\uff0c\u4f7f\u5f97\u673a\u5668\u4eba\u6ca1\u6709\u51fa\u6574\u4e2a\u5706\u3002 \u601d\u8def\uff1a \u731c\u6d4b\u53ef\u4ee5\u6c42\u51fa\u4e00\u4e2a\u5706\u8868\u793a\u673a\u5668\u4eba\u7684\u8def\u5f84\uff0c\u90a3\u4e48\u6c42\u4e00\u4e2a\u6700\u5c0f\u8986\u76d6\u5706\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using db = double ; const int N = 1e5 + 10 ; const db eps = 1e-10 ; mt19937 rnd ( time ( 0 )); int sgn ( db x ) { if ( fabs ( x ) < eps ) return 0 ; return x > 0 ? 1 : -1 ; } struct Point { db x , y ; Point ( db x = 0 , db y = 0 ) : x ( x ), y ( y ) {} Point operator + ( const Point & b ) const { return Point ( x + b . x , y + b . y ); } Point operator - ( const Point & b ) const { return Point ( x - b . x , y - b . y ); } Point operator * ( const db & b ) const { return Point ( x * b , y * b ); } Point operator / ( const db & b ) const { return Point ( x / b , y / b ); } db operator ^ ( const Point & b ) const { return x * b . y - y * b . x ; } db operator * ( const Point & b ) const { return x * b . x + y * b . y ; } db len () { return hypot ( x , y ); } db len2 () { return x * x + y * y ; } db dis ( Point b ) { return hypot ( x - b . x , y - b . y ); } Point rotright () { return Point ( y , - x ); } } p [ N ]; struct Circle { Point p ; db r ; Circle () {} Circle ( Point p , db r ) : p ( p ), r ( r ) {} Circle ( db x , db y , db r ) : p ( Point ( x , y )), r ( r ) {} Circle ( Point a , Point b , Point c , int opt = 0 ) { if ( opt == 0 ) { Point p0 = ( a + b ) / 2 ; Point v0 = ( b - a ). rotright (); Point p1 = ( a + c ) / 2 ; Point v1 = ( c - a ). rotright (); db t = (( p1 - p0 ) ^ v1 ) / ( v0 ^ v1 ); p = p0 + v0 * t ; r = p . dis ( a ); } } }; int n , R , r ; Point solve () { shuffle ( p + 1 , p + 1 + n , rnd ); Circle cir ( 0 , 0 , 0 ); for ( int i = 1 ; i <= n ; ++ i ) { if ( sgn (( cir . p - p [ i ]). len2 () - cir . r ) > 0 ) { cir . p = p [ i ]; cir . r = 0 ; for ( int j = 1 ; j < i ; ++ j ) { if ( sgn (( cir . p - p [ j ]). len2 () - cir . r ) > 0 ) { cir . p = ( p [ i ] + p [ j ]) / 2 ; cir . r = ( p [ j ] - cir . p ). len2 (); for ( int k = 1 ; k < j ; ++ k ) { if ( sgn (( cir . p - p [ k ]). len2 () - cir . r ) > 0 ) { cir = Circle ( p [ i ], p [ j ], p [ k ]); cir . r = ( p [ k ] - cir . p ). len2 (); } } } } } } cir . p . x *= -1 ; cir . p . y *= -1 ; if ( sgn ( cir . p . x ) == 0 ) cir . p . x = 0 ; if ( sgn ( cir . p . y ) == 0 ) cir . p . y = 0 ; return cir . p ; } int main () { freopen ( \"robots.in\" , \"r\" , stdin ); int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d %d %d\" , & n , & R , & r ); db x = 0 , y = 0 ; for ( int i = 1 , dx , dy ; i <= n ; ++ i ) { scanf ( \"%d %d\" , & dx , & dy ); x += dx , y += dy ; p [ i ] = Point ( x , y ); } ++ n ; p [ n ] = Point ( 0 , 0 ); Point res = solve (); printf ( \"%.9f %.9f \\n \" , res . x , res . y ); } return 0 ; } J. Clarifications Solved By Dup4 & Hsueh-. 4:19(+) \u9898\u610f\uff1a \u5728\u4e00\u573a\u65f6\u957f\u4e3a m m \u7684\u6bd4\u8d5b\u4e2d\uff0c\u6709 n n \u4e2a\u95ee\u9898\uff0c\u6709 k k \u4e2a\u79cd\u7c7b\u7684\u95ee\u9898\uff0c\u6709\u4e24\u4e2a\u56de\u7b54\u7684\u4eba A \u548c B \uff0c A \u80fd\u5728\u4efb\u4f55\u65f6\u523b\u56de\u7b54\u4efb\u4f55\u95ee\u9898\uff0c B \u53ea\u80fd\u56de\u7b54\u5728\u8fd9\u4e4b\u524d A \u56de\u7b54\u8fc7\u7684\u95ee\u9898\u4e2d\u76f8\u540c\u79cd\u7c7b\u7684\u95ee\u9898\u3002 \u6bcf\u4e2a\u95ee\u9898\u6709\u4e24\u4e2a\u53c2\u6570 t_i, p_i t_i, p_i \uff0c\u5206\u522b\u8868\u793a\u8be2\u95ee\u7684\u65f6\u523b\u548c\u79cd\u7c7b\u3002\u73b0\u5728\u95ee\u57fa\u4e8e\u4e0a\u8ff0\u9650\u5236\u6761\u4ef6\uff0c\u56de\u7b54\u5b8c\u6240\u6709\u95ee\u9898\u6700\u5c11\u9700\u8981\u591a\u5c11\u65f6\u95f4\u3002 \u601d\u8def\uff1a \u8003\u8651\u5df2\u7ecf\u88ab A \u56de\u7b54\u8fc7\u7684\u79cd\u7c7b\u662f\u6ca1\u6709\u533a\u522b\u7684\uff0c\u5e76\u4e14\u4f18\u5148\u7ea7\u6700\u4f4e\u3002 \u7136\u540e\u8003\u8651\u8fd8\u6ca1\u6709\u56de\u7b54\u8fc7\u7684\uff0c\u4f46\u662f\u5df2\u7ecf\u5728\u961f\u5217\u4e2d\u4e86\uff0c\u6211\u4eec\u6839\u636e\u4ed6\u4eec\u5728\u961f\u5217\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u8fdb\u884c\u4f18\u5148\u7ea7\u6392\u5e8f\uff0c\u5bf9\u4e8e A \u6765\u8bf4\uff0c\u6bcf\u6b21\u53d6\u4f18\u5148\u7ea7\u6700\u9ad8\u7684\u51fa\u6765\u56de\u7b54\u6389\uff0c\u7136\u540e\u91ca\u653e\u51fa\u4e00\u4e9b\u95ee\u9898\uff0c\u53ef\u4ee5\u8ba9 B \u4e5f\u4e00\u8d77\u5e2e\u5fd9\u56de\u7b54\u3002 \u4f46\u662f\u5982\u679c\u6709\u4e24\u4e2a\u95ee\u9898\u7684\u51fa\u73b0\u6b21\u6570\u76f8\u540c\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u4e0b\u4e00\u79d2\u4f1a\u51fa\u73b0\u7684\u95ee\u9898\u4e5f\u7eb3\u5165\u8003\u91cf\u4e4b\u4e2d\u3002 \u7ef4\u62a4\u4f18\u5148\u7ea7\u7684\u64cd\u4f5c\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002 Code #include <bits/stdc++.h> using namespace std ; using pII = pair < int , int > ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 1e5 + 10 , INF = 1e9 ; int n , m , K , sta [ N ]; struct SEG { struct node { int val , pos ; node ( int val = 0 , int pos = 0 ) : val ( val ), pos ( pos ) {} node operator + ( const node & other ) const { node res = node (); if ( val > other . val ) { res = ( * this ); } else { res = other ; } return res ; } } t [ N << 2 ]; void build ( int id , int l , int r ) { t [ id ] = node (); if ( l == r ) { t [ id ]. pos = l ; return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); } void update ( int id , int l , int r , int pos , int v ) { // dbg(id, l, r, pos, v); if ( l == r ) { t [ id ]. val += v ; return ; } int mid = ( l + r ) >> 1 ; if ( pos <= mid ) update ( id << 1 , l , mid , pos , v ); else update ( id << 1 | 1 , mid + 1 , r , pos , v ); t [ id ] = t [ id << 1 ] + t [ id << 1 | 1 ]; } } seg ; int main () { freopen ( \"clar.in\" , \"r\" , stdin ); int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d%d%d\" , & m , & n , & K ); vector < vector < int >> vec ( m + 5 ); for ( int i = 1 , t , p ; i <= n ; ++ i ) { scanf ( \"%d%d\" , & t , & p ); vec [ t ]. push_back ( p ); } // 0 \u6ca1\u51fa\u73b0\u8fc7 1 \u5728seg\u4e2d 2 \u88ab\u56de\u7b54\u8fc7\u4e00\u6b21 for ( int i = 1 ; i <= K ; ++ i ) sta [ i ] = 0 ; seg . build ( 1 , 1 , K ); int cnt = 0 ; int t = 1 ; int remind = n ; while ( remind ) { if ( t <= m ) for ( auto & it : vec [ t ]) { if ( sta [ it ] == 0 ) { ++ sta [ it ]; seg . update ( 1 , 1 , K , it , 1 ); } else if ( sta [ it ] == 1 ) { seg . update ( 1 , 1 , K , it , 1 ); } else if ( sta [ it ] == 2 ) { ++ cnt ; } } if ( t + 1 <= m ) for ( auto & it : vec [ t + 1 ]) { if ( sta [ it ] == 1 ) { seg . update ( 1 , 1 , K , it , 1 ); } } if ( cnt ) -- cnt , -- remind ; int val = seg . t [ 1 ]. val , pos = seg . t [ 1 ]. pos ; if ( sta [ pos ] != 1 ) pos = 0 ; if ( pos ) { cnt += val - 1 ; sta [ pos ] = 2 ; -- remind ; seg . update ( 1 , 1 , K , pos , - INF ); } else if ( cnt ) { -- cnt ; -- remind ; } if ( t + 1 <= m ) for ( auto & it : vec [ t + 1 ]) { if ( it == pos ) { -- cnt ; } else if ( sta [ it ] == 1 ) { seg . update ( 1 , 1 , K , it , -1 ); } } ++ t ; } printf ( \"%d \\n \" , t - 1 ); } return 0 ; } K. Tourists' Tour Solved By Dup4 & Hsueh-. 1:11(+1) \u9898\u610f\uff1a \u6709 n n \u5ea7\u5c71\u5cf0\uff0c\u6bcf\u5ea7\u5c71\u5cf0\u7684\u9ad8\u5ea6\u4e3a h_i h_i \uff0c\u5bf9\u4e8e\u7b2c i i \u5ea7\u5c71\u5cf0\uff0c\u5982\u679c\u5b83\u5de6\u8fb9\u6709\u6bd4\u4ed6\u9ad8\u7684\u5c71\u5cf0\uff0c\u90a3\u4e48\u5b83\u4f1a\u627e\u4e00\u5ea7\u79bb\u5b83\u6700\u8fd1\u7684\u5e76\u4e14\u6bd4\u5b83\u9ad8\u7684\u7136\u540e\u5728\u8fd9\u4e4b\u95f4\u5efa\u7acb\u4e00\u5ea7\u6865(\u5373\u8fde\u4e00\u6761\u8fb9)\u3002 \u5bf9\u4e8e\u53f3\u8fb9\u4ea6\u662f\u5982\u6b64\uff0c\u73b0\u5728\u8981\u5bf9\u8fd9\u4e9b\u8fb9\u8fdb\u884c\u67d3\u8272\uff0c\u4f7f\u5f97\u4efb\u610f\u4e24\u6761\u76f8\u90bb\u7684\u8fb9\u4e0d\u540c\u8272\uff0c\u6ce8\u610f\u8fb9\u662f\u65e0\u5411\u8fb9\u3002 \u601d\u8def\uff1a \u5f3a\u5236\u8ba9\u9ad8\u7684\u5c71\u5cf0\u8fde\u5411\u4f4e\u7684\u5c71\u5cf0\uff0c\u53d8\u6210 DAG\uff0c\u7136\u540e\u66b4\u529b\u67d3\u8272\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e6 + 10 ; int n ; int a [ N ]; vector < vector < int > > G ; int col [ N ], in [ N ], vis [ N ][ 6 ]; int gao () { int rt = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( in [ i ] == 0 ) { rt = i ; break ; } } int Max = 0 ; queue < int > q ; q . push ( rt ); while ( ! q . empty ()) { int u = q . front (); q . pop (); for ( int i = 1 ; i <= 5 ; ++ i ) { if ( vis [ u ][ i ]) continue ; col [ u ] = i ; Max = max ( Max , i ); for ( auto v : G [ u ]) { vis [ v ][ i ] = 1 ; in [ v ] -- ; if ( in [ v ] == 0 ) { q . push ( v ); } } break ; } } return Max ; } int main () { freopen ( \"tour.in\" , \"r\" , stdin ); int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { col [ i ] = 0 ; in [ i ] = 0 ; for ( int j = 0 ; j < 6 ; ++ j ) { vis [ i ][ j ] = 0 ; } } for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); } G . clear (); G . resize ( n + 1 ); stack < int > stk ; for ( int i = 1 ; i <= n ; ++ i ) { while ( ! stk . empty () && a [ stk . top ()] <= a [ i ]) stk . pop (); if ( ! stk . empty ()) { int u = stk . top (); int v = i ; G [ u ]. push_back ( v ); in [ v ] ++ ; } stk . push ( i ); } while ( ! stk . empty ()) stk . pop (); for ( int i = n ; i >= 1 ; -- i ) { while ( ! stk . empty () && a [ stk . top ()] <= a [ i ]) stk . pop (); if ( ! stk . empty ()) { int u = stk . top (); int v = i ; G [ u ]. push_back ( v ); in [ v ] ++ ; } stk . push ( i ); } int Max = gao (); printf ( \"%d \\n \" , Max ); for ( int i = 1 ; i <= n ; ++ i ) { printf ( \"%d%c\" , col [ i ], \" \\n \" [ i == n ]); } } return 0 ; } L. Sad Meals UnSolved. \u9898\u610f\uff1a \u6709\u4e00\u4e2a\u53a8\u5e08\u505a\u83dc\uff0c\u5047\u8bbe\u4ed6\u5728\u7b2c i i \u5929\u4e4b\u524d\u5df2\u7ecf\u4f1a\u4e86 x x \u9053\u83dc\u4e86\u3002 \u90a3\u4e48\u4ed6\u5728\u7b2c i i \u53ef\u80fd\u5b66\u65b0\u83dc\uff0c\u5373 a_i = x + 1 a_i = x + 1 \u3002 \u4e5f\u53ef\u80fd\u987a\u7740\u524d\u4e00\u5929\u7684\u987a\u5e8f\u505a\u83dc\uff0c\u5373 a_i = a_{i - 1} + 1 a_i = a_{i - 1} + 1 \u3002 \u5982\u679c\u524d\u4e00\u5929\u505a\u5b8c\u4e86\u5df2\u7ecf\u5b66\u4f1a\u7684\u83dc\uff0c\u90a3\u4e48\u5c31\u91cd\u65b0\u5f00\u59cb\u8f6e\u56de\uff0c\u5373\u505a\u7b2c\u4e00\u9053\u83dc a_i = 1 a_i = 1 \u3002 \u73b0\u5728\u7ed9\u51fa a a \u6570\u7ec4\uff0c\u4f46\u662f\u6316\u7a7a\u4e86\u4e00\u4e9b\u4f4d\u7f6e\uff0c\u8981\u6c42\u8865\u5145\u4e0a\u8fd9\u4e9b\u4f4d\u7f6e\uff0c\u4f7f\u5f97\u6ee1\u8db3\u4e0a\u8ff0\u9650\u5236\u6761\u4ef6\u3002 \u601d\u8def\uff1a","title":"2018 ACM-ICPC, Syrian Collegiate Programming Contest"},{"location":"trainings/random-trainings/2018-ACM-ICPC-Syrian-Collegiate-Programming-Contest/#contest-info","text":"Practice Link Solved A B C D E F G H I J K L 10/12 O O O O - O O O O O O - O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5","title":"Contest Info"},{"location":"trainings/random-trainings/2018-ACM-ICPC-Syrian-Collegiate-Programming-Contest/#solutions","text":"","title":"Solutions"},{"location":"trainings/random-trainings/2018-ACM-ICPC-Syrian-Collegiate-Programming-Contest/#a-hello-scpc-2018","text":"Solved By Hsueh-. 0:04(+) \u9898\u610f\uff1a \u5224\u65ad\u5341\u4e8c\u4e2a\u6570\u5b57\u662f\u5426\u6ee1\u8db3\uff1b \u524d4\u4e2a\u9012\u589e \u540e\u97628\u4e2a\u4e25\u683c\u5927\u4e8e\u524d4\u4e2a \u601d\u8def\uff1a \u6a21\u62df\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int a [ N ]; int main () { freopen ( \"hello.in\" , \"r\" , stdin ); int T ; scanf ( \"%d\" , & T ); while ( T -- ) { for ( int i = 0 ; i < 12 ; ++ i ) { scanf ( \"%d\" , a + i ); } sort ( a + 4 , a + 12 ); bool F = true ; for ( int i = 1 ; i < 12 ; ++ i ) { if ( a [ i ] < a [ i - 1 ]) { F = false ; break ; } } puts ( F ? \"yes\" : \"no\" ); } return 0 ; }","title":"A. Hello SCPC 2018!"},{"location":"trainings/random-trainings/2018-ACM-ICPC-Syrian-Collegiate-Programming-Contest/#b-binary-hamming","text":"Solved By Dup4. 0:10(+) \u9898\u610f\uff1a \u7ed9\u51fa\u4e24\u4e2a 01 \u4e32\uff0c\u53ef\u4ee5\u6253\u4e71\u5b57\u6bcd\u6392\u5217\u987a\u5e8f\uff0c\u4f7f\u5f97\u4e24\u4e2a 01 \u4e32\u7684\u6c49\u660e\u7801\u8ddd\u79bb\u6700\u5927\u3002 \u601d\u8def\uff1a \u5c3d\u53ef\u80fd\u8d2a\u5fc3\u653e 01 \u4f7f\u5f97\u540c\u4e00\u4f4d\u4e0d\u540c\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; int main () { ios :: sync_with_stdio ( false ); cin . tie ( 0 ); cout . tie ( 0 ); freopen ( \"hamming.in\" , \"r\" , stdin ); int _T ; cin >> _T ; string s , t ; while ( _T -- ) { int n ; cin >> n ; cin >> s >> t ; int a [ 2 ] = { 0 , 0 }, b [ 2 ] = { 0 , 0 }; for ( auto & c : s ) ++ a [ c - '0' ]; for ( auto & c : t ) ++ b [ c - '0' ]; cout << min ( a [ 0 ], b [ 1 ]) + min ( a [ 1 ], b [ 0 ]) << \" \\n \" ; } return 0 ; }","title":"B. Binary Hamming"},{"location":"trainings/random-trainings/2018-ACM-ICPC-Syrian-Collegiate-Programming-Contest/#c-portals","text":"Solved By Dup4. 1:00(+) \u9898\u610f\uff1a \u6709\u4e00\u4e2a 1 \\cdot n 1 \\cdot n \u7684\u8ff7\u5bab\uff0c . \u8868\u793a\u7a7a\u5730\uff0c # \u8868\u793a\u969c\u788d\u7269\uff0c o \u8868\u793a\u4f20\u9001\u95e8(\u5373\u542b\u6709 o \u7684\u683c\u5b50\u90fd\u53ef\u4ee5\u4e92\u76f8\u5230\u8fbe), s \u8868\u793a\u8d77\u70b9\uff0c e \u8868\u793a\u7ec8\u70b9\u3002 \u73b0\u5728\u53ef\u4ee5\u5c06 # \u8fb9\u6210 . \uff0c\u95ee\u6700\u5c11\u7684\u6b21\u6570\u4f7f\u5f97 s \u4e0d\u80fd\u5230\u8fbe e \u3002 \u601d\u8def\uff1a \u9700\u8981\u6700\u591a\u7684\u6b21\u6570\u662f 2 2 \uff0c\u5e76\u4e14\u53ef\u4ee5\u53d1\u73b0\u80af\u5b9a\u662f\u5c06\u79bb s \u6216\u8005 e \u6700\u8fd1\u7684 . \u66f4\u6539\u6389\uff0c\u5206\u7c7b\u8ba8\u8bba\u4e00\u4e0b\u7136\u540e\u5224\u8fde\u901a\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } #define SZ(x) (int(x.size())) const int N = 2e5 + 10 ; int n , st , ed ; char s [ N ]; struct UFS { int fa [ N ], rk [ N ]; void init ( int n ) { memset ( fa , 0 , sizeof ( fa [ 0 ]) * ( n + 5 )); memset ( rk , 0 , sizeof ( rk [ 0 ]) * ( n + 5 )); } int find ( int x ) { return fa [ x ] == 0 ? x : fa [ x ] = find ( fa [ x ]); } bool merge ( int x , int y ) { int fx = find ( x ), fy = find ( y ); if ( fx != fy ) { if ( rk [ fx ] > rk [ fy ]) swap ( fx , fy ); fa [ fx ] = fy ; if ( rk [ fx ] == rk [ fy ]) ++ rk [ fy ]; return true ; } return false ; } bool same ( int x , int y ) { return find ( x ) == find ( y ); } } ufs ; bool ok () { ufs . init ( n ); vector < int > vec ; for ( int i = 1 ; i <= n ; ++ i ) { if ( s [ i ] == 'o' ) vec . push_back ( i ); } for ( int i = 2 ; i <= n ; ++ i ) if ( s [ i ] == '.' || s [ i ] == 'o' || s [ i ] == 's' || s [ i ] == 'e' ) { if ( s [ i - 1 ] == '.' || s [ i - 1 ] == 'o' || s [ i - 1 ] == 's' || s [ i - 1 ] == 'e' ) ufs . merge ( i - 1 , i ); } for ( int i = 1 ; i < SZ ( vec ); ++ i ) ufs . merge ( vec [ i - 1 ], vec [ i ]); return ! ufs . same ( st , ed ); } int gao1 ( int st ) { for ( int i = st - 1 ; i >= 1 ; -- i ) { if ( s [ i ] == '.' ) { s [ i ] = '#' ; if ( ok ()) return 1 ; s [ i ] = '.' ; break ; } } for ( int i = st + 1 ; i <= n ; ++ i ) { if ( s [ i ] == '.' ) { s [ i ] = '#' ; if ( ok ()) return 1 ; s [ i ] = '.' ; break ; } } return 0 ; } int gao2 ( int st ) { int i , j ; for ( i = st - 1 ; i >= 1 ; -- i ) { if ( s [ i ] == '.' ) { break ; } } for ( j = st + 1 ; j <= n ; ++ j ) { if ( s [ j ] == '.' ) { break ; } } // dbg(st, i, j); if ( i >= 1 && j <= n ) { s [ i ] = '#' ; s [ j ] = '#' ; if ( ok ()) return 1 ; s [ i ] = '.' ; s [ j ] = '.' ; } return 0 ; } int gao () { if ( ok ()) return 0 ; if ( gao1 ( st )) return 1 ; if ( gao1 ( ed )) return 1 ; if ( gao2 ( st )) return 2 ; if ( gao2 ( ed )) return 2 ; return -1 ; } int main () { freopen ( \"portals.in\" , \"r\" , stdin ); int _T ; cin >> _T ; while ( _T -- ) { scanf ( \"%d%s\" , & n , s + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { if ( s [ i ] == 's' ) st = i ; else if ( s [ i ] == 'e' ) ed = i ; } printf ( \"%d \\n \" , gao ()); } return 0 ; }","title":"C. Portals"},{"location":"trainings/random-trainings/2018-ACM-ICPC-Syrian-Collegiate-Programming-Contest/#d-carnival-slots","text":"Solved By Heush-. 1:44(+) \u9898\u610f\uff1a \u4e00\u5f20 n \\cdot m n \\cdot m \u7684\u7684\u56fe\uff0c\u4f60\u53ef\u4ee5\u4efb\u610f\u4fee\u6539 \\ , / \u4f7f\u5f97\u6bcf\u5217\u6389\u4e0b\u6765\u7684\u6743\u503c\u6570\u91cf\u548c\u6700\u5927\u3002 \u601d\u8def\uff1a - \u8bb0\u5fc6\u5316\u641c\u7d22\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 5e2 + 10 ; int n , m ; char G [ N ][ N ]; int f [ N ][ N ], num [ N ], val [ N ]; int gao ( int x , int y ) { if ( x == n + 1 ) { return val [ y ]; } if ( f [ x ][ y ] != -1 ) return f [ x ][ y ]; int & res = f [ x ][ y ]; res = gao ( x + 1 , y ); if ( G [ x ][ y ] != '.' && y - 1 >= 1 ) res = max ( res , gao ( x + 1 , y - 1 )); if ( G [ x ][ y ] != '.' && y + 1 <= m ) res = max ( res , gao ( x + 1 , y + 1 )); return res ; } int main () { freopen ( \"balls.in\" , \"r\" , stdin ); int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d %d\" , & n , & m ); for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { f [ i ][ j ] = -1 ; } } for ( int i = 1 ; i <= m ; ++ i ) { scanf ( \"%d\" , num + i ); } for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%s\" , G [ i ] + 1 ); } for ( int i = 1 ; i <= m ; ++ i ) { scanf ( \"%d\" , val + i ); } ll res = 0 ; for ( int i = 1 ; i <= m ; ++ i ) { res += 1l l * gao ( 1 , i ) * num [ i ]; } printf ( \"%lld \\n \" , res ); } return 0 ; }","title":"D. Carnival Slots"},{"location":"trainings/random-trainings/2018-ACM-ICPC-Syrian-Collegiate-Programming-Contest/#e-2nodes","text":"UnSolved. \u9898\u610f\uff1a \u6709\u4e00\u68f5\u6811\uff0c\u6bcf\u4e2a\u70b9\u6709\u989c\u8272(\u767d\u3001\u7ea2\u3001\u84dd)\uff0c\u6bcf\u79d2\u949f\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u767d\u8272\u8282\u70b9\uff0c\u5982\u679c\u5b83\u76f8\u90bb\u7684\u8282\u70b9\u4e2d\u5b58\u5728\u975e\u767d\u8272\u7684\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u8282\u70b9\u67d3\u8272\u6210\u90a3\u4e2a\u8282\u70b9\u7684\u989c\u8272\uff0c\u5982\u679c\u6709\u591a\u4e2a\uff0c\u90a3\u4e48\u9009\u53d6\u6807\u53f7\u6700\u5c0f\u7684\u90a3\u4e2a\u70b9\u7684\u989c\u8272\u4f5c\u4e3a\u5f53\u524d\u70b9\u7684\u67d3\u8272\u3002 \u73b0\u5728\u6700\u591a\u80fd\u5c06 2 2 \u4e2a\u70b9\u53d8\u6210\u767d\u8272\uff0c\u95ee\u5982\u4f55\u53d8\u4f7f\u5f97\u6700\u7ec8\u7ea2\u8272\u70b9\u6700\u591a\uff1f \u601d\u8def\uff1a","title":"E. 2Nodes"},{"location":"trainings/random-trainings/2018-ACM-ICPC-Syrian-Collegiate-Programming-Contest/#f-pretests","text":"Solved By Dup4. 2:45(+2) \u9898\u610f\uff1a \u5bf9\u4e8e\u4e00\u4e2a\u9898\u76ee\uff0c\u6709 t t \u7ec4\u6570\u636e\uff0c\u6709 n n \u4efd\u5f85\u8bc4\u6d4b\u7684\u7a0b\u5e8f\uff0c\u6bcf\u4efd\u7a0b\u5e8f\u5982\u679c\u6302\u5728\u4e86\u7b2c k k \u4e2a\u70b9\uff0c\u90a3\u4e48\u5b83\u9700\u8981\u7684\u6d4b\u8bd5\u65f6\u95f4\u4e3a k k \uff0c\u5982\u679c\u901a\u8fc7\u6240\u6709\u6570\u636e\uff0c\u90a3\u4e48\u6d4b\u8bd5\u7684\u65f6\u95f4\u4e3a t t \uff0c\u73b0\u5728\u7ed9\u51fa\u6bcf\u4efd\u7a0b\u5e8f\u5bf9\u4e8e\u6bcf\u4e2a\u70b9\u7684\u901a\u8fc7\u60c5\u51b5\uff0c\u53ef\u4ee5\u91cd\u65b0\u5b89\u6392\u6d4b\u8bd5\u70b9\u7684\u987a\u5e8f\uff0c\u4f7f\u5f97\u603b\u7684\u6d4b\u8bd5\u65f6\u95f4\u6700\u5c0f\u3002 \u8f93\u51fa\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u65b9\u6848\u3002 \u601d\u8def\uff1a f[S] f[S] \u8868\u793a\u524d i i \u4e2a\u6d4b\u8bd5\u70b9\u7684\u96c6\u5408\u4e3a S S \uff0c\u9700\u8981\u7684\u6700\u5c11\u6d4b\u8bd5\u65f6\u95f4\uff0c\u7136\u540e\u679a\u4e3e\u4e00\u4e2a j j \u8fdb\u884c\u8f6c\u79fb\uff0c j j \u8981\u5305\u542b\u5728 S S \u4e2d\u3002 \u7136\u540e\u53d1\u73b0\u989d\u5916\u7684\u8d21\u732e\u662f\u6d4b\u8bd5\u7a0b\u5e8f\u7684\u901a\u8fc7\u6d4b\u8bd5\u70b9\u7684\u96c6\u5408\u662f S S \u7684\u8d85\u96c6\uff0c\u7136\u540e\u8fd9\u90e8\u5206\u8d21\u732e\u53ef\u4ee5\u7528\u9ad8\u7ef4\u524d\u7f00\u548c\u9884\u5904\u7406\u3002 \u603b\u65f6\u95f4\u590d\u6742\u5ea6 O(n \\cdot 2^n) O(n \\cdot 2^n) \uff0c\u5bf9\u4e8e\u5b57\u5178\u5e8f\uff0c\u76f4\u63a5\u8bb0\u5f55\u4e00\u4e2a string \u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 2e6 + 10 , INF = 0x3f3f3f3f ; int t , n , cnt [ N ], f [ N ]; char s [ 110 ]; vector < int > g [ N ]; inline void chmin ( int & x , int y ) { if ( x > y ) x = y ; } int main () { freopen ( \"tests.in\" , \"r\" , stdin ); int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d%d\" , & t , & n ); for ( int i = 0 ; i < ( 1 << t ); ++ i ) cnt [ i ] = 0 , f [ i ] = INF , g [ i ]. clear (); f [ 0 ] = 0 ; int more = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%s\" , s ); int res = 0 ; for ( int j = 0 ; j < t ; ++ j ) { if ( s [ j ] == '1' ) { res |= 1 << j ; } } if ( res == ( 1 << t ) - 1 ) more += t - 1 ; else ++ cnt [ res ]; } for ( int j = 0 ; j < t ; ++ j ) { for ( int i = 0 ; i < 1 << t ; ++ i ) { if ( ! ( i >> j & 1 )) cnt [ i ] += cnt [ i ^ ( 1 << j )]; } } for ( int i = 1 ; i < 1 << t ; ++ i ) { for ( int j = 0 ; j < t ; ++ j ) { if (( i >> j ) & 1 ) { int nx = i ^ ( 1 << j ); g [ nx ]. push_back ( j ); if ( f [ nx ] < f [ i ] || ( f [ nx ] == f [ i ] && g [ nx ] < g [ i ])) { f [ i ] = f [ nx ]; g [ i ] = g [ nx ]; } g [ nx ]. pop_back (); } } f [ i ] += cnt [ i ]; } printf ( \"%d \\n \" , f [( 1 << t ) - 1 ] + n + more ); for ( int i = 0 ; i < t ; ++ i ) printf ( \"%d%c\" , g [( 1 << t ) - 1 ][ i ] + 1 , \" \\n \" [ i == t - 1 ]); } return 0 ; }","title":"F. Pretests"},{"location":"trainings/random-trainings/2018-ACM-ICPC-Syrian-Collegiate-Programming-Contest/#g-is-topo-logical","text":"Solved By Dup4. 3:22(+1) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a n n \u548c\u4e24\u4e2a\u5165\u5ea6\u6570\u7ec4 a, b a, b \uff0c\u8981\u6c42\u6784\u9020\u4e00\u4e2a n n \u4e2a\u70b9\u7684\u6709\u5411\u56fe\uff0c\u6ee1\u8db3\u521a\u5f00\u59cb\u65f6\u7b2c i i \u4e2a\u70b9\u7684\u5165\u5ea6\u4e3a a_i a_i \uff0c\u8dd1\u5b8c\u62d3\u6251\u6392\u5e8f\u540e\u7b2c i i \u4e2a\u70b9\u7684\u5ea6\u6570\u4e3a b_i b_i \u3002 \u601d\u8def\uff1a \u57fa\u4e8e b b \u6570\u7ec4\u4e2d\u662f\u5426\u4e3a 0 0 \u5c06\u70b9\u5206\u6210\u4e24\u90e8\u5206\uff0c\u4e3a 0 0 \u7684\u90a3\u90e8\u5206\u7ec4\u6210\u4e00\u6761\u94fe\uff0c\u4e0d\u4e3a 0 0 \u7684\u90a3\u90e8\u5206\u7ec4\u6210\u4e00\u4e2a\u73af\u3002 \u7136\u540e\u6839\u636e\u5165\u5ea6\u8fde\u8fb9\u5373\u53ef\uff0c\u6839\u636e a_i, b_i a_i, b_i \u8ba8\u8bba\u4e00\u4e0b\u5165\u5ea6\u7684\u6765\u6e90\u3002 Code #include <bits/stdc++.h> using namespace std ; #define SZ(x) (int(x.size())) #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 2e5 + 10 ; int n , a [ N ], b [ N ], need [ N ]; vector < vector < int >> G ; bool gao () { G . clear (); G . resize ( n + 1 ); vector < int > A , B ; for ( int i = 1 ; i <= n ; ++ i ) { need [ i ] = a [ i ] - b [ i ]; if ( ! b [ i ]) A . push_back ( i ); else B . push_back ( i ); } if ( SZ ( B ) == 1 ) return 0 ; for ( int i = 0 ; i < SZ ( B ); ++ i ) { if ( ! i ) G [ B . back ()]. push_back ( B [ i ]); else G [ B [ i - 1 ]]. push_back ( B [ i ]); -- b [ B [ i ]]; } for ( int i = 0 ; i < SZ ( B ); ++ i ) { for ( int j = 0 ; b [ B [ i ]] && j < SZ ( B ); ++ j ) if ( i != j ) { if ( i == 0 && j == SZ ( B ) - 1 ) continue ; if ( i != 0 && j == i - 1 ) continue ; -- b [ B [ i ]]; G [ B [ j ]]. push_back ( B [ i ]); } if ( b [ B [ i ]]) return 0 ; for ( int j = 0 ; need [ B [ i ]] && j < SZ ( A ); ++ j ) { -- need [ B [ i ]]; G [ A [ j ]]. push_back ( B [ i ]); } if ( need [ B [ i ]]) return 0 ; } sort ( A . begin (), A . end (), [ & ]( int x , int y ) { return a [ x ] < a [ y ]; }); for ( int i = 0 ; i < SZ ( A ); ++ i ) { if ( a [ A [ i ]] > i ) return 0 ; for ( int j = 0 ; a [ A [ i ]] && j < i ; ++ j ) { -- a [ A [ i ]]; G [ A [ j ]]. push_back ( A [ i ]); } } int sze = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sze += SZ ( G [ i ]); printf ( \"%d \\n \" , sze ); for ( int i = 1 ; i <= n ; ++ i ) { for ( auto & it : G [ i ]) { printf ( \"%d %d \\n \" , i , it ); } } return 1 ; } int main () { freopen ( \"topo.in\" , \"r\" , stdin ); int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , b + i ); if ( ! gao ()) printf ( \"-1 \\n \" ); } return 0 ; }","title":"G. Is Topo Logical?"},{"location":"trainings/random-trainings/2018-ACM-ICPC-Syrian-Collegiate-Programming-Contest/#h-bugged-system","text":"Solved By Hsueh-. 1:29(+4) \u9898\u610f\uff1a \u4e00\u4e2a\u5730\u94c1\u7ad9\uff0c\u6709 n n \u4e2a\u7ad9\uff0c\u4f46\u662f\u5b58\u5728\u4e00\u4e2a bug\uff0c\u5982\u679c\u4e00\u4e2a\u4eba\u4ece a a \u7ad9\u8fdb\u7ad9 b b \u7ad9\u51fa\u6765\u5219\u4e0d\u7528\u94b1\uff0c\u4eba\u4eec\u53ef\u4ee5\u4ea4\u6362\u5730\u94c1\u5361\u3002 \u95ee n n \u4e2a\u4eba\u5206\u522b\u4ece s_i s_i \u8fdb\u7ad9\uff0c d_i d_i \u51fa\u7ad9\uff0c\u662f\u5426\u5b58\u5728\u4e00\u4e2a\u65b9\u6848\u4f7f\u5f97\u5927\u5bb6\u4e0d\u82b1\u94b1\u3002 \u5982\u679c\u5b58\u5728\u5219\u8f93\u51fa\u6700\u5c0f\u884c\u52a8\u8ddd\u79bb\u548c\u3002 \u601d\u8def\uff1a \u5f88\u663e\u7136\u5982\u679c\u5b58\u5728\u5219\u662f\u4e00\u4e2a\u73af\uff0c\u90a3\u4e48\u6bcf\u4e2a\u7ad9\u7684\u8fdb\u7ad9\u6570\u91cf\u7b49\u4e8e\u51fa\u7ad9\u6570\u91cf\uff0c\u8ddd\u79bb\u5c31\u662f\u6bcf\u4e2a\u4eba\u7684\u884c\u52a8\u8ddd\u79bb Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 2e6 + 10 ; int n , m ; ll a [ N ]; int vis [ N ]; int main () { freopen ( \"bugged.in\" , \"r\" , stdin ); int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d %d\" , & n , & m ); for ( int i = 1 ; i <= n ; ++ i ) { vis [ i ] = 0 ; } for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld\" , a + i ); } ll res = 0 ; for ( int i = 1 , s , d ; i <= m ; ++ i ) { scanf ( \"%d %d\" , & s , & d ); vis [ s ] ++ ; vis [ d ] -- ; res += abs ( a [ s ] - a [ d ]); } for ( int i = 1 ; i <= n ; ++ i ) { if ( vis [ i ]) { res = -1 ; break ; } } printf ( \"%lld \\n \" , res ); } return 0 ; }","title":"H. Bugged System"},{"location":"trainings/random-trainings/2018-ACM-ICPC-Syrian-Collegiate-Programming-Contest/#i-rise-of-the-robots","text":"Solved By Hsueh-. 2:34(+3) \u9898\u610f\uff1a \u4e00\u4e2a\u534a\u5f84\u4e3a R R \u7684\u56fe\uff0c\u4e00\u4e2a\u534a\u5f84\u4e3a r r \u673a\u5668\u4eba\uff0c\u7ecf\u8fc7 n n \u6b21\u64cd\u4f5c\uff0c\u6bcf\u6b21\u64cd\u4f5c\u90fd\u4ece (x,y) (x,y) \u5230 (x+dx_i, y+dy_i) (x+dx_i, y+dy_i) \uff0c\u95ee\u662f\u5426\u5b58\u5728\u4e00\u4e2a\u8d77\u70b9\uff0c\u4f7f\u5f97\u673a\u5668\u4eba\u6ca1\u6709\u51fa\u6574\u4e2a\u5706\u3002 \u601d\u8def\uff1a \u731c\u6d4b\u53ef\u4ee5\u6c42\u51fa\u4e00\u4e2a\u5706\u8868\u793a\u673a\u5668\u4eba\u7684\u8def\u5f84\uff0c\u90a3\u4e48\u6c42\u4e00\u4e2a\u6700\u5c0f\u8986\u76d6\u5706\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using db = double ; const int N = 1e5 + 10 ; const db eps = 1e-10 ; mt19937 rnd ( time ( 0 )); int sgn ( db x ) { if ( fabs ( x ) < eps ) return 0 ; return x > 0 ? 1 : -1 ; } struct Point { db x , y ; Point ( db x = 0 , db y = 0 ) : x ( x ), y ( y ) {} Point operator + ( const Point & b ) const { return Point ( x + b . x , y + b . y ); } Point operator - ( const Point & b ) const { return Point ( x - b . x , y - b . y ); } Point operator * ( const db & b ) const { return Point ( x * b , y * b ); } Point operator / ( const db & b ) const { return Point ( x / b , y / b ); } db operator ^ ( const Point & b ) const { return x * b . y - y * b . x ; } db operator * ( const Point & b ) const { return x * b . x + y * b . y ; } db len () { return hypot ( x , y ); } db len2 () { return x * x + y * y ; } db dis ( Point b ) { return hypot ( x - b . x , y - b . y ); } Point rotright () { return Point ( y , - x ); } } p [ N ]; struct Circle { Point p ; db r ; Circle () {} Circle ( Point p , db r ) : p ( p ), r ( r ) {} Circle ( db x , db y , db r ) : p ( Point ( x , y )), r ( r ) {} Circle ( Point a , Point b , Point c , int opt = 0 ) { if ( opt == 0 ) { Point p0 = ( a + b ) / 2 ; Point v0 = ( b - a ). rotright (); Point p1 = ( a + c ) / 2 ; Point v1 = ( c - a ). rotright (); db t = (( p1 - p0 ) ^ v1 ) / ( v0 ^ v1 ); p = p0 + v0 * t ; r = p . dis ( a ); } } }; int n , R , r ; Point solve () { shuffle ( p + 1 , p + 1 + n , rnd ); Circle cir ( 0 , 0 , 0 ); for ( int i = 1 ; i <= n ; ++ i ) { if ( sgn (( cir . p - p [ i ]). len2 () - cir . r ) > 0 ) { cir . p = p [ i ]; cir . r = 0 ; for ( int j = 1 ; j < i ; ++ j ) { if ( sgn (( cir . p - p [ j ]). len2 () - cir . r ) > 0 ) { cir . p = ( p [ i ] + p [ j ]) / 2 ; cir . r = ( p [ j ] - cir . p ). len2 (); for ( int k = 1 ; k < j ; ++ k ) { if ( sgn (( cir . p - p [ k ]). len2 () - cir . r ) > 0 ) { cir = Circle ( p [ i ], p [ j ], p [ k ]); cir . r = ( p [ k ] - cir . p ). len2 (); } } } } } } cir . p . x *= -1 ; cir . p . y *= -1 ; if ( sgn ( cir . p . x ) == 0 ) cir . p . x = 0 ; if ( sgn ( cir . p . y ) == 0 ) cir . p . y = 0 ; return cir . p ; } int main () { freopen ( \"robots.in\" , \"r\" , stdin ); int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d %d %d\" , & n , & R , & r ); db x = 0 , y = 0 ; for ( int i = 1 , dx , dy ; i <= n ; ++ i ) { scanf ( \"%d %d\" , & dx , & dy ); x += dx , y += dy ; p [ i ] = Point ( x , y ); } ++ n ; p [ n ] = Point ( 0 , 0 ); Point res = solve (); printf ( \"%.9f %.9f \\n \" , res . x , res . y ); } return 0 ; }","title":"I. Rise of the Robots"},{"location":"trainings/random-trainings/2018-ACM-ICPC-Syrian-Collegiate-Programming-Contest/#j-clarifications","text":"Solved By Dup4 & Hsueh-. 4:19(+) \u9898\u610f\uff1a \u5728\u4e00\u573a\u65f6\u957f\u4e3a m m \u7684\u6bd4\u8d5b\u4e2d\uff0c\u6709 n n \u4e2a\u95ee\u9898\uff0c\u6709 k k \u4e2a\u79cd\u7c7b\u7684\u95ee\u9898\uff0c\u6709\u4e24\u4e2a\u56de\u7b54\u7684\u4eba A \u548c B \uff0c A \u80fd\u5728\u4efb\u4f55\u65f6\u523b\u56de\u7b54\u4efb\u4f55\u95ee\u9898\uff0c B \u53ea\u80fd\u56de\u7b54\u5728\u8fd9\u4e4b\u524d A \u56de\u7b54\u8fc7\u7684\u95ee\u9898\u4e2d\u76f8\u540c\u79cd\u7c7b\u7684\u95ee\u9898\u3002 \u6bcf\u4e2a\u95ee\u9898\u6709\u4e24\u4e2a\u53c2\u6570 t_i, p_i t_i, p_i \uff0c\u5206\u522b\u8868\u793a\u8be2\u95ee\u7684\u65f6\u523b\u548c\u79cd\u7c7b\u3002\u73b0\u5728\u95ee\u57fa\u4e8e\u4e0a\u8ff0\u9650\u5236\u6761\u4ef6\uff0c\u56de\u7b54\u5b8c\u6240\u6709\u95ee\u9898\u6700\u5c11\u9700\u8981\u591a\u5c11\u65f6\u95f4\u3002 \u601d\u8def\uff1a \u8003\u8651\u5df2\u7ecf\u88ab A \u56de\u7b54\u8fc7\u7684\u79cd\u7c7b\u662f\u6ca1\u6709\u533a\u522b\u7684\uff0c\u5e76\u4e14\u4f18\u5148\u7ea7\u6700\u4f4e\u3002 \u7136\u540e\u8003\u8651\u8fd8\u6ca1\u6709\u56de\u7b54\u8fc7\u7684\uff0c\u4f46\u662f\u5df2\u7ecf\u5728\u961f\u5217\u4e2d\u4e86\uff0c\u6211\u4eec\u6839\u636e\u4ed6\u4eec\u5728\u961f\u5217\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\u8fdb\u884c\u4f18\u5148\u7ea7\u6392\u5e8f\uff0c\u5bf9\u4e8e A \u6765\u8bf4\uff0c\u6bcf\u6b21\u53d6\u4f18\u5148\u7ea7\u6700\u9ad8\u7684\u51fa\u6765\u56de\u7b54\u6389\uff0c\u7136\u540e\u91ca\u653e\u51fa\u4e00\u4e9b\u95ee\u9898\uff0c\u53ef\u4ee5\u8ba9 B \u4e5f\u4e00\u8d77\u5e2e\u5fd9\u56de\u7b54\u3002 \u4f46\u662f\u5982\u679c\u6709\u4e24\u4e2a\u95ee\u9898\u7684\u51fa\u73b0\u6b21\u6570\u76f8\u540c\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u4e0b\u4e00\u79d2\u4f1a\u51fa\u73b0\u7684\u95ee\u9898\u4e5f\u7eb3\u5165\u8003\u91cf\u4e4b\u4e2d\u3002 \u7ef4\u62a4\u4f18\u5148\u7ea7\u7684\u64cd\u4f5c\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002 Code #include <bits/stdc++.h> using namespace std ; using pII = pair < int , int > ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 1e5 + 10 , INF = 1e9 ; int n , m , K , sta [ N ]; struct SEG { struct node { int val , pos ; node ( int val = 0 , int pos = 0 ) : val ( val ), pos ( pos ) {} node operator + ( const node & other ) const { node res = node (); if ( val > other . val ) { res = ( * this ); } else { res = other ; } return res ; } } t [ N << 2 ]; void build ( int id , int l , int r ) { t [ id ] = node (); if ( l == r ) { t [ id ]. pos = l ; return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); } void update ( int id , int l , int r , int pos , int v ) { // dbg(id, l, r, pos, v); if ( l == r ) { t [ id ]. val += v ; return ; } int mid = ( l + r ) >> 1 ; if ( pos <= mid ) update ( id << 1 , l , mid , pos , v ); else update ( id << 1 | 1 , mid + 1 , r , pos , v ); t [ id ] = t [ id << 1 ] + t [ id << 1 | 1 ]; } } seg ; int main () { freopen ( \"clar.in\" , \"r\" , stdin ); int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d%d%d\" , & m , & n , & K ); vector < vector < int >> vec ( m + 5 ); for ( int i = 1 , t , p ; i <= n ; ++ i ) { scanf ( \"%d%d\" , & t , & p ); vec [ t ]. push_back ( p ); } // 0 \u6ca1\u51fa\u73b0\u8fc7 1 \u5728seg\u4e2d 2 \u88ab\u56de\u7b54\u8fc7\u4e00\u6b21 for ( int i = 1 ; i <= K ; ++ i ) sta [ i ] = 0 ; seg . build ( 1 , 1 , K ); int cnt = 0 ; int t = 1 ; int remind = n ; while ( remind ) { if ( t <= m ) for ( auto & it : vec [ t ]) { if ( sta [ it ] == 0 ) { ++ sta [ it ]; seg . update ( 1 , 1 , K , it , 1 ); } else if ( sta [ it ] == 1 ) { seg . update ( 1 , 1 , K , it , 1 ); } else if ( sta [ it ] == 2 ) { ++ cnt ; } } if ( t + 1 <= m ) for ( auto & it : vec [ t + 1 ]) { if ( sta [ it ] == 1 ) { seg . update ( 1 , 1 , K , it , 1 ); } } if ( cnt ) -- cnt , -- remind ; int val = seg . t [ 1 ]. val , pos = seg . t [ 1 ]. pos ; if ( sta [ pos ] != 1 ) pos = 0 ; if ( pos ) { cnt += val - 1 ; sta [ pos ] = 2 ; -- remind ; seg . update ( 1 , 1 , K , pos , - INF ); } else if ( cnt ) { -- cnt ; -- remind ; } if ( t + 1 <= m ) for ( auto & it : vec [ t + 1 ]) { if ( it == pos ) { -- cnt ; } else if ( sta [ it ] == 1 ) { seg . update ( 1 , 1 , K , it , -1 ); } } ++ t ; } printf ( \"%d \\n \" , t - 1 ); } return 0 ; }","title":"J. Clarifications"},{"location":"trainings/random-trainings/2018-ACM-ICPC-Syrian-Collegiate-Programming-Contest/#k-tourists-tour","text":"Solved By Dup4 & Hsueh-. 1:11(+1) \u9898\u610f\uff1a \u6709 n n \u5ea7\u5c71\u5cf0\uff0c\u6bcf\u5ea7\u5c71\u5cf0\u7684\u9ad8\u5ea6\u4e3a h_i h_i \uff0c\u5bf9\u4e8e\u7b2c i i \u5ea7\u5c71\u5cf0\uff0c\u5982\u679c\u5b83\u5de6\u8fb9\u6709\u6bd4\u4ed6\u9ad8\u7684\u5c71\u5cf0\uff0c\u90a3\u4e48\u5b83\u4f1a\u627e\u4e00\u5ea7\u79bb\u5b83\u6700\u8fd1\u7684\u5e76\u4e14\u6bd4\u5b83\u9ad8\u7684\u7136\u540e\u5728\u8fd9\u4e4b\u95f4\u5efa\u7acb\u4e00\u5ea7\u6865(\u5373\u8fde\u4e00\u6761\u8fb9)\u3002 \u5bf9\u4e8e\u53f3\u8fb9\u4ea6\u662f\u5982\u6b64\uff0c\u73b0\u5728\u8981\u5bf9\u8fd9\u4e9b\u8fb9\u8fdb\u884c\u67d3\u8272\uff0c\u4f7f\u5f97\u4efb\u610f\u4e24\u6761\u76f8\u90bb\u7684\u8fb9\u4e0d\u540c\u8272\uff0c\u6ce8\u610f\u8fb9\u662f\u65e0\u5411\u8fb9\u3002 \u601d\u8def\uff1a \u5f3a\u5236\u8ba9\u9ad8\u7684\u5c71\u5cf0\u8fde\u5411\u4f4e\u7684\u5c71\u5cf0\uff0c\u53d8\u6210 DAG\uff0c\u7136\u540e\u66b4\u529b\u67d3\u8272\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e6 + 10 ; int n ; int a [ N ]; vector < vector < int > > G ; int col [ N ], in [ N ], vis [ N ][ 6 ]; int gao () { int rt = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( in [ i ] == 0 ) { rt = i ; break ; } } int Max = 0 ; queue < int > q ; q . push ( rt ); while ( ! q . empty ()) { int u = q . front (); q . pop (); for ( int i = 1 ; i <= 5 ; ++ i ) { if ( vis [ u ][ i ]) continue ; col [ u ] = i ; Max = max ( Max , i ); for ( auto v : G [ u ]) { vis [ v ][ i ] = 1 ; in [ v ] -- ; if ( in [ v ] == 0 ) { q . push ( v ); } } break ; } } return Max ; } int main () { freopen ( \"tour.in\" , \"r\" , stdin ); int _T ; scanf ( \"%d\" , & _T ); while ( _T -- ) { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { col [ i ] = 0 ; in [ i ] = 0 ; for ( int j = 0 ; j < 6 ; ++ j ) { vis [ i ][ j ] = 0 ; } } for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); } G . clear (); G . resize ( n + 1 ); stack < int > stk ; for ( int i = 1 ; i <= n ; ++ i ) { while ( ! stk . empty () && a [ stk . top ()] <= a [ i ]) stk . pop (); if ( ! stk . empty ()) { int u = stk . top (); int v = i ; G [ u ]. push_back ( v ); in [ v ] ++ ; } stk . push ( i ); } while ( ! stk . empty ()) stk . pop (); for ( int i = n ; i >= 1 ; -- i ) { while ( ! stk . empty () && a [ stk . top ()] <= a [ i ]) stk . pop (); if ( ! stk . empty ()) { int u = stk . top (); int v = i ; G [ u ]. push_back ( v ); in [ v ] ++ ; } stk . push ( i ); } int Max = gao (); printf ( \"%d \\n \" , Max ); for ( int i = 1 ; i <= n ; ++ i ) { printf ( \"%d%c\" , col [ i ], \" \\n \" [ i == n ]); } } return 0 ; }","title":"K. Tourists' Tour"},{"location":"trainings/random-trainings/2018-ACM-ICPC-Syrian-Collegiate-Programming-Contest/#l-sad-meals","text":"UnSolved. \u9898\u610f\uff1a \u6709\u4e00\u4e2a\u53a8\u5e08\u505a\u83dc\uff0c\u5047\u8bbe\u4ed6\u5728\u7b2c i i \u5929\u4e4b\u524d\u5df2\u7ecf\u4f1a\u4e86 x x \u9053\u83dc\u4e86\u3002 \u90a3\u4e48\u4ed6\u5728\u7b2c i i \u53ef\u80fd\u5b66\u65b0\u83dc\uff0c\u5373 a_i = x + 1 a_i = x + 1 \u3002 \u4e5f\u53ef\u80fd\u987a\u7740\u524d\u4e00\u5929\u7684\u987a\u5e8f\u505a\u83dc\uff0c\u5373 a_i = a_{i - 1} + 1 a_i = a_{i - 1} + 1 \u3002 \u5982\u679c\u524d\u4e00\u5929\u505a\u5b8c\u4e86\u5df2\u7ecf\u5b66\u4f1a\u7684\u83dc\uff0c\u90a3\u4e48\u5c31\u91cd\u65b0\u5f00\u59cb\u8f6e\u56de\uff0c\u5373\u505a\u7b2c\u4e00\u9053\u83dc a_i = 1 a_i = 1 \u3002 \u73b0\u5728\u7ed9\u51fa a a \u6570\u7ec4\uff0c\u4f46\u662f\u6316\u7a7a\u4e86\u4e00\u4e9b\u4f4d\u7f6e\uff0c\u8981\u6c42\u8865\u5145\u4e0a\u8fd9\u4e9b\u4f4d\u7f6e\uff0c\u4f7f\u5f97\u6ee1\u8db3\u4e0a\u8ff0\u9650\u5236\u6761\u4ef6\u3002 \u601d\u8def\uff1a","title":"L. Sad Meals"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Brazil-Subregional-Programming-Contest/","text":"2019-2020 ACM-ICPC Brazil Subregional Programming Contest Contents Contest Info Solutions A.Artwork B.Buffoon C.Crossings With Danger D.Denouncing Mafia E.Exhibition of Clownfish F.Forests in Danger G.Getting Confidence H.Hour for a Run I.Interplanetary J.Jar of Water Game K.Keep Calm and Sell Balloons L.Less Coin Tosses M.Maratona Brasileira de Popcorn Contest Info Practice Link Solved A B C D E F G H I J K L M 11/13 O O - O - O O O O O O O O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5 Solutions A.Artwork Solved By Hsueh- & ltslts. 0:33(+) \u9898\u610f\uff1a \u4e00\u4e2a n \\cdot m n \\cdot m \u7684\u77e9\u9635\u6709 n n \u4e2a\u534a\u5f84\u4e3a R_i R_i \u7684\u4f20\u611f\u5668\uff0c\u95ee\u80fd\u5426\u4ece (0,0) (0,0) \u8d70\u5230 (n,m) (n,m) \u4e0d\u78b0\u5230\u4efb\u4f55\u4f20\u611f\u5668\u3002 \u601d\u8def\uff1a \u5e76\u67e5\u96c6\uff0c\u5c06 n n \u4e2a\u5706\u5e76\u8d77\u6765\uff0c\u5224\u65ad\u5de6\u4e0a\u533a\u57df\u80fd\u5426\u4e0e\u53f3\u4e0b\u533a\u57df\u8fde\u901a\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 ; struct node { int x , y , r ; void input () { scanf ( \"%d %d %d\" , & x , & y , & r ); } } a [ N ]; int n , m , k ; int fa [ N ], sze [ N ]; int find ( int x ) { return x == fa [ x ] ? fa [ x ] : fa [ x ] = find ( fa [ x ]); } void merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( x != y ) { if ( sze [ x ] > sze [ y ]) swap ( x , y ); fa [ x ] = y ; sze [ y ] += sze [ x ]; } } int sqr ( int x ) { return x * x ; } int main () { scanf ( \"%d %d %d\" , & n , & m , & k ); for ( int i = 1 ; i <= k ; ++ i ) { a [ i ]. input (); } for ( int i = 1 ; i <= k + 2 ; ++ i ) { fa [ i ] = i , sze [ i ] = 1 ; } for ( int i = 1 ; i <= k ; ++ i ) { if ( a [ i ]. x + a [ i ]. r >= n || a [ i ]. y <= a [ i ]. r ) merge ( i , k + 1 ); if ( a [ i ]. x <= a [ i ]. r || a [ i ]. y + a [ i ]. r >= m ) merge ( i , k + 2 ); } for ( int i = 1 ; i <= k ; ++ i ) { for ( int j = 1 ; j < i ; ++ j ) { if ( sqr ( a [ i ]. x - a [ j ]. x ) + sqr ( a [ i ]. y - a [ j ]. y ) <= sqr ( a [ i ]. r + a [ j ]. r )) { merge ( i , j ); } } } puts ( find ( k + 1 ) == find ( k + 2 ) ? \"N\" : \"S\" ); return 0 ; } B.Buffoon Solved By Dup4. 0:07(+) \u7b7e\u5230\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e4 + 10 ; int n , a [ N ]; int main () { scanf ( \"%d\" , & n ); int Max = -1 ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); Max = max ( Max , a [ i ]); } puts (( a [ 1 ] == Max ) ? \"S\" : \"N\" ); return 0 ; } C.Crossings With Danger Solved By . 0:00(+) \u9898\u610f\uff1a \u601d\u8def\uff1a D.Denouncing Mafia Solved By Dup4 & Hsueh-. 1:39(+1) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u68f5\u6811\uff0c\u6bcf\u6b21\u9009\u62e9\u4e00\u4e2a\u70b9\uff0c\u5c06\u8be5\u70b9\u5230\u6839\u7684\u6240\u6709\u70b9\u90fd\u67d3\u8272\uff0c\u73b0\u5728\u53ef\u4ee5\u9009\u62e9 k k \u4e2a\u70b9\u8fdb\u884c\u67d3\u8272\u64cd\u4f5c\uff0c\u95ee\u6700\u591a\u80fd\u67d3\u591a\u5c11\u4e2a\u70b9\uff1f \u601d\u8def\uff1a \u957f\u94fe\u5256\u5206\uff0c\u5c06\u6bcf\u6761\u94fe\u5256\u5206\u51fa\u6765\uff0c\u7136\u540e\u8d2a\u5fc3\u53d6 K K \u6761\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int n , K ; vector < vector < int >> G ; int fa [ N ], md [ N ], hson [ N ], deep [ N ], use [ N ]; void dfs ( int u ) { hson [ u ] = 0 ; for ( auto & v : G [ u ]) { deep [ v ] = deep [ u ] + 1 ; dfs ( v ); if ( ! hson [ u ] || md [ v ] > md [ hson [ u ]]) hson [ u ] = v ; } md [ u ] = md [ hson [ u ]] + 1 ; } int main () { scanf ( \"%d%d\" , & n , & K ); G . resize ( n + 1 ); fa [ 1 ] = 1 ; deep [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; ++ i ) { scanf ( \"%d\" , fa + i ); G [ fa [ i ]]. push_back ( i ); } int cnt = 0 ; for ( int i = 2 ; i <= n ; ++ i ) if ( G [ i ]. empty ()) { ++ cnt ; } if ( K >= cnt ) { printf ( \"%d \\n \" , n ); } else { dfs ( 1 ); vector < int > vec ; for ( int i = 1 ; i <= n ; ++ i ) if ( hson [ i ]) use [ hson [ i ]] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) if ( use [ i ] == 0 ) { vec . push_back ( md [ i ]); } sort ( vec . begin (), vec . end (), [ & ]( int x , int y ) { return x > y ; }); int sum = 0 ; for ( int i = 0 ; i < K ; ++ i ) sum += vec [ i ]; printf ( \"%d \\n \" , sum ); } return 0 ; } E.Exhibition of Clownfish Solved By . 0:00(+) \u9898\u610f\uff1a \u601d\u8def\uff1a F.Forests in Danger Solved By Dup4 & ltslts. 4:18(+) \u9898\u610f\uff1a \u7ed9\u51fa\u82e5\u5e72\u6761\u5e73\u884c\u4e8e\u5750\u6807\u8f74\u7684\u7ebf\u6bb5\u548c\u4e00\u4e2a\u56db\u6761\u8fb9\u90fd\u5e73\u884c\u4e8e\u5750\u6807\u8f74\u7684\u77e9\u5f62\uff0c\u7136\u540e\u7ed9\u51fa\u4e00\u4e2a P P \uff0c\u73b0\u5728\u8981\u9009\u5b9a\u4e00\u4e2a\u6700\u5c0f\u7684 r r \uff0c\u5bf9\u4e8e\u6bcf\u6761\u7ebf\u6bb5\u627e\u4e00\u4e2a\u77e9\u5f62\u8986\u76d6\u5b83\uff0c\u5e76\u4e14\u4fdd\u8bc1\u77e9\u5f62\u5916\u7684\u70b9\u5230\u8fd9\u6761\u7ebf\u6bb5\u7684\u6700\u77ed\u8ddd\u79bb\u4e3a r r ,\u8981\u6ee1\u8db3\u8fd9\u4e9b\u77e9\u5f62\u7684\u9762\u79ef\u5e76\u548c\u9898\u76ee\u7ed9\u5b9a\u77e9\u5f62\u7684\u9762\u79ef\u5e76\u5927\u4e8e\u7b49\u4e8e\u9898\u76ee\u7ed9\u5b9a\u77e9\u5f62\u7684\u9762\u79ef\u7684 $P % $\u3002 \u601d\u8def\uff1a \u4e8c\u5206 r r \uff0c\u7136\u540e\u5c31\u662f\u6c42\u77e9\u5f62\u9762\u79ef\u5e76\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 2e5 + 10 ; int n , rate ; struct P { int x , y ; void scan () { scanf ( \"%d%d\" , & x , & y ); } }; struct node { P s , e ; void scan () { s . scan (); e . scan (); } }; node li [ N ]; node Tri ; struct Hash { int a [ N ], tot ; void init () { tot = 0 ; a [ 0 ] = 0 ; } void add ( int x ) { a [ ++ tot ] = x ; } void gao () { sort ( a + 1 , a + 1 + tot ); tot = unique ( a + 1 , a + 1 + tot ) - a - 1 ; } int get ( int x ) { return lower_bound ( a + 1 , a + 1 + tot , x ) - a ; } } hx , hy ; struct SEG { struct node { int cnt , len ; void init () { cnt = len = 0 ; } } t [ N << 2 ]; void build ( int id , int l , int r ) { t [ id ]. init (); if ( l == r ) return ; int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); } void up ( int id , int l , int r ) { if ( t [ id ]. cnt > 0 ) { t [ id ]. len = hy . a [ r ] - hy . a [ l - 1 ]; } else { if ( l == r ) t [ id ]. len = 0 ; else { t [ id ]. len = t [ id << 1 ]. len + t [ id << 1 | 1 ]. len ; } } } void update ( int id , int l , int r , int ql , int qr , int v ) { if ( ql > qr ) return ; if ( l >= ql && r <= qr ) { t [ id ]. cnt += v ; up ( id , l , r ); return ; } int mid = ( l + r ) >> 1 ; if ( ql <= mid ) update ( id << 1 , l , mid , ql , qr , v ); if ( qr > mid ) update ( id << 1 | 1 , mid + 1 , r , ql , qr , v ); up ( id , l , r ); } } seg ; node rec [ N ]; vector < vector < P >> add , del ; ll calc ( int r ) { hx . init (); hy . init (); for ( int i = 1 ; i <= n ; ++ i ) { node tmp ; tmp . s . x = min ( li [ i ]. s . x , li [ i ]. e . x ) - r ; tmp . s . x = max ( tmp . s . x , Tri . s . x ); tmp . s . y = min ( li [ i ]. s . y , li [ i ]. e . y ) - r ; tmp . s . y = max ( tmp . s . y , Tri . s . y ); tmp . e . x = max ( li [ i ]. s . x , li [ i ]. e . x ) + r ; tmp . e . x = min ( tmp . e . x , Tri . e . x ); tmp . e . y = max ( li [ i ]. s . y , li [ i ]. e . y ) + r ; tmp . e . y = min ( tmp . e . y , Tri . e . y ); rec [ i ] = tmp ; hx . add ( tmp . s . x ); hx . add ( tmp . e . x ); hy . add ( tmp . s . y ); hy . add ( tmp . e . y ); } hx . gao (); hy . gao (); for ( int i = 1 ; i <= n ; ++ i ) { rec [ i ]. s . x = hx . get ( rec [ i ]. s . x ); rec [ i ]. e . x = hx . get ( rec [ i ]. e . x ); rec [ i ]. s . y = hy . get ( rec [ i ]. s . y ); rec [ i ]. e . y = hy . get ( rec [ i ]. e . y ); } int cx = hx . tot , cy = hy . tot ; add . clear (); add . resize ( cx + 5 ); del . clear (); del . resize ( cx + 5 ); for ( int i = 1 ; i <= n ; ++ i ) { add [ rec [ i ]. s . x ]. push_back ({ rec [ i ]. s . y + 1 , rec [ i ]. e . y }); del [ rec [ i ]. e . x ]. push_back ({ rec [ i ]. s . y + 1 , rec [ i ]. e . y }); } seg . build ( 1 , 1 , cy ); ll res = 0 ; for ( int i = 1 ; i <= cx ; ++ i ) { res += 1l l * ( hx . a [ i ] - hx . a [ i - 1 ]) * seg . t [ 1 ]. len ; for ( auto & it : add [ i ]) { seg . update ( 1 , 1 , cy , it . x , it . y , 1 ); } for ( auto & it : del [ i ]) { seg . update ( 1 , 1 , cy , it . x , it . y , -1 ); } } return res * 100 ; } int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { li [ i ]. scan (); } scanf ( \"%d\" , & rate ); Tri . scan (); ll area = 1l l * ( Tri . e . x - Tri . s . x ) * ( Tri . e . y - Tri . s . y ) * rate ; int l = 0 , r = 1e5 , res = 1e5 ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( calc ( mid ) >= area ) { r = mid - 1 ; res = mid ; } else { l = mid + 1 ; } } printf ( \"%d \\n \" , res ); return 0 ; } G.Getting Confidence Solved By Hsueh-. 1:00(+) \u9898\u610f\uff1a - n n \u4e2a\u7269\u54c1\uff0c n n \u4e2a\u8d27\u67b6\uff0c a_{ij} a_{ij} \u8868\u793a\u7269\u54c1 i i \u653e\u5728\u8d27\u67b6 j j \u7684\u6743\u503c\uff0c\u95ee\u6700\u5927\u7684 \\prod a(i, p_i) \\prod a(i, p_i) \u3002 \u601d\u8def\uff1a \u53d6 log log \u8f6c\u5316\u4e3a\u52a0\u6cd5\uff0c\u8dd1\u8d39\u7528\u6d41\u3002 Code #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } using db = double ; const int N = 2e4 + 10 , M = 1e6 + 10 , INF = 0x3f3f3f3f ; struct Edge { int to , nxt , cap , flow ; db cost ; Edge () {} Edge ( int to , int nxt , int cap , int flow , db cost ) : to ( to ), nxt ( nxt ), cap ( cap ), flow ( flow ), cost ( cost ) {} } edge [ M ]; int head [ N ], tot ; int pre [ N ]; db dis [ N ]; bool vis [ N ]; void Init () { tot = 0 ; memset ( head , -1 , sizeof head ); } void addedge ( int u , int v , int cap , db cost ) { edge [ tot ] = Edge ( v , head [ u ], cap , 0 , cost ); head [ u ] = tot ++ ; edge [ tot ] = Edge ( u , head [ v ], 0 , 0 , - cost ); head [ v ] = tot ++ ; } bool SPFA ( int S , int T ) { queue < int > q ; for ( int i = 0 ; i < N ; ++ i ) { dis [ i ] = INF ; vis [ i ] = false ; pre [ i ] = -1 ; } dis [ S ] = 0 ; vis [ S ] = true ; q . push ( S ); while ( ! q . empty ()) { int u = q . front (); q . pop (); // dbg(u); vis [ u ] = false ; for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { int v = edge [ i ]. to ; if ( edge [ i ]. cap > edge [ i ]. flow && dis [ v ] > dis [ u ] + edge [ i ]. cost ) { dis [ v ] = dis [ u ] + edge [ i ]. cost ; pre [ v ] = i ; if ( ! vis [ v ]) { q . push ( v ); vis [ v ] = true ; } } } } // for (int i = 1; i <= 11; ++i) { // dbg(i, pre[i]); // } if ( pre [ T ] == -1 ) return false ; else return true ; } int minCostMaxflow ( int s , int t , db & cost ) { int flow = 0 ; cost = 0 ; while ( SPFA ( s , t )) { int Min = INF ; for ( int i = pre [ t ]; ~ i ; i = pre [ edge [ i ^ 1 ]. to ]) { Min = min ( Min , edge [ i ]. cap - edge [ i ]. flow ); } for ( int i = pre [ t ]; ~ i ; i = pre [ edge [ i ^ 1 ]. to ]) { edge [ i ]. flow += Min ; edge [ i ^ 1 ]. flow -= Min ; cost += edge [ i ]. cost * Min ; } flow += Min ; } return flow ; } int n ; int res [ N ]; int main () { scanf ( \"%d\" , & n ); Init (); int S = 2 * n + 1 , T = 2 * n + 2 ; for ( int i = 1 ; i <= n ; ++ i ) { addedge ( S , i , 1 , 0 ); addedge ( i + n , T , 1 , 0 ); } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { db x = 0 ; scanf ( \"%lf\" , & x ); x = log ( x ); addedge ( i , j + n , 1 , - x ); } } db cost ; minCostMaxflow ( S , T , cost ); for ( int u = 1 ; u <= n ; ++ u ) { for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { int v = edge [ i ]. to ; if ( v != S && edge [ i ]. cap == edge [ i ]. flow ) { res [ v - n ] = u ; } } } for ( int i = 1 ; i <= n ; ++ i ) { printf ( \"%d%c\" , res [ i ], \" \\n \" [ i == n ]); } return 0 ; } H.Hour for a Run Solved By Hsueh-. 0:06(+) \u9898\u610f\uff1a \u64cd\u573a\u4e00\u5708\u6709 n n \u4e2a\u6807\u5fd7\uff0c\u603b\u5171\u8dd1 v v \u5708\uff0c\u95ee 10 \\% \\cdots 90 \\% 10 \\% \\cdots 90 \\% \u4f1a\u9047\u5230\u591a\u5c11\u969c\u788d\u7269\u3002 \u601d\u8def\uff1a \u7b7e\u5230\u3002 Code #include <bits/stdc++.h> using namespace std ; int v , n ; int main () { scanf ( \"%d %d\" , & v , & n ); for ( int i = 1 ; i <= 9 ; ++ i ) { int res = (( v * n * i ) + 9 ) / 10 ; printf ( \"%d%c\" , res , \" \\n \" [ i == 9 ]); } return 0 ; } I.Interplanetary Solved By Hsueh-. 3:34(+) \u9898\u610f\uff1a n n \u4e2a\u661f\u7403\uff0c\u6bcf\u4e2a\u661f\u7403\u53c8\u5728\u81ea\u5df1\u7684\u6e29\u5ea6\uff0c\u6709 Q Q \u6b21\u67e5\u8be2\uff0c\u6bcf\u6b21\u67e5\u8be2\u95ee\u6307\u7ecf\u8fc7\u6700\u7d2f\u6216\u6700\u70ed\u7684 K K \u4e2a\u661f\u7403\uff0c\u4ece a a \u5230 b b \u7684\u6700\u77ed\u8def\u3002 \u601d\u8def\uff1a \u79bb\u7ebf\u540e\u52a8\u6001\u52a0\u70b9\u8dd1 Floyd\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 4e2 + 10 , M = 1e5 + 10 , INF = 0x3f3f3f3f ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } struct E { int a , b , x , id , op ; E () {} E ( int a , int b , int x , int id , int op ) : a ( a ), b ( b ), x ( x ), id ( id ), op ( op ) {} bool operator < ( const E & other ) const { return x < other . x ; } }; struct node { int id , x ; node () {} node ( int id , int x ) : id ( id ), x ( x ) {} bool operator < ( const node & other ) const { return x < other . x ; } }; int n , m , top ; int temp [ N ], res [ M ]; int G [ N ][ N ], _G [ N ][ N ]; int id [ N ]; vector < E > Q ; vector < node > vec ; void gao () { // T = 0 <= x for ( int i = 1 ; i <= n ; ++ i ) { vec . push_back ( node ( i , temp [ i ])); } sort ( vec . begin (), vec . end ()); sort ( Q . begin (), Q . end ()); for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { G [ i ][ j ] = _G [ i ][ j ]; } } int pos = -1 ; for ( auto it : Q ) { while ( pos < n - 1 && vec [ pos + 1 ]. x <= id [ it . x ]) { // dbg(pos); pos ++ ; int k = vec [ pos ]. id ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { G [ i ][ j ] = min ( G [ i ][ j ], G [ i ][ k ] + G [ k ][ j ]); } } } if ( it . op == 0 ) res [ it . id ] = G [ it . a ][ it . b ]; } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { G [ i ][ j ] = _G [ i ][ j ]; } } // T = 1 >= x reverse ( vec . begin (), vec . end ()); reverse ( id + 1 , id + 1 + top ); pos = -1 ; for ( auto it : Q ) { // dbg(it.id); while ( pos < n - 1 && vec [ pos + 1 ]. x >= id [ it . x ]) { pos ++ ; int k = vec [ pos ]. id ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { G [ i ][ j ] = min ( G [ i ][ j ], G [ i ][ k ] + G [ k ][ j ]); } } } if ( it . op == 1 ) res [ it . id ] = G [ it . a ][ it . b ]; } } int main () { scanf ( \"%d %d\" , & n , & m ); memset ( _G , INF , sizeof _G ); for ( int i = 1 ; i <= n ; ++ i ) { _G [ i ][ i ] = 0 ; } set < int > se ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , temp + i ); se . insert ( temp [ i ]); } for ( auto it : se ) { id [ ++ top ] = it ; } for ( int i = 1 , u , v , w ; i <= m ; ++ i ) { scanf ( \"%d %d %d\" , & u , & v , & w ); _G [ u ][ v ] = _G [ v ][ u ] = w ; } int q ; scanf ( \"%d\" , & q ); for ( int i = 1 , a , b , x , t ; i <= q ; ++ i ) { scanf ( \"%d %d %d %d\" , & a , & b , & x , & t ); if ( x > top ) x = top ; Q . push_back ( E ( a , b , x , i , t )); } gao (); for ( int i = 1 ; i <= q ; ++ i ) { if ( res [ i ] == INF ) { res [ i ] = -1 ; } printf ( \"%d \\n \" , res [ i ]); } return 0 ; } J.Jar of Water Game Solved By Hsueh-. 2:02(+1) \u9898\u610f\uff1a \u4e00\u4e2a\u6e38\u620f\uff0c\u603b\u5171\u6709 A23456789DJQK \u548c wildcard \uff0c 14 14 \u79cd\u724c\uff0c\u6309\u7167\u89c4\u5219\u95ee\u6700\u540e\u8c01\u8d62\u3002 \u89c4\u5219\u5982\u4e0b\uff1a n n \u4e2a\u4eba\u5750\u6210\u4e00\u5708\uff0c\u7b2c k k \u4e2a\u4eba\u5148\u5f00\u59cb\u3002 \u6bcf\u4e2a\u4eba\u7ed9\u81ea\u5df1\u7684\u4e0b\u4e00\u4f4d\uff0c\u4e5f\u5c31\u662f 1 1 \u7ed9 2 \\cdots 2 \\cdots \u3002 \u5982\u679c\u521a\u62ff\u5230 wildcard \u5219\u4e0d\u80fd\u5c06 wildcard \u7ed9\u4e0b\u4e00\u5bb6,\u5426\u5219\u4e00\u5b9a\u7ed9 wildcard \u3002 \u5426\u5219\u627e\u5230\u6570\u91cf\u6700\u5c0f\u7684\u7ed9\u4e0b\u4e00\u5bb6\u3002 \u5982\u679c\u6709\u591a\u4e2a\u6570\u91cf\u6700\u5c0f\u7684\u5219\u62ff\u51fa\u6570\u5b57\u6700\u4e0b\u7684\u3002 \u5982\u679c\u4e00\u4e2a\u4eba\u624b\u4e0a\u56db\u5f20\u724c\u90fd\u4e00\u6837\u5219\u83b7\u80dc\u3002 \u601d\u8def\uff1a \u6a21\u62df Code #include <bits/stdc++.h> using namespace std ; const int INF = 0x3f3f3f3f ; int get ( char c ) { if ( c == 'A' ) return 1 ; else if ( c == 'D' ) return 10 ; else if ( c == 'Q' ) return 11 ; else if ( c == 'J' ) return 12 ; else if ( c == 'K' ) return 13 ; else return c - '0' ; } struct E { bool First , wildcard ; vector < int > card ; int get () { if ( wildcard ) { if ( First ) { First = false ; } else { wildcard = false ; return -1 ; } } map < int , int > mp ; for ( auto it : card ) { mp [ it ] ++ ; } int Min = INF ; for ( auto it : mp ) { Min = min ( it . second , Min ); } for ( auto it : mp ) { if ( it . second == Min ) { card . erase ( find ( card . begin (), card . end (), it . first )); return it . first ; } } } void insert ( int x ) { if ( x == -1 ) { First = wildcard = true ; } else { card . push_back ( x ); } } } a [ 30 ]; bool win ( int x ) { if ( a [ x ]. wildcard ) return false ; if ( a [ x ]. card [ 0 ] != a [ x ]. card [ 1 ]) return false ; if ( a [ x ]. card [ 1 ] != a [ x ]. card [ 2 ]) return false ; if ( a [ x ]. card [ 2 ] != a [ x ]. card [ 3 ]) return false ; return true ; } int n , k ; int main () { scanf ( \"%d %d\" , & n , & k ); for ( int i = 1 ; i <= n ; ++ i ) { char s [ 10 ]; scanf ( \"%s\" , s + 1 ); a [ i ]. card . clear (); for ( int j = 1 ; j <= 4 ; ++ j ) { a [ i ]. insert ( get ( s [ j ])); } a [ i ]. First = a [ i ]. wildcard = false ; } a [ k ]. First = a [ k ]. wildcard = true ; for ( int i = 1 ; i <= n ; ++ i ) { if ( win ( i )) { printf ( \"%d \\n \" , i ); return 0 ; } } int cur = k ; while ( true ) { int nxt = cur % n + 1 ; a [ nxt ]. insert ( a [ cur ]. get ()); if ( win ( cur )) break ; cur = nxt ; } printf ( \"%d \\n \" , cur ); return 0 ; } K.Keep Calm and Sell Balloons Solved By Dup4 & ltslts. 3:14(+) \u9898\u610f\uff1a \u7ed9\u51fa 2 \\cdot N 2 \\cdot N \u7684\u77e9\u9635\uff0c\u77e9\u9635\u4e0a\u7684\u6570\u5b57\u4ece\u5de6\u5f80\u53f3\uff0c\u4ece\u4e0a\u5230\u4e0b\uff0c\u4f9d\u6b21\u4e3a 1 - 2N 1 - 2N \u3002 \u73b0\u5728\u53ef\u4ee5\u4efb\u9009\u4e00\u4e2a\u8d77\u70b9\u51fa\u53d1\uff0c\u6bcf\u6b21\u53ef\u4ee5\u4e0a\u4e0b\u5de6\u53f3\u5bf9\u89d2\u7ebf\u516b\u4e2a\u65b9\u5411\u8d70\u5230\u76f8\u90bb\u7684\u5e76\u4e14\u6ca1\u6709\u88ab\u8bbf\u95ee\u8fc7\u7684\u70b9\u8d70\uff0c\u95ee\u8bbf\u95ee\u5b8c\u6240\u6709\u70b9\u7684\u65b9\u6848\u6570\u3002 \u601d\u8def\uff1a \u4ee4 f[n] f[n] \u8868\u793a\u4ece 1 1 \u51fa\u53d1\u7684\u65b9\u6848\u6570\u3002 \u90a3\u4e48\u6211\u4eec\u8003\u8651\u600e\u4e48\u9012\u63a8 f[n] f[n] \uff1a \u4ece 1 1 \u51fa\u53d1\uff0c\u5982\u679c\u6700\u7ec8\u56de\u5230 n + 1 n + 1 \uff0c\u90a3\u4e48\u6bcf\u6b21\u5f80\u53f3\u53ef\u4ee5\u9009\u62e9\u8d70\u4e0a\u8fb9\u6216\u8005\u5f80\u4e0b\u8fb9\uff0c\u90a3\u4e48\u56de\u6765\u56de\u5230 n + 1 n + 1 \u7684\u8def\u5f84\u662f\u56fa\u5b9a\u7684\uff0c\u8fd9\u90e8\u5206\u8d21\u732e\u662f 2^{n - 1} 2^{n - 1} \u5982\u679c\u7b2c\u4e8c\u6b65\u8d70 n + 1 n + 1 \uff0c\u90a3\u4e48\u7b2c\u4e09\u6b65\u53ef\u4ee5\u8d70 2 2 \u6216\u8005 n + 2 n + 2 \uff0c\u5bb9\u6613\u53d1\u73b0\u8fd9\u662f\u4e00\u4e2a\u5b50\u95ee\u9898\uff0c\u65b9\u6848\u6570\u4e3a 2f[n - 1] 2f[n - 1] \u3002 \u518d\u8003\u8651\u7b2c\u4e09\u6b65\u8d70 n + 1 n + 1 \uff0c\u90a3\u4e48\u8d70\u6cd5\u662f 1 \\to 2 \\to n + 1 \\to n + 2 1 \\to 2 \\to n + 1 \\to n + 2 \u6216\u8005 1 \\to n + 2 \\to n + 1 \\to 2 1 \\to n + 2 \\to n + 1 \\to 2 \uff0c\u7136\u540e\u5c31\u662f\u4e00\u4e2a n - 2 n - 2 \u89c4\u6a21\u7684\u5b50\u95ee\u9898\uff0c\u8d21\u732e\u662f 4f[n - 2] 4f[n - 2] \u3002 \u6240\u4ee5\u6709\uff1a \\begin{eqnarray*} f[n] = 2f[n - 1] + 4f[n - 2] + 2^{n - 1} \\end{eqnarray*} \\begin{eqnarray*} f[n] = 2f[n - 1] + 4f[n - 2] + 2^{n - 1} \\end{eqnarray*} \u90a3\u4e48\u56db\u4e2a\u89d2\u7684\u8d21\u732e\u5c31\u662f 4f[n] 4f[n] \uff0c\u6211\u4eec\u518d\u8003\u8651\u4e2d\u95f4\u7684\u8d21\u732e\u3002 \u5bb9\u6613\u53d1\u73b0\uff0c\u6211\u4eec\u53d1\u73b0\u4ece\u7b2c\u4e00\u5c42\u7684\u7b2c i i \u5217\u51fa\u53d1\u548c\u4ece\u7b2c\u4e8c\u5c42\u7684\u7b2c i i \u5217\u51fa\u53d1\u7684\u65b9\u6848\u6570\u662f\u76f8\u540c\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u8003\u8651\u7b2c\u4e00\u5c42\u7684\u7b2c i i \u5217\uff1a \u663e\u7136\uff0c\u5b83\u4e0d\u53ef\u80fd\u5728\u7b2c\u4e8c\u6b65\u8d70\u5230 n + i n + i \u3002 \u5047\u8bbe\u5b83\u5f80\u53f3\u8d70\uff0c\u65b9\u6848\u6570\u4e3a 2^{n - i} 2^{n - i} \uff0c\u7136\u540e\u56de\u5230 n + i n + i \u8fd9\u4e2a\u4f4d\u7f6e\uff0c\u518d\u5f80\u5de6\u8fb9\u8d70\uff0c\u8fd9\u90e8\u5206\u7684\u65b9\u6848\u662f f[i - 1] f[i - 1] \uff0c\u6240\u4ee5\u5f80\u53f3\u8d70\u7684\u8d21\u732e\u662f \\displaystyle f[i - 1] \\cdot 2^{n - 1} \\displaystyle f[i - 1] \\cdot 2^{n - 1} \u3002 \u540c\u7406\u53ef\u5f97\uff0c\u5f80\u5de6\u8fb9\u8d70\u7684\u65b9\u6848\u6570\u4e3a f[n - i] \\cdot 2^{i - 1} f[n - i] \\cdot 2^{i - 1} \u3002 \u90a3\u4e48\u7b54\u6848\u5c31\u662f\uff1a \\begin{eqnarray*} f[n] &=& 4f[n - 2] + 2f[n - 1] + 2^{n - 1} \\\\ ans &=& 4(f[n] + \\sum\\limits_{i = 2}^{n - 1} (f[i - 1] \\cdot 2^{n - i} + f[n - i] \\cdot 2^{i - 1}) ) \\end{eqnarray*} \\begin{eqnarray*} f[n] &=& 4f[n - 2] + 2f[n - 1] + 2^{n - 1} \\\\ ans &=& 4(f[n] + \\sum\\limits_{i = 2}^{n - 1} (f[i - 1] \\cdot 2^{n - i} + f[n - i] \\cdot 2^{i - 1}) ) \\end{eqnarray*} \u4ee4 \\displaystyle g[n] = \\sum\\limits_{i = 2}^{n - 1} f[i - 1] \\cdot 2^{n - i} \\displaystyle g[n] = \\sum\\limits_{i = 2}^{n - 1} f[i - 1] \\cdot 2^{n - i} \uff0c\u6709 \\begin{eqnarray*} g[n] = g[n - 1] \\cdot 2 + f[n - 2] \\cdot 2 \\end{eqnarray*} \\begin{eqnarray*} g[n] = g[n - 1] \\cdot 2 + f[n - 2] \\cdot 2 \\end{eqnarray*} \u4ee4 \\displaystyle h[n] = \\sum\\limits_{i = 2}^{n - 1} f[n - i] \\cdot 2^{i - 1} \\displaystyle h[n] = \\sum\\limits_{i = 2}^{n - 1} f[n - i] \\cdot 2^{i - 1} \uff0c\u6709 \\begin{eqnarray*} h[n] = h[n - 1] \\cdot 2 + f[n - 2] \\cdot 2 \\end{eqnarray*} \\begin{eqnarray*} h[n] = h[n - 1] \\cdot 2 + f[n - 2] \\cdot 2 \\end{eqnarray*} \u5bb9\u6613\u53d1\u73b0 g[n] g[n] \u548c h[n] h[n] \u662f\u4e00\u6837\u7684\uff0c\u76f4\u63a5\u77e9\u9635\u5feb\u901f\u5e42\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using ll = long long ; using namespace std ; const int mod = 1e9 + 7 ; int n ; inline void chadd ( ll & x , ll y ) { x += y ; while ( x >= mod ) x -= mod ; while ( x < 0 ) x += mod ; } struct node { ll a [ 4 ][ 4 ]; node () {} ll * operator []( int x ) { return a [ x ]; } void init () { memset ( a , 0 , sizeof a ); } node operator * ( const node & other ) const { node res = node (); res . init (); for ( int i = 0 ; i < 4 ; ++ i ) { for ( int j = 0 ; j < 4 ; ++ j ) { for ( int k = 0 ; k < 4 ; ++ k ) { chadd ( res . a [ i ][ j ], a [ i ][ k ] * other . a [ k ][ j ] % mod ); } } } return res ; } }; node qpow ( node base , node res , ll n ) { while ( n ) { if ( n & 1 ) res = res * base ; base = base * base ; n >>= 1 ; } return res ; } ll gao () { if ( n == 1 ) return 2 ; if ( n == 2 ) return 24 ; node base = node (); base . init (); base [ 0 ][ 0 ] = 6 , base [ 0 ][ 1 ] = 1 , base [ 0 ][ 2 ] = 0 , base [ 0 ][ 3 ] = 4 ; node res = node (); res . init (); res [ 0 ][ 0 ] = 2 , res [ 0 ][ 1 ] = 1 ; res [ 1 ][ 0 ] = 4 , res [ 1 ][ 2 ] = 2 ; res [ 2 ][ 2 ] = 2 ; res [ 3 ][ 0 ] = 1 , res [ 3 ][ 3 ] = 2 ; swap ( res , base ); res = qpow ( base , res , n - 2 ); return 4l l * ( res [ 0 ][ 0 ] + 2l l * res [ 0 ][ 2 ] % mod ) % mod ; } int main () { scanf ( \"%d\" , & n ); ll res = gao (); res = ( res % mod + mod ) % mod ; printf ( \"%lld \\n \" , res ); return 0 ; } L.Less Coin Tosses Solved By Dup4 & ltslts. 1:07(+) \u9898\u610f\uff1a \u6709\u4e00\u4e2a\u786c\u5e01\uff0c\u5b83\u4e0d\u662f\u516c\u5e73\u7684\uff0c\u5373\u63b7\u51fa\u6b63\u9762\u548c\u53cd\u9762\u7684\u6982\u7387\u4e0d\u540c\u3002 \u73b0\u5728\u4e3a\u4e86\u516c\u5e73\uff0c\u6709\u5982\u4e0b\u7b56\u7565\uff1a \u9009\u4e00\u4e2a n n \u3002 \u90a3\u4e48\u6709 2^n 2^n \u4e2a 01\u4e32 \uff0cAlice \u62ff\u4e00\u90e8\u5206\uff0cBob \u62ff\u4e00\u90e8\u5206\uff0c\u5269\u4e0b\u7684\u820d\u5f03\uff0c\u7136\u540e\u5c06\u8be5\u786c\u5e01\u6295\u63b7 n n \u6b21\uff0c\u6839\u636e\u63b7\u51fa\u7684\u6b63\u53cd\u9762\u5f62\u6210\u4e00\u4e2a\u957f\u5ea6\u4e3a n n \u7684 01\u4e32 \uff0c\u5982\u679c\u8be5\u4e32\u5728 Alice \u90a3\u90e8\u5206\u4e2d\uff0cAlice \u83b7\u80dc\uff0c\u5982\u679c\u5728 Bob \u90a3\u90e8\u5206\u4e2d\uff0cBob \u83b7\u80dc\uff0c\u5426\u5219\u518d\u6765\u4e00\u6b21\u3002 \u73b0\u5728\u7ed9\u5b9a n n \uff0c\u73b0\u5728\u95ee\u6700\u5c11\u820d\u5f03\u591a\u5c11 01\u4e32 \uff0c\u4f7f\u5f97\u8be5\u73a9\u6cd5\u662f\u516c\u5e73\u7684\u3002 \u601d\u8def\uff1a \u6211\u4eec\u5047\u8bbe\u6295\u51fa\u6b63\u9762\u7684\u6982\u7387\u4e3a x x \uff0c\u6295\u51fa\u53cd\u9762\u7684\u6982\u7387\u4e3a y y \uff0c\u5047\u8bbe\u4e00\u4e2a\u957f\u5ea6\u4e3a n n \u7684\u5b57\u7b26\u4e32\u4e2d\u6709 a a \u4e2a 0\uff0c\u6709 b b \u4e2a 1\uff0c\u90a3\u4e48\u63b7\u51fa\u8be5 01\u4e32 \u7684\u6982\u7387\u4e3a x^a \\cdot y^b x^a \\cdot y^b \u3002 \u90a3\u4e48\u53ef\u4ee5\u6839\u636e (a, b) (a, b) \u8fd9\u4e2a\u4e8c\u5143\u7ec4\uff0c\u5c06\u6240\u6709 01\u4e32 \u8fdb\u884c\u5206\u7c7b\uff0c\u540c\u7c7b\u7684\u5747\u5206\u7ed9\u4e24\u4eba\uff0c\u90a3\u4e48\u5bb9\u6613\u53d1\u73b0\uff0c\u5982\u679c\u67d0\u7c7b\u5b57\u7b26\u4e32\u662f\u5947\u6570\u4e2a\uff0c\u90a3\u4e48\u5fc5\u7136\u8981\u7559\u4e0b\u4e00\u4e2a\u3002 \u6240\u4ee5\u7b54\u6848\u5c31\u662f \\displaystyle \\sum\\limits_{i = 0}^n {n \\choose i} \\% 2 = 2^p \\displaystyle \\sum\\limits_{i = 0}^n {n \\choose i} \\% 2 = 2^p \uff0c\u5176\u4e2d p p \u4e3a n n \u7684\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d 1 1 \u7684\u4e2a\u6570\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; int main () { ll n ; cin >> n ; cout << ( 1l l << __builtin_popcountll ( n )) << \" \\n \" ; return 0 ; } M.Maratona Brasileira de Popcorn Solved By Dup4. 0:33(+) \u9898\u610f\uff1a \u6709 n n \u888b\u7206\u7c73\u82b1\uff0c\u6bcf\u888b\u6709 p_i p_i \u4e2a\u7206\u7c73\u82b1\uff0c\u6709 C C \u4e2a\u4eba\uff0c\u6bcf\u4e2a\u4eba\u6bcf\u79d2\u949f\u80fd\u591f\u5403 T T \u4e2a\u7206\u7c73\u82b1\u3002 \u73b0\u5728\u6709\u4e24\u4e2a\u9650\u5236\u6761\u4ef6\uff1a \u6bcf\u4e2a\u4eba\u53ea\u80fd\u5403\u4e00\u6bb5\u888b\u5b50\u6807\u53f7\u8fde\u7eed\u7684\u7206\u7c73\u82b1 \u540c\u4e00\u888b\u91cc\u7684\u7206\u7c73\u82b1\u53ea\u80fd\u88ab\u540c\u4e00\u4e2a\u4eba\u5403 \u95ee\u6700\u5c11\u9700\u8981\u591a\u5c11\u65f6\u95f4\uff0c\u4f7f\u5f97\u7206\u7c73\u82b1\u80fd\u88ab\u5403\u5b8c\u3002 \u601d\u8def\uff1a \u4e8c\u5206\u65f6\u95f4\uff0c\u8d2a\u5fc3 check\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int n , m , T , a [ N ]; int calc ( int x ) { int tot = x * T ; int res = 1 , sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( a [ i ] > tot ) return 1e9 ; if ( a [ i ] + sum <= tot ) { sum += a [ i ]; } else { sum = a [ i ]; ++ res ; } } return res ; } int main () { scanf ( \"%d%d%d\" , & n , & m , & T ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); int l = 1 , r = 1e9 / T + 5 , res = 1e9 ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( calc ( mid ) <= m ) { r = mid - 1 ; res = mid ; } else { l = mid + 1 ; } } printf ( \"%d \\n \" , res ); return 0 ; }","title":"2019-2020 ACM-ICPC Brazil Subregional Programming Contest"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Brazil-Subregional-Programming-Contest/#contest-info","text":"Practice Link Solved A B C D E F G H I J K L M 11/13 O O - O - O O O O O O O O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5","title":"Contest Info"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Brazil-Subregional-Programming-Contest/#solutions","text":"","title":"Solutions"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Brazil-Subregional-Programming-Contest/#aartwork","text":"Solved By Hsueh- & ltslts. 0:33(+) \u9898\u610f\uff1a \u4e00\u4e2a n \\cdot m n \\cdot m \u7684\u77e9\u9635\u6709 n n \u4e2a\u534a\u5f84\u4e3a R_i R_i \u7684\u4f20\u611f\u5668\uff0c\u95ee\u80fd\u5426\u4ece (0,0) (0,0) \u8d70\u5230 (n,m) (n,m) \u4e0d\u78b0\u5230\u4efb\u4f55\u4f20\u611f\u5668\u3002 \u601d\u8def\uff1a \u5e76\u67e5\u96c6\uff0c\u5c06 n n \u4e2a\u5706\u5e76\u8d77\u6765\uff0c\u5224\u65ad\u5de6\u4e0a\u533a\u57df\u80fd\u5426\u4e0e\u53f3\u4e0b\u533a\u57df\u8fde\u901a\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 ; struct node { int x , y , r ; void input () { scanf ( \"%d %d %d\" , & x , & y , & r ); } } a [ N ]; int n , m , k ; int fa [ N ], sze [ N ]; int find ( int x ) { return x == fa [ x ] ? fa [ x ] : fa [ x ] = find ( fa [ x ]); } void merge ( int x , int y ) { x = find ( x ), y = find ( y ); if ( x != y ) { if ( sze [ x ] > sze [ y ]) swap ( x , y ); fa [ x ] = y ; sze [ y ] += sze [ x ]; } } int sqr ( int x ) { return x * x ; } int main () { scanf ( \"%d %d %d\" , & n , & m , & k ); for ( int i = 1 ; i <= k ; ++ i ) { a [ i ]. input (); } for ( int i = 1 ; i <= k + 2 ; ++ i ) { fa [ i ] = i , sze [ i ] = 1 ; } for ( int i = 1 ; i <= k ; ++ i ) { if ( a [ i ]. x + a [ i ]. r >= n || a [ i ]. y <= a [ i ]. r ) merge ( i , k + 1 ); if ( a [ i ]. x <= a [ i ]. r || a [ i ]. y + a [ i ]. r >= m ) merge ( i , k + 2 ); } for ( int i = 1 ; i <= k ; ++ i ) { for ( int j = 1 ; j < i ; ++ j ) { if ( sqr ( a [ i ]. x - a [ j ]. x ) + sqr ( a [ i ]. y - a [ j ]. y ) <= sqr ( a [ i ]. r + a [ j ]. r )) { merge ( i , j ); } } } puts ( find ( k + 1 ) == find ( k + 2 ) ? \"N\" : \"S\" ); return 0 ; }","title":"A.Artwork"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Brazil-Subregional-Programming-Contest/#bbuffoon","text":"Solved By Dup4. 0:07(+) \u7b7e\u5230\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e4 + 10 ; int n , a [ N ]; int main () { scanf ( \"%d\" , & n ); int Max = -1 ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); Max = max ( Max , a [ i ]); } puts (( a [ 1 ] == Max ) ? \"S\" : \"N\" ); return 0 ; }","title":"B.Buffoon"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Brazil-Subregional-Programming-Contest/#ccrossings-with-danger","text":"Solved By . 0:00(+) \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"C.Crossings With Danger"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Brazil-Subregional-Programming-Contest/#ddenouncing-mafia","text":"Solved By Dup4 & Hsueh-. 1:39(+1) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u68f5\u6811\uff0c\u6bcf\u6b21\u9009\u62e9\u4e00\u4e2a\u70b9\uff0c\u5c06\u8be5\u70b9\u5230\u6839\u7684\u6240\u6709\u70b9\u90fd\u67d3\u8272\uff0c\u73b0\u5728\u53ef\u4ee5\u9009\u62e9 k k \u4e2a\u70b9\u8fdb\u884c\u67d3\u8272\u64cd\u4f5c\uff0c\u95ee\u6700\u591a\u80fd\u67d3\u591a\u5c11\u4e2a\u70b9\uff1f \u601d\u8def\uff1a \u957f\u94fe\u5256\u5206\uff0c\u5c06\u6bcf\u6761\u94fe\u5256\u5206\u51fa\u6765\uff0c\u7136\u540e\u8d2a\u5fc3\u53d6 K K \u6761\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int n , K ; vector < vector < int >> G ; int fa [ N ], md [ N ], hson [ N ], deep [ N ], use [ N ]; void dfs ( int u ) { hson [ u ] = 0 ; for ( auto & v : G [ u ]) { deep [ v ] = deep [ u ] + 1 ; dfs ( v ); if ( ! hson [ u ] || md [ v ] > md [ hson [ u ]]) hson [ u ] = v ; } md [ u ] = md [ hson [ u ]] + 1 ; } int main () { scanf ( \"%d%d\" , & n , & K ); G . resize ( n + 1 ); fa [ 1 ] = 1 ; deep [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; ++ i ) { scanf ( \"%d\" , fa + i ); G [ fa [ i ]]. push_back ( i ); } int cnt = 0 ; for ( int i = 2 ; i <= n ; ++ i ) if ( G [ i ]. empty ()) { ++ cnt ; } if ( K >= cnt ) { printf ( \"%d \\n \" , n ); } else { dfs ( 1 ); vector < int > vec ; for ( int i = 1 ; i <= n ; ++ i ) if ( hson [ i ]) use [ hson [ i ]] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) if ( use [ i ] == 0 ) { vec . push_back ( md [ i ]); } sort ( vec . begin (), vec . end (), [ & ]( int x , int y ) { return x > y ; }); int sum = 0 ; for ( int i = 0 ; i < K ; ++ i ) sum += vec [ i ]; printf ( \"%d \\n \" , sum ); } return 0 ; }","title":"D.Denouncing Mafia"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Brazil-Subregional-Programming-Contest/#eexhibition-of-clownfish","text":"Solved By . 0:00(+) \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"E.Exhibition of Clownfish"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Brazil-Subregional-Programming-Contest/#fforests-in-danger","text":"Solved By Dup4 & ltslts. 4:18(+) \u9898\u610f\uff1a \u7ed9\u51fa\u82e5\u5e72\u6761\u5e73\u884c\u4e8e\u5750\u6807\u8f74\u7684\u7ebf\u6bb5\u548c\u4e00\u4e2a\u56db\u6761\u8fb9\u90fd\u5e73\u884c\u4e8e\u5750\u6807\u8f74\u7684\u77e9\u5f62\uff0c\u7136\u540e\u7ed9\u51fa\u4e00\u4e2a P P \uff0c\u73b0\u5728\u8981\u9009\u5b9a\u4e00\u4e2a\u6700\u5c0f\u7684 r r \uff0c\u5bf9\u4e8e\u6bcf\u6761\u7ebf\u6bb5\u627e\u4e00\u4e2a\u77e9\u5f62\u8986\u76d6\u5b83\uff0c\u5e76\u4e14\u4fdd\u8bc1\u77e9\u5f62\u5916\u7684\u70b9\u5230\u8fd9\u6761\u7ebf\u6bb5\u7684\u6700\u77ed\u8ddd\u79bb\u4e3a r r ,\u8981\u6ee1\u8db3\u8fd9\u4e9b\u77e9\u5f62\u7684\u9762\u79ef\u5e76\u548c\u9898\u76ee\u7ed9\u5b9a\u77e9\u5f62\u7684\u9762\u79ef\u5e76\u5927\u4e8e\u7b49\u4e8e\u9898\u76ee\u7ed9\u5b9a\u77e9\u5f62\u7684\u9762\u79ef\u7684 $P % $\u3002 \u601d\u8def\uff1a \u4e8c\u5206 r r \uff0c\u7136\u540e\u5c31\u662f\u6c42\u77e9\u5f62\u9762\u79ef\u5e76\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 2e5 + 10 ; int n , rate ; struct P { int x , y ; void scan () { scanf ( \"%d%d\" , & x , & y ); } }; struct node { P s , e ; void scan () { s . scan (); e . scan (); } }; node li [ N ]; node Tri ; struct Hash { int a [ N ], tot ; void init () { tot = 0 ; a [ 0 ] = 0 ; } void add ( int x ) { a [ ++ tot ] = x ; } void gao () { sort ( a + 1 , a + 1 + tot ); tot = unique ( a + 1 , a + 1 + tot ) - a - 1 ; } int get ( int x ) { return lower_bound ( a + 1 , a + 1 + tot , x ) - a ; } } hx , hy ; struct SEG { struct node { int cnt , len ; void init () { cnt = len = 0 ; } } t [ N << 2 ]; void build ( int id , int l , int r ) { t [ id ]. init (); if ( l == r ) return ; int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); } void up ( int id , int l , int r ) { if ( t [ id ]. cnt > 0 ) { t [ id ]. len = hy . a [ r ] - hy . a [ l - 1 ]; } else { if ( l == r ) t [ id ]. len = 0 ; else { t [ id ]. len = t [ id << 1 ]. len + t [ id << 1 | 1 ]. len ; } } } void update ( int id , int l , int r , int ql , int qr , int v ) { if ( ql > qr ) return ; if ( l >= ql && r <= qr ) { t [ id ]. cnt += v ; up ( id , l , r ); return ; } int mid = ( l + r ) >> 1 ; if ( ql <= mid ) update ( id << 1 , l , mid , ql , qr , v ); if ( qr > mid ) update ( id << 1 | 1 , mid + 1 , r , ql , qr , v ); up ( id , l , r ); } } seg ; node rec [ N ]; vector < vector < P >> add , del ; ll calc ( int r ) { hx . init (); hy . init (); for ( int i = 1 ; i <= n ; ++ i ) { node tmp ; tmp . s . x = min ( li [ i ]. s . x , li [ i ]. e . x ) - r ; tmp . s . x = max ( tmp . s . x , Tri . s . x ); tmp . s . y = min ( li [ i ]. s . y , li [ i ]. e . y ) - r ; tmp . s . y = max ( tmp . s . y , Tri . s . y ); tmp . e . x = max ( li [ i ]. s . x , li [ i ]. e . x ) + r ; tmp . e . x = min ( tmp . e . x , Tri . e . x ); tmp . e . y = max ( li [ i ]. s . y , li [ i ]. e . y ) + r ; tmp . e . y = min ( tmp . e . y , Tri . e . y ); rec [ i ] = tmp ; hx . add ( tmp . s . x ); hx . add ( tmp . e . x ); hy . add ( tmp . s . y ); hy . add ( tmp . e . y ); } hx . gao (); hy . gao (); for ( int i = 1 ; i <= n ; ++ i ) { rec [ i ]. s . x = hx . get ( rec [ i ]. s . x ); rec [ i ]. e . x = hx . get ( rec [ i ]. e . x ); rec [ i ]. s . y = hy . get ( rec [ i ]. s . y ); rec [ i ]. e . y = hy . get ( rec [ i ]. e . y ); } int cx = hx . tot , cy = hy . tot ; add . clear (); add . resize ( cx + 5 ); del . clear (); del . resize ( cx + 5 ); for ( int i = 1 ; i <= n ; ++ i ) { add [ rec [ i ]. s . x ]. push_back ({ rec [ i ]. s . y + 1 , rec [ i ]. e . y }); del [ rec [ i ]. e . x ]. push_back ({ rec [ i ]. s . y + 1 , rec [ i ]. e . y }); } seg . build ( 1 , 1 , cy ); ll res = 0 ; for ( int i = 1 ; i <= cx ; ++ i ) { res += 1l l * ( hx . a [ i ] - hx . a [ i - 1 ]) * seg . t [ 1 ]. len ; for ( auto & it : add [ i ]) { seg . update ( 1 , 1 , cy , it . x , it . y , 1 ); } for ( auto & it : del [ i ]) { seg . update ( 1 , 1 , cy , it . x , it . y , -1 ); } } return res * 100 ; } int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { li [ i ]. scan (); } scanf ( \"%d\" , & rate ); Tri . scan (); ll area = 1l l * ( Tri . e . x - Tri . s . x ) * ( Tri . e . y - Tri . s . y ) * rate ; int l = 0 , r = 1e5 , res = 1e5 ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( calc ( mid ) >= area ) { r = mid - 1 ; res = mid ; } else { l = mid + 1 ; } } printf ( \"%d \\n \" , res ); return 0 ; }","title":"F.Forests in Danger"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Brazil-Subregional-Programming-Contest/#ggetting-confidence","text":"Solved By Hsueh-. 1:00(+) \u9898\u610f\uff1a - n n \u4e2a\u7269\u54c1\uff0c n n \u4e2a\u8d27\u67b6\uff0c a_{ij} a_{ij} \u8868\u793a\u7269\u54c1 i i \u653e\u5728\u8d27\u67b6 j j \u7684\u6743\u503c\uff0c\u95ee\u6700\u5927\u7684 \\prod a(i, p_i) \\prod a(i, p_i) \u3002 \u601d\u8def\uff1a \u53d6 log log \u8f6c\u5316\u4e3a\u52a0\u6cd5\uff0c\u8dd1\u8d39\u7528\u6d41\u3002 Code #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } using db = double ; const int N = 2e4 + 10 , M = 1e6 + 10 , INF = 0x3f3f3f3f ; struct Edge { int to , nxt , cap , flow ; db cost ; Edge () {} Edge ( int to , int nxt , int cap , int flow , db cost ) : to ( to ), nxt ( nxt ), cap ( cap ), flow ( flow ), cost ( cost ) {} } edge [ M ]; int head [ N ], tot ; int pre [ N ]; db dis [ N ]; bool vis [ N ]; void Init () { tot = 0 ; memset ( head , -1 , sizeof head ); } void addedge ( int u , int v , int cap , db cost ) { edge [ tot ] = Edge ( v , head [ u ], cap , 0 , cost ); head [ u ] = tot ++ ; edge [ tot ] = Edge ( u , head [ v ], 0 , 0 , - cost ); head [ v ] = tot ++ ; } bool SPFA ( int S , int T ) { queue < int > q ; for ( int i = 0 ; i < N ; ++ i ) { dis [ i ] = INF ; vis [ i ] = false ; pre [ i ] = -1 ; } dis [ S ] = 0 ; vis [ S ] = true ; q . push ( S ); while ( ! q . empty ()) { int u = q . front (); q . pop (); // dbg(u); vis [ u ] = false ; for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { int v = edge [ i ]. to ; if ( edge [ i ]. cap > edge [ i ]. flow && dis [ v ] > dis [ u ] + edge [ i ]. cost ) { dis [ v ] = dis [ u ] + edge [ i ]. cost ; pre [ v ] = i ; if ( ! vis [ v ]) { q . push ( v ); vis [ v ] = true ; } } } } // for (int i = 1; i <= 11; ++i) { // dbg(i, pre[i]); // } if ( pre [ T ] == -1 ) return false ; else return true ; } int minCostMaxflow ( int s , int t , db & cost ) { int flow = 0 ; cost = 0 ; while ( SPFA ( s , t )) { int Min = INF ; for ( int i = pre [ t ]; ~ i ; i = pre [ edge [ i ^ 1 ]. to ]) { Min = min ( Min , edge [ i ]. cap - edge [ i ]. flow ); } for ( int i = pre [ t ]; ~ i ; i = pre [ edge [ i ^ 1 ]. to ]) { edge [ i ]. flow += Min ; edge [ i ^ 1 ]. flow -= Min ; cost += edge [ i ]. cost * Min ; } flow += Min ; } return flow ; } int n ; int res [ N ]; int main () { scanf ( \"%d\" , & n ); Init (); int S = 2 * n + 1 , T = 2 * n + 2 ; for ( int i = 1 ; i <= n ; ++ i ) { addedge ( S , i , 1 , 0 ); addedge ( i + n , T , 1 , 0 ); } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { db x = 0 ; scanf ( \"%lf\" , & x ); x = log ( x ); addedge ( i , j + n , 1 , - x ); } } db cost ; minCostMaxflow ( S , T , cost ); for ( int u = 1 ; u <= n ; ++ u ) { for ( int i = head [ u ]; ~ i ; i = edge [ i ]. nxt ) { int v = edge [ i ]. to ; if ( v != S && edge [ i ]. cap == edge [ i ]. flow ) { res [ v - n ] = u ; } } } for ( int i = 1 ; i <= n ; ++ i ) { printf ( \"%d%c\" , res [ i ], \" \\n \" [ i == n ]); } return 0 ; }","title":"G.Getting Confidence"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Brazil-Subregional-Programming-Contest/#hhour-for-a-run","text":"Solved By Hsueh-. 0:06(+) \u9898\u610f\uff1a \u64cd\u573a\u4e00\u5708\u6709 n n \u4e2a\u6807\u5fd7\uff0c\u603b\u5171\u8dd1 v v \u5708\uff0c\u95ee 10 \\% \\cdots 90 \\% 10 \\% \\cdots 90 \\% \u4f1a\u9047\u5230\u591a\u5c11\u969c\u788d\u7269\u3002 \u601d\u8def\uff1a \u7b7e\u5230\u3002 Code #include <bits/stdc++.h> using namespace std ; int v , n ; int main () { scanf ( \"%d %d\" , & v , & n ); for ( int i = 1 ; i <= 9 ; ++ i ) { int res = (( v * n * i ) + 9 ) / 10 ; printf ( \"%d%c\" , res , \" \\n \" [ i == 9 ]); } return 0 ; }","title":"H.Hour for a Run"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Brazil-Subregional-Programming-Contest/#iinterplanetary","text":"Solved By Hsueh-. 3:34(+) \u9898\u610f\uff1a n n \u4e2a\u661f\u7403\uff0c\u6bcf\u4e2a\u661f\u7403\u53c8\u5728\u81ea\u5df1\u7684\u6e29\u5ea6\uff0c\u6709 Q Q \u6b21\u67e5\u8be2\uff0c\u6bcf\u6b21\u67e5\u8be2\u95ee\u6307\u7ecf\u8fc7\u6700\u7d2f\u6216\u6700\u70ed\u7684 K K \u4e2a\u661f\u7403\uff0c\u4ece a a \u5230 b b \u7684\u6700\u77ed\u8def\u3002 \u601d\u8def\uff1a \u79bb\u7ebf\u540e\u52a8\u6001\u52a0\u70b9\u8dd1 Floyd\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 4e2 + 10 , M = 1e5 + 10 , INF = 0x3f3f3f3f ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } struct E { int a , b , x , id , op ; E () {} E ( int a , int b , int x , int id , int op ) : a ( a ), b ( b ), x ( x ), id ( id ), op ( op ) {} bool operator < ( const E & other ) const { return x < other . x ; } }; struct node { int id , x ; node () {} node ( int id , int x ) : id ( id ), x ( x ) {} bool operator < ( const node & other ) const { return x < other . x ; } }; int n , m , top ; int temp [ N ], res [ M ]; int G [ N ][ N ], _G [ N ][ N ]; int id [ N ]; vector < E > Q ; vector < node > vec ; void gao () { // T = 0 <= x for ( int i = 1 ; i <= n ; ++ i ) { vec . push_back ( node ( i , temp [ i ])); } sort ( vec . begin (), vec . end ()); sort ( Q . begin (), Q . end ()); for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { G [ i ][ j ] = _G [ i ][ j ]; } } int pos = -1 ; for ( auto it : Q ) { while ( pos < n - 1 && vec [ pos + 1 ]. x <= id [ it . x ]) { // dbg(pos); pos ++ ; int k = vec [ pos ]. id ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { G [ i ][ j ] = min ( G [ i ][ j ], G [ i ][ k ] + G [ k ][ j ]); } } } if ( it . op == 0 ) res [ it . id ] = G [ it . a ][ it . b ]; } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { G [ i ][ j ] = _G [ i ][ j ]; } } // T = 1 >= x reverse ( vec . begin (), vec . end ()); reverse ( id + 1 , id + 1 + top ); pos = -1 ; for ( auto it : Q ) { // dbg(it.id); while ( pos < n - 1 && vec [ pos + 1 ]. x >= id [ it . x ]) { pos ++ ; int k = vec [ pos ]. id ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { G [ i ][ j ] = min ( G [ i ][ j ], G [ i ][ k ] + G [ k ][ j ]); } } } if ( it . op == 1 ) res [ it . id ] = G [ it . a ][ it . b ]; } } int main () { scanf ( \"%d %d\" , & n , & m ); memset ( _G , INF , sizeof _G ); for ( int i = 1 ; i <= n ; ++ i ) { _G [ i ][ i ] = 0 ; } set < int > se ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , temp + i ); se . insert ( temp [ i ]); } for ( auto it : se ) { id [ ++ top ] = it ; } for ( int i = 1 , u , v , w ; i <= m ; ++ i ) { scanf ( \"%d %d %d\" , & u , & v , & w ); _G [ u ][ v ] = _G [ v ][ u ] = w ; } int q ; scanf ( \"%d\" , & q ); for ( int i = 1 , a , b , x , t ; i <= q ; ++ i ) { scanf ( \"%d %d %d %d\" , & a , & b , & x , & t ); if ( x > top ) x = top ; Q . push_back ( E ( a , b , x , i , t )); } gao (); for ( int i = 1 ; i <= q ; ++ i ) { if ( res [ i ] == INF ) { res [ i ] = -1 ; } printf ( \"%d \\n \" , res [ i ]); } return 0 ; }","title":"I.Interplanetary"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Brazil-Subregional-Programming-Contest/#jjar-of-water-game","text":"Solved By Hsueh-. 2:02(+1) \u9898\u610f\uff1a \u4e00\u4e2a\u6e38\u620f\uff0c\u603b\u5171\u6709 A23456789DJQK \u548c wildcard \uff0c 14 14 \u79cd\u724c\uff0c\u6309\u7167\u89c4\u5219\u95ee\u6700\u540e\u8c01\u8d62\u3002 \u89c4\u5219\u5982\u4e0b\uff1a n n \u4e2a\u4eba\u5750\u6210\u4e00\u5708\uff0c\u7b2c k k \u4e2a\u4eba\u5148\u5f00\u59cb\u3002 \u6bcf\u4e2a\u4eba\u7ed9\u81ea\u5df1\u7684\u4e0b\u4e00\u4f4d\uff0c\u4e5f\u5c31\u662f 1 1 \u7ed9 2 \\cdots 2 \\cdots \u3002 \u5982\u679c\u521a\u62ff\u5230 wildcard \u5219\u4e0d\u80fd\u5c06 wildcard \u7ed9\u4e0b\u4e00\u5bb6,\u5426\u5219\u4e00\u5b9a\u7ed9 wildcard \u3002 \u5426\u5219\u627e\u5230\u6570\u91cf\u6700\u5c0f\u7684\u7ed9\u4e0b\u4e00\u5bb6\u3002 \u5982\u679c\u6709\u591a\u4e2a\u6570\u91cf\u6700\u5c0f\u7684\u5219\u62ff\u51fa\u6570\u5b57\u6700\u4e0b\u7684\u3002 \u5982\u679c\u4e00\u4e2a\u4eba\u624b\u4e0a\u56db\u5f20\u724c\u90fd\u4e00\u6837\u5219\u83b7\u80dc\u3002 \u601d\u8def\uff1a \u6a21\u62df Code #include <bits/stdc++.h> using namespace std ; const int INF = 0x3f3f3f3f ; int get ( char c ) { if ( c == 'A' ) return 1 ; else if ( c == 'D' ) return 10 ; else if ( c == 'Q' ) return 11 ; else if ( c == 'J' ) return 12 ; else if ( c == 'K' ) return 13 ; else return c - '0' ; } struct E { bool First , wildcard ; vector < int > card ; int get () { if ( wildcard ) { if ( First ) { First = false ; } else { wildcard = false ; return -1 ; } } map < int , int > mp ; for ( auto it : card ) { mp [ it ] ++ ; } int Min = INF ; for ( auto it : mp ) { Min = min ( it . second , Min ); } for ( auto it : mp ) { if ( it . second == Min ) { card . erase ( find ( card . begin (), card . end (), it . first )); return it . first ; } } } void insert ( int x ) { if ( x == -1 ) { First = wildcard = true ; } else { card . push_back ( x ); } } } a [ 30 ]; bool win ( int x ) { if ( a [ x ]. wildcard ) return false ; if ( a [ x ]. card [ 0 ] != a [ x ]. card [ 1 ]) return false ; if ( a [ x ]. card [ 1 ] != a [ x ]. card [ 2 ]) return false ; if ( a [ x ]. card [ 2 ] != a [ x ]. card [ 3 ]) return false ; return true ; } int n , k ; int main () { scanf ( \"%d %d\" , & n , & k ); for ( int i = 1 ; i <= n ; ++ i ) { char s [ 10 ]; scanf ( \"%s\" , s + 1 ); a [ i ]. card . clear (); for ( int j = 1 ; j <= 4 ; ++ j ) { a [ i ]. insert ( get ( s [ j ])); } a [ i ]. First = a [ i ]. wildcard = false ; } a [ k ]. First = a [ k ]. wildcard = true ; for ( int i = 1 ; i <= n ; ++ i ) { if ( win ( i )) { printf ( \"%d \\n \" , i ); return 0 ; } } int cur = k ; while ( true ) { int nxt = cur % n + 1 ; a [ nxt ]. insert ( a [ cur ]. get ()); if ( win ( cur )) break ; cur = nxt ; } printf ( \"%d \\n \" , cur ); return 0 ; }","title":"J.Jar of Water Game"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Brazil-Subregional-Programming-Contest/#kkeep-calm-and-sell-balloons","text":"Solved By Dup4 & ltslts. 3:14(+) \u9898\u610f\uff1a \u7ed9\u51fa 2 \\cdot N 2 \\cdot N \u7684\u77e9\u9635\uff0c\u77e9\u9635\u4e0a\u7684\u6570\u5b57\u4ece\u5de6\u5f80\u53f3\uff0c\u4ece\u4e0a\u5230\u4e0b\uff0c\u4f9d\u6b21\u4e3a 1 - 2N 1 - 2N \u3002 \u73b0\u5728\u53ef\u4ee5\u4efb\u9009\u4e00\u4e2a\u8d77\u70b9\u51fa\u53d1\uff0c\u6bcf\u6b21\u53ef\u4ee5\u4e0a\u4e0b\u5de6\u53f3\u5bf9\u89d2\u7ebf\u516b\u4e2a\u65b9\u5411\u8d70\u5230\u76f8\u90bb\u7684\u5e76\u4e14\u6ca1\u6709\u88ab\u8bbf\u95ee\u8fc7\u7684\u70b9\u8d70\uff0c\u95ee\u8bbf\u95ee\u5b8c\u6240\u6709\u70b9\u7684\u65b9\u6848\u6570\u3002 \u601d\u8def\uff1a \u4ee4 f[n] f[n] \u8868\u793a\u4ece 1 1 \u51fa\u53d1\u7684\u65b9\u6848\u6570\u3002 \u90a3\u4e48\u6211\u4eec\u8003\u8651\u600e\u4e48\u9012\u63a8 f[n] f[n] \uff1a \u4ece 1 1 \u51fa\u53d1\uff0c\u5982\u679c\u6700\u7ec8\u56de\u5230 n + 1 n + 1 \uff0c\u90a3\u4e48\u6bcf\u6b21\u5f80\u53f3\u53ef\u4ee5\u9009\u62e9\u8d70\u4e0a\u8fb9\u6216\u8005\u5f80\u4e0b\u8fb9\uff0c\u90a3\u4e48\u56de\u6765\u56de\u5230 n + 1 n + 1 \u7684\u8def\u5f84\u662f\u56fa\u5b9a\u7684\uff0c\u8fd9\u90e8\u5206\u8d21\u732e\u662f 2^{n - 1} 2^{n - 1} \u5982\u679c\u7b2c\u4e8c\u6b65\u8d70 n + 1 n + 1 \uff0c\u90a3\u4e48\u7b2c\u4e09\u6b65\u53ef\u4ee5\u8d70 2 2 \u6216\u8005 n + 2 n + 2 \uff0c\u5bb9\u6613\u53d1\u73b0\u8fd9\u662f\u4e00\u4e2a\u5b50\u95ee\u9898\uff0c\u65b9\u6848\u6570\u4e3a 2f[n - 1] 2f[n - 1] \u3002 \u518d\u8003\u8651\u7b2c\u4e09\u6b65\u8d70 n + 1 n + 1 \uff0c\u90a3\u4e48\u8d70\u6cd5\u662f 1 \\to 2 \\to n + 1 \\to n + 2 1 \\to 2 \\to n + 1 \\to n + 2 \u6216\u8005 1 \\to n + 2 \\to n + 1 \\to 2 1 \\to n + 2 \\to n + 1 \\to 2 \uff0c\u7136\u540e\u5c31\u662f\u4e00\u4e2a n - 2 n - 2 \u89c4\u6a21\u7684\u5b50\u95ee\u9898\uff0c\u8d21\u732e\u662f 4f[n - 2] 4f[n - 2] \u3002 \u6240\u4ee5\u6709\uff1a \\begin{eqnarray*} f[n] = 2f[n - 1] + 4f[n - 2] + 2^{n - 1} \\end{eqnarray*} \\begin{eqnarray*} f[n] = 2f[n - 1] + 4f[n - 2] + 2^{n - 1} \\end{eqnarray*} \u90a3\u4e48\u56db\u4e2a\u89d2\u7684\u8d21\u732e\u5c31\u662f 4f[n] 4f[n] \uff0c\u6211\u4eec\u518d\u8003\u8651\u4e2d\u95f4\u7684\u8d21\u732e\u3002 \u5bb9\u6613\u53d1\u73b0\uff0c\u6211\u4eec\u53d1\u73b0\u4ece\u7b2c\u4e00\u5c42\u7684\u7b2c i i \u5217\u51fa\u53d1\u548c\u4ece\u7b2c\u4e8c\u5c42\u7684\u7b2c i i \u5217\u51fa\u53d1\u7684\u65b9\u6848\u6570\u662f\u76f8\u540c\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u8003\u8651\u7b2c\u4e00\u5c42\u7684\u7b2c i i \u5217\uff1a \u663e\u7136\uff0c\u5b83\u4e0d\u53ef\u80fd\u5728\u7b2c\u4e8c\u6b65\u8d70\u5230 n + i n + i \u3002 \u5047\u8bbe\u5b83\u5f80\u53f3\u8d70\uff0c\u65b9\u6848\u6570\u4e3a 2^{n - i} 2^{n - i} \uff0c\u7136\u540e\u56de\u5230 n + i n + i \u8fd9\u4e2a\u4f4d\u7f6e\uff0c\u518d\u5f80\u5de6\u8fb9\u8d70\uff0c\u8fd9\u90e8\u5206\u7684\u65b9\u6848\u662f f[i - 1] f[i - 1] \uff0c\u6240\u4ee5\u5f80\u53f3\u8d70\u7684\u8d21\u732e\u662f \\displaystyle f[i - 1] \\cdot 2^{n - 1} \\displaystyle f[i - 1] \\cdot 2^{n - 1} \u3002 \u540c\u7406\u53ef\u5f97\uff0c\u5f80\u5de6\u8fb9\u8d70\u7684\u65b9\u6848\u6570\u4e3a f[n - i] \\cdot 2^{i - 1} f[n - i] \\cdot 2^{i - 1} \u3002 \u90a3\u4e48\u7b54\u6848\u5c31\u662f\uff1a \\begin{eqnarray*} f[n] &=& 4f[n - 2] + 2f[n - 1] + 2^{n - 1} \\\\ ans &=& 4(f[n] + \\sum\\limits_{i = 2}^{n - 1} (f[i - 1] \\cdot 2^{n - i} + f[n - i] \\cdot 2^{i - 1}) ) \\end{eqnarray*} \\begin{eqnarray*} f[n] &=& 4f[n - 2] + 2f[n - 1] + 2^{n - 1} \\\\ ans &=& 4(f[n] + \\sum\\limits_{i = 2}^{n - 1} (f[i - 1] \\cdot 2^{n - i} + f[n - i] \\cdot 2^{i - 1}) ) \\end{eqnarray*} \u4ee4 \\displaystyle g[n] = \\sum\\limits_{i = 2}^{n - 1} f[i - 1] \\cdot 2^{n - i} \\displaystyle g[n] = \\sum\\limits_{i = 2}^{n - 1} f[i - 1] \\cdot 2^{n - i} \uff0c\u6709 \\begin{eqnarray*} g[n] = g[n - 1] \\cdot 2 + f[n - 2] \\cdot 2 \\end{eqnarray*} \\begin{eqnarray*} g[n] = g[n - 1] \\cdot 2 + f[n - 2] \\cdot 2 \\end{eqnarray*} \u4ee4 \\displaystyle h[n] = \\sum\\limits_{i = 2}^{n - 1} f[n - i] \\cdot 2^{i - 1} \\displaystyle h[n] = \\sum\\limits_{i = 2}^{n - 1} f[n - i] \\cdot 2^{i - 1} \uff0c\u6709 \\begin{eqnarray*} h[n] = h[n - 1] \\cdot 2 + f[n - 2] \\cdot 2 \\end{eqnarray*} \\begin{eqnarray*} h[n] = h[n - 1] \\cdot 2 + f[n - 2] \\cdot 2 \\end{eqnarray*} \u5bb9\u6613\u53d1\u73b0 g[n] g[n] \u548c h[n] h[n] \u662f\u4e00\u6837\u7684\uff0c\u76f4\u63a5\u77e9\u9635\u5feb\u901f\u5e42\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using ll = long long ; using namespace std ; const int mod = 1e9 + 7 ; int n ; inline void chadd ( ll & x , ll y ) { x += y ; while ( x >= mod ) x -= mod ; while ( x < 0 ) x += mod ; } struct node { ll a [ 4 ][ 4 ]; node () {} ll * operator []( int x ) { return a [ x ]; } void init () { memset ( a , 0 , sizeof a ); } node operator * ( const node & other ) const { node res = node (); res . init (); for ( int i = 0 ; i < 4 ; ++ i ) { for ( int j = 0 ; j < 4 ; ++ j ) { for ( int k = 0 ; k < 4 ; ++ k ) { chadd ( res . a [ i ][ j ], a [ i ][ k ] * other . a [ k ][ j ] % mod ); } } } return res ; } }; node qpow ( node base , node res , ll n ) { while ( n ) { if ( n & 1 ) res = res * base ; base = base * base ; n >>= 1 ; } return res ; } ll gao () { if ( n == 1 ) return 2 ; if ( n == 2 ) return 24 ; node base = node (); base . init (); base [ 0 ][ 0 ] = 6 , base [ 0 ][ 1 ] = 1 , base [ 0 ][ 2 ] = 0 , base [ 0 ][ 3 ] = 4 ; node res = node (); res . init (); res [ 0 ][ 0 ] = 2 , res [ 0 ][ 1 ] = 1 ; res [ 1 ][ 0 ] = 4 , res [ 1 ][ 2 ] = 2 ; res [ 2 ][ 2 ] = 2 ; res [ 3 ][ 0 ] = 1 , res [ 3 ][ 3 ] = 2 ; swap ( res , base ); res = qpow ( base , res , n - 2 ); return 4l l * ( res [ 0 ][ 0 ] + 2l l * res [ 0 ][ 2 ] % mod ) % mod ; } int main () { scanf ( \"%d\" , & n ); ll res = gao (); res = ( res % mod + mod ) % mod ; printf ( \"%lld \\n \" , res ); return 0 ; }","title":"K.Keep Calm and Sell Balloons"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Brazil-Subregional-Programming-Contest/#lless-coin-tosses","text":"Solved By Dup4 & ltslts. 1:07(+) \u9898\u610f\uff1a \u6709\u4e00\u4e2a\u786c\u5e01\uff0c\u5b83\u4e0d\u662f\u516c\u5e73\u7684\uff0c\u5373\u63b7\u51fa\u6b63\u9762\u548c\u53cd\u9762\u7684\u6982\u7387\u4e0d\u540c\u3002 \u73b0\u5728\u4e3a\u4e86\u516c\u5e73\uff0c\u6709\u5982\u4e0b\u7b56\u7565\uff1a \u9009\u4e00\u4e2a n n \u3002 \u90a3\u4e48\u6709 2^n 2^n \u4e2a 01\u4e32 \uff0cAlice \u62ff\u4e00\u90e8\u5206\uff0cBob \u62ff\u4e00\u90e8\u5206\uff0c\u5269\u4e0b\u7684\u820d\u5f03\uff0c\u7136\u540e\u5c06\u8be5\u786c\u5e01\u6295\u63b7 n n \u6b21\uff0c\u6839\u636e\u63b7\u51fa\u7684\u6b63\u53cd\u9762\u5f62\u6210\u4e00\u4e2a\u957f\u5ea6\u4e3a n n \u7684 01\u4e32 \uff0c\u5982\u679c\u8be5\u4e32\u5728 Alice \u90a3\u90e8\u5206\u4e2d\uff0cAlice \u83b7\u80dc\uff0c\u5982\u679c\u5728 Bob \u90a3\u90e8\u5206\u4e2d\uff0cBob \u83b7\u80dc\uff0c\u5426\u5219\u518d\u6765\u4e00\u6b21\u3002 \u73b0\u5728\u7ed9\u5b9a n n \uff0c\u73b0\u5728\u95ee\u6700\u5c11\u820d\u5f03\u591a\u5c11 01\u4e32 \uff0c\u4f7f\u5f97\u8be5\u73a9\u6cd5\u662f\u516c\u5e73\u7684\u3002 \u601d\u8def\uff1a \u6211\u4eec\u5047\u8bbe\u6295\u51fa\u6b63\u9762\u7684\u6982\u7387\u4e3a x x \uff0c\u6295\u51fa\u53cd\u9762\u7684\u6982\u7387\u4e3a y y \uff0c\u5047\u8bbe\u4e00\u4e2a\u957f\u5ea6\u4e3a n n \u7684\u5b57\u7b26\u4e32\u4e2d\u6709 a a \u4e2a 0\uff0c\u6709 b b \u4e2a 1\uff0c\u90a3\u4e48\u63b7\u51fa\u8be5 01\u4e32 \u7684\u6982\u7387\u4e3a x^a \\cdot y^b x^a \\cdot y^b \u3002 \u90a3\u4e48\u53ef\u4ee5\u6839\u636e (a, b) (a, b) \u8fd9\u4e2a\u4e8c\u5143\u7ec4\uff0c\u5c06\u6240\u6709 01\u4e32 \u8fdb\u884c\u5206\u7c7b\uff0c\u540c\u7c7b\u7684\u5747\u5206\u7ed9\u4e24\u4eba\uff0c\u90a3\u4e48\u5bb9\u6613\u53d1\u73b0\uff0c\u5982\u679c\u67d0\u7c7b\u5b57\u7b26\u4e32\u662f\u5947\u6570\u4e2a\uff0c\u90a3\u4e48\u5fc5\u7136\u8981\u7559\u4e0b\u4e00\u4e2a\u3002 \u6240\u4ee5\u7b54\u6848\u5c31\u662f \\displaystyle \\sum\\limits_{i = 0}^n {n \\choose i} \\% 2 = 2^p \\displaystyle \\sum\\limits_{i = 0}^n {n \\choose i} \\% 2 = 2^p \uff0c\u5176\u4e2d p p \u4e3a n n \u7684\u4e8c\u8fdb\u5236\u8868\u793a\u4e2d 1 1 \u7684\u4e2a\u6570\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; int main () { ll n ; cin >> n ; cout << ( 1l l << __builtin_popcountll ( n )) << \" \\n \" ; return 0 ; }","title":"L.Less Coin Tosses"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Brazil-Subregional-Programming-Contest/#mmaratona-brasileira-de-popcorn","text":"Solved By Dup4. 0:33(+) \u9898\u610f\uff1a \u6709 n n \u888b\u7206\u7c73\u82b1\uff0c\u6bcf\u888b\u6709 p_i p_i \u4e2a\u7206\u7c73\u82b1\uff0c\u6709 C C \u4e2a\u4eba\uff0c\u6bcf\u4e2a\u4eba\u6bcf\u79d2\u949f\u80fd\u591f\u5403 T T \u4e2a\u7206\u7c73\u82b1\u3002 \u73b0\u5728\u6709\u4e24\u4e2a\u9650\u5236\u6761\u4ef6\uff1a \u6bcf\u4e2a\u4eba\u53ea\u80fd\u5403\u4e00\u6bb5\u888b\u5b50\u6807\u53f7\u8fde\u7eed\u7684\u7206\u7c73\u82b1 \u540c\u4e00\u888b\u91cc\u7684\u7206\u7c73\u82b1\u53ea\u80fd\u88ab\u540c\u4e00\u4e2a\u4eba\u5403 \u95ee\u6700\u5c11\u9700\u8981\u591a\u5c11\u65f6\u95f4\uff0c\u4f7f\u5f97\u7206\u7c73\u82b1\u80fd\u88ab\u5403\u5b8c\u3002 \u601d\u8def\uff1a \u4e8c\u5206\u65f6\u95f4\uff0c\u8d2a\u5fc3 check\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 ; int n , m , T , a [ N ]; int calc ( int x ) { int tot = x * T ; int res = 1 , sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( a [ i ] > tot ) return 1e9 ; if ( a [ i ] + sum <= tot ) { sum += a [ i ]; } else { sum = a [ i ]; ++ res ; } } return res ; } int main () { scanf ( \"%d%d%d\" , & n , & m , & T ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ); int l = 1 , r = 1e9 / T + 5 , res = 1e9 ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( calc ( mid ) <= m ) { r = mid - 1 ; res = mid ; } else { l = mid + 1 ; } } printf ( \"%d \\n \" , res ); return 0 ; }","title":"M.Maratona Brasileira de Popcorn"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Latin-American-Regional-Programming-Contest/","text":"2019-2020 ACM-ICPC Latin American Regional Programming Contest Contents Contest Info Solutions A. Algorithm Teaching B. Build the Perfect House C. Cut Inequality Down D. Dazzling stars E. Eggfruit Cake F. Fabricating Sculptures G. Gluing Pictures H. Hold or Continue? I. Improve SPAM J. Jumping Grasshoper K. Know your Aliens L. Leverage MDT M. Mountain Ranges Contest Info Practice Link Solved A B C D E F G H I J K L M 9/13 - - \u00d8 O O - O \u00d8 O - O O O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5 Solutions A. Algorithm Teaching UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a B. Build the Perfect House UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a C. Cut Inequality Down UpSolved by Dup4. \u9898\u610f\uff1a \u6709\u4e00\u4e2a\u5e8f\u5217 a_i a_i \uff0c\u957f\u5ea6\u4e3a n n \uff0c\u548c\u4e24\u4e2a\u53c2\u6570 L, U L, U \uff0c\u73b0\u5728\u6bcf\u6b21\u8be2\u95ee\u7ed9\u51fa B, E, X B, E, X \uff0c\u8981\u6c42\u4f5c\u5982\u4e0b\u64cd\u4f5c\uff1a \u4ee4 i i \u4ece B B \u904d\u5386\u5230 E E \u3002 \u7136\u540e\u4ee4 \\displaystyle X = max(L, min(R, X + a_i)) \\displaystyle X = max(L, min(R, X + a_i)) \u3002 \u8f93\u51fa\u6700\u540e\u7684 X X \u3002 \u601d\u8def\uff1a \u8003\u8651\u5bf9\u4e8e\u6bcf\u4e00\u6b21\u67e5\u8be2\uff0c\u53ef\u4ee5 O(\\log n) O(\\log n) \u7684\u65f6\u95f4\u627e\u5230\u4e0b\u4e00\u4e2a\u53d8\u5316\u7684\u70b9\uff0c\u90a3\u4e48\u4ece\u4e0b\u4e00\u4e2a\u53d8\u5316\u7684\u70b9\u5f00\u59cb\u5f80\u4e0b\u8d70\uff0c\u90a3\u4e48\u5bb9\u6613\u53d1\u73b0\u4ece\u4e0b\u4e00\u4e2a\u53d8\u5316\u7684\u70b9\u5f00\u59cb\u8d70\u7684\u521d\u59cb\u503c\u8981\u4e48\u662f L L \uff0c\u8981\u4e48\u662f U U \uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5c06\u6bcf\u4e2a a_i a_i \u62c6\u6210\u4e24\u4e2a\u70b9\uff0c\u4e00\u4e2a\u662f\u8d77\u59cb\u503c\u4e3a L L \uff0c\u4ece\u7b2c i i \u4e2a\u70b9\u5f00\u59cb\u5f80\u4e0b\u8d70\uff0c\u4e00\u4e2a\u662f\u8d77\u59cb\u503c\u4e3a U U \uff0c\u4ece\u7b2c i i \u4e2a\u70b9\u5f00\u59cb\u5f80\u4e0b\u8d70\uff0c\u53d1\u73b0\u4f1a\u5f62\u6210\u6811\u5f62\u7ed3\u6784\u3002 \u90a3\u4e48\u6211\u4eec\u6bcf\u6b21\u4ece\u521d\u59cb\u503c\u627e\u5230\u7b2c\u4e00\u4e2a\u53d8\u5316\u7684\u70b9\u4e4b\u540e\u76f4\u63a5\u5728\u6811\u4e0a\u500d\u589e\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; using pII = pair < int , int > ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } #define fi first #define se second #define SZ(x) (int(x.size())) const int N = 1e5 + 10 , M = 20 ; const ll INFLL = 1e18 ; int n , L , R , q , a [ N ]; // 0 L 1 R ll S [ N ]; vector < vector < int >> G ; struct RMQ { ll Max [ N ][ M ]; ll Min [ N ][ M ]; int mm [ N ]; void init ( int n , ll * b ) { mm [ 0 ] = -1 ; for ( int i = 1 ; i <= n ; ++ i ) { mm [ i ] = (( i & ( i - 1 )) == 0 ) ? mm [ i - 1 ] + 1 : mm [ i - 1 ]; Max [ i ][ 0 ] = b [ i ]; Min [ i ][ 0 ] = b [ i ]; } for ( int j = 1 ; j <= mm [ n ]; ++ j ) { for ( int i = 1 ; i + ( 1 << j ) - 1 <= n ; ++ i ) { Max [ i ][ j ] = max ( Max [ i ][ j - 1 ], Max [ i + ( 1 << ( j - 1 ))][ j - 1 ]); Min [ i ][ j ] = min ( Min [ i ][ j - 1 ], Min [ i + ( 1 << ( j - 1 ))][ j - 1 ]); } } } ll queryMax ( int x , int y ) { int k = mm [ y - x + 1 ]; return max ( Max [ x ][ k ], Max [ y - ( 1 << k ) + 1 ][ k ]); } ll queryMin ( int x , int y ) { int k = mm [ y - x + 1 ]; return min ( Min [ x ][ k ], Min [ y - ( 1 << k ) + 1 ][ k ]); } int queryL ( int x , ll ini ) { int l = x , r = n , res = n ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( ini + queryMin ( x , mid ) - S [ x - 1 ] <= L ) { res = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return res + 1 ; } int queryR ( int x , ll ini ) { int l = x , r = n , res = n ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( ini + queryMax ( x , mid ) - S [ x - 1 ] >= R ) { res = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return res + 1 ; } } rmq ; void addEdge ( int ini , int id ) { int nl = rmq . queryL ( id / 2 , ini ); int nr = rmq . queryR ( id / 2 , ini ); if ( nl < nr ) { // dbg(nl * 2, id); G [ nl * 2 ]. push_back ( id ); } else { // dbg(nr * 2 + 1, id); G [ nr * 2 + 1 ]. push_back ( id ); } } int fa [ M ][ N * 2 + 10 ]; void dfs ( int u ) { for ( int i = 1 ; i < M ; ++ i ) fa [ i ][ u ] = fa [ i - 1 ][ fa [ i - 1 ][ u ]]; for ( auto & v : G [ u ]) { fa [ 0 ][ v ] = u ; dfs ( v ); } } ll get ( int u , int E ) { // dbg(u, E); for ( int i = M - 1 ; i >= 0 ; -- i ) { if ( fa [ i ][ u ] / 2 <= E ) u = fa [ i ][ u ]; } // dbg(u, E); ll ans = u % 2 ? R : L ; ans += S [ E ] - S [ u / 2 - 1 ]; if ( ans > R ) ans = R ; if ( ans < L ) ans = L ; return ans ; } int main () { scanf ( \"%d%d%d\" , & n , & L , & R ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ), S [ i ] = S [ i - 1 ] + a [ i ]; rmq . init ( n , S ); G . clear (); G . resize ( n * 2 + 20 ); for ( int i = 1 ; i <= n ; ++ i ) { addEdge ( L , 2 * i ); addEdge ( R , 2 * i + 1 ); } fa [ 0 ][ 2 * ( n + 1 )] = 2 * ( n + 1 ); fa [ 0 ][ 2 * ( n + 1 ) + 1 ] = 2 * ( n + 1 ) + 1 ; dfs ( 2 * ( n + 1 )); dfs ( 2 * ( n + 1 ) + 1 ); scanf ( \"%d\" , & q ); for ( int i = 1 , B , E , X ; i <= q ; ++ i ) { scanf ( \"%d%d%d\" , & B , & E , & X ); int nl = rmq . queryL ( B , X ); int nr = rmq . queryR ( B , X ); if ( min ( nl , nr ) - 1 >= E ) { ll ans = S [ E ] - S [ B - 1 ] + X ; if ( ans > R ) ans = R ; if ( ans < L ) ans = L ; printf ( \"%lld \\n \" , ans ); } else { int id ; if ( nl < nr ) id = nl * 2 ; else id = nr * 2 + 1 ; printf ( \"%lld \\n \" , get ( id , E )); } } return 0 ; } D. Dazzling stars Solved By Hsueh-. 3:47(+1) \u9898\u610f\uff1a \u6709 n \u4e2a\u661f\u661f\uff0c\u6bcf\u4e2a\u661f\u661f\u6709\u5750\u6807\u548c\u4eae\u5ea6\uff0c\u95ee\u662f\u5426\u5b58\u5728\u4e00\u4e2a\u65b9\u5411\uff0c\u4f7f\u5f97\u8fd9\u4e2a\u65b9\u5411\u8fc7\u6765\u4eae\u5ea6\u4ece\u9ad8\u5230\u4f4e\u9012\u51cf\u3002 \u601d\u8def\uff1a \u5904\u7406\u51fa\u6bcf\u5bf9\u4ece\u4eae\u7684\u5230\u6697\u7684\u65b9\u5411\u5411\u91cf\u8303\u56f4\uff0c\u770b\u6709\u6ca1\u6709\u4ea4\u96c6\u3002 Code #include <bits/stdc++.h> using namespace std ; using db = double ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const db PI = acos ( -1.0 ), eps = 1e-8 ; const int N = 2e3 + 10 ; int sgn ( db x ) { if ( fabs ( x ) < eps ) return 0 ; else return x > 0 ? 1 : -1 ; } struct Point { int x , y ; Point () {} Point ( int x , int y ) : x ( x ), y ( y ) {} Point operator - ( const Point & other ) const { return { x - other . x , y - other . y }; } Point rot () { return { - y , x }; } } a [ N ]; struct node { Point p ; int val , id ; db arc ; bool operator < ( const node & other ) const { if ( sgn ( arc - other . arc ) == 0 ) return val > other . val ; else return arc < other . arc ; } }; int n , tot ; vector < node > vec ; int b [ N ]; int add [ N * N ]; int l [ N * N ], r [ N * N ]; bool ok () { if ( vec . empty ()) return true ; for ( auto & it : vec ) { it . arc = atan2 ( it . p . y , it . p . x ); } sort ( vec . begin (), vec . end ()); for ( int i = 0 , len = vec . size (); i < len ; ++ i ) { if ( vec [ i ]. val == 1 ) l [ vec [ i ]. id ] = i ; else r [ vec [ i ]. id ] = i ; } for ( int i = 0 ; i < tot ; ++ i ) { if ( l [ i ] < r [ i ]) { add [ l [ i ]] ++ ; add [ r [ i ] + 1 ] -- ; } else { add [ l [ i ]] ++ ; add [ 0 ] ++ ; add [ r [ i ] + 1 ] -- ; } } int cnt = 0 ; for ( int i = 0 ; i < 2 * tot ; ++ i ) { cnt += add [ i ]; if ( cnt == tot ) return true ; } return false ; } void push ( Point a , Point b ) { vec . push_back ({( a - b ). rot (), -1 , tot }); vec . push_back ({( b - a ). rot (), 1 , tot }); tot ++ ; } int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d %d %d\" , & a [ i ]. x , & a [ i ]. y , & b [ i ]); } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j < i ; ++ j ) { if ( b [ i ] == b [ j ]) continue ; if ( b [ i ] > b [ j ]) { push ( a [ i ], a [ j ]); } else { push ( a [ j ], a [ i ]); } } } if ( ok ()) puts ( \"Y\" ); else puts ( \"N\" ); return 0 ; } E. Eggfruit Cake Solved By Dup4. 0:14(+) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32\u73af\uff0c\u91cc\u9762\u53ea\u6709 E \u548c P \u4e24\u79cd\u5b57\u7b26\uff0c\u73b0\u5728\u95ee\u6709\u591a\u5c11\u533a\u95f4\uff0c\u6ee1\u8db3\u8fd9\u4e2a\u533a\u95f4\u957f\u5ea6\u5c0f\u4e8e\u7b49\u4e8e S S \uff0c\u5e76\u4e14\u91cc\u9762\u81f3\u5c11\u6709\u4e00\u4e2a E \u3002 \u601d\u8def\uff1a \u590d\u5236\u4e00\u904d\uff0c\u62d3\u5c55\u6210 2n 2n \uff0c\u7136\u540e\u626b\u4e00\u904d\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 2e5 + 10 ; int n , S ; char s [ N ]; int main () { scanf ( \"%s%d\" , s + 1 , & S ); n = strlen ( s + 1 ); for ( int i = 1 ; i <= n ; ++ i ) s [ i + n ] = s [ i ]; int pre = 0 ; for ( int i = 1 ; i <= n ; ++ i ) if ( s [ i ] == 'E' ) pre = i ; ll res = 0 ; for ( int i = n + 1 ; i <= n * 2 ; ++ i ) { if ( s [ i ] == 'E' ) pre = i ; int last = i - S ; res += max ( 0 , pre - last ); } printf ( \"%lld \\n \" , res ); return 0 ; } F. Fabricating Sculptures UpSolved by Dup4. \u9898\u610f\uff1a \u5806\u7bb1\u5b50\uff0c\u6700\u5e95\u5c42\u6709 S S \u4e2a\uff0c\u4e00\u5171\u6709 B B \u4e2a\u7bb1\u5b50\uff0c\u4e00\u5c42\u4e00\u5c42\u5f80\u4e0a\u5806\uff0c\u6bcf\u4e00\u5c42\u5fc5\u987b\u8fde\u7eed\uff0c\u4e14\u4e2a\u6570\u4e0d\u8d85\u8fc7\u4e4b\u524d\u90a3\u4e00\u5c42\uff0c\u5e76\u4e14\u5f53\u524d\u5c42\u7684\u7bb1\u5b50\u5fc5\u987b\u90fd\u8981\u4e0a\u4e00\u5c42\u7684\u7bb1\u5b50\u4e4b\u4e0a\u3002 \u601d\u8def\uff1a f[i][j] f[i][j] \u8868\u793a\u7528\u4e86 i i \u4e2a\u7bb1\u5b50\uff0c\u6700\u4e0a\u5c42\u6709 j j \u4e2a\uff0c\u90a3\u4e48\u8f6c\u79fb\u6709\uff1a f[i][j] = \\sum\\limits_{k = j}^S f[i - k][k] \\cdot (k - j + 1) f[i][j] = \\sum\\limits_{k = j}^S f[i - k][k] \\cdot (k - j + 1) \u7136\u540e\u7ef4\u62a4 f[i][j] \\cdot j f[i][j] \\cdot j \u4ee5\u53ca f[i][j] f[i][j] \u7684\u540e\u7f00\u548c\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int mod = 1e9 + 7 ; const int N = 5e3 + 10 ; int n , S , B ; ll f [ N ][ N ], g [ N ][ N ], h [ N ][ N ]; // f[i][j] \u7528\u4e86i\u4e2a \u6700\u4e0a\u9762\u4e00\u5c42\u6709j \u4e2a\u7684\u65b9\u6848\u6570 int main () { scanf ( \"%d%d\" , & S , & B ); memset ( f , 0 , sizeof f ); memset ( g , 0 , sizeof g ); memset ( h , 0 , sizeof h ); f [ S ][ S ] = 1 ; for ( int i = S ; i >= 1 ; -- i ) { g [ S ][ i ] = ( g [ S ][ i + 1 ] + f [ S ][ i ]) % mod ; h [ S ][ i ] = ( h [ S ][ i + 1 ] + f [ S ][ i ] * i % mod ) % mod ; } for ( int i = S + 1 ; i <= B ; ++ i ) { for ( int j = 1 ; j <= S ; ++ j ) { f [ i ][ j ] = 1l l * ( 1 - j + mod ) % mod * ( g [ i - j ][ j ] - g [ i - j ][ S + 1 ] + mod ) % mod ; f [ i ][ j ] = ( f [ i ][ j ] + ( h [ i - j ][ j ] - h [ i - j ][ S + 1 ] + mod ) % mod ) % mod ; // if (f[i][j]) dbg(i, j, f[i][j]); } for ( int j = S ; j >= 1 ; -- j ) { g [ i ][ j ] = ( g [ i ][ j + 1 ] + f [ i ][ j ]) % mod ; h [ i ][ j ] = ( h [ i ][ j + 1 ] + f [ i ][ j ] * j % mod ) % mod ; } } ll res = 0 ; for ( int i = 1 ; i <= S ; ++ i ) { res = ( res + f [ B ][ i ]) % mod ; } printf ( \"%lld \\n \" , res ); return 0 ; } G. Gluing Pictures Solved By Dup4. 0:54(+) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32 S S \uff0c\u6709 q q \u6b21\u8be2\u95ee\uff0c\u6bcf\u6b21\u8be2\u95ee\u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32 T T \uff0c\u95ee T T \u6700\u5c11\u80fd\u5206\u6210\u591a\u5c11\u6bb5\uff0c\u4f7f\u5f97\u6bcf\u6bb5\u90fd\u662f S S \u7684\u4e00\u4e2a\u5b50\u4e32\u3002 \u601d\u8def\uff1a \u8003\u8651 f[i] f[i] \u8868\u793a T T \u4e2d\u7684\u524d i i \u4e2a\u5b57\u7b26\u6700\u5c11\u9700\u8981\u591a\u5c11\u6bb5\uff0c\u663e\u7136 f f \u5177\u6709\u5355\u8c03\u4e0d\u51cf\u6027\u8d28\u3002 \u7136\u540e\u6211\u4eec\u5bf9 S S \u5efa SAM \uff0c\u7136\u540e\u7528 T T \u5728 SAM \u4e0a\u8dd1\u5339\u914d\uff0c\u5982\u679c\u4e0d\u80fd\u5f80\u4e0b\u62d3\u5c55\u4e86\u5c31\u8df3\u540e\u7f00\uff0c\u7ef4\u62a4\u5f53\u524d\u5339\u914d\u7684\u6700\u957f\u540e\u7f00\u957f\u5ea6\uff0c\u8fdb\u884c\u8f6c\u79fb\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 2e5 + 10 , ALP = 26 ; int n , q , f [ N ]; char s [ N ], t [ N ]; struct SAM { struct node { int maxlen , cnt , fa , nx [ ALP ]; void init () { maxlen = cnt = fa = 0 ; memset ( nx , 0 , sizeof nx ); } } t [ N << 1 ]; int tot , lst ; int newnode () { ++ tot ; t [ tot ]. init (); return tot ; } void init () { tot = 0 ; lst = newnode (); } void extend ( int id ) { int cur = newnode (), p ; t [ cur ]. cnt = 1 ; t [ cur ]. maxlen = t [ lst ]. maxlen + 1 ; for ( p = lst ; p && ! t [ p ]. nx [ id ]; p = t [ p ]. fa ) t [ p ]. nx [ id ] = cur ; if ( ! p ) { t [ cur ]. fa = 1 ; } else { int q = t [ p ]. nx [ id ]; if ( t [ q ]. maxlen == t [ p ]. maxlen + 1 ) { t [ cur ]. fa = q ; } else { int clone = newnode (); t [ clone ] = t [ q ]; t [ clone ]. cnt = 0 ; t [ clone ]. maxlen = t [ p ]. maxlen + 1 ; for (; p && t [ p ]. nx [ id ] == q ; p = t [ p ]. fa ) t [ p ]. nx [ id ] = clone ; t [ cur ]. fa = t [ q ]. fa = clone ; } } lst = cur ; } void build ( char * s ) { init (); for ( int i = 1 ; s [ i ]; ++ i ) { extend ( s [ i ] - 'A' ); } } int solve ( char * s ) { int len = strlen ( s + 1 ); memset ( f , -1 , sizeof ( f [ 0 ]) * ( len + 5 )); f [ 0 ] = 0 ; int cur = 1 ; int curlen = 0 ; for ( int i = 1 ; i <= len ; ++ i ) { while ( cur && t [ cur ]. nx [ s [ i ] - 'A' ] == 0 ) { cur = t [ cur ]. fa ; curlen = min ( curlen , t [ cur ]. maxlen ); } if ( cur == 0 ) return -1 ; cur = t [ cur ]. nx [ s [ i ] - 'A' ]; ++ curlen ; f [ i ] = f [ i - curlen ] + 1 ; } return f [ len ]; } } sam ; int main () { scanf ( \"%s\" , s + 1 ); scanf ( \"%d\" , & q ); sam . build ( s ); while ( q -- ) { scanf ( \"%s\" , t + 1 ); printf ( \"%d \\n \" , sam . solve ( t )); } return 0 ; } H. Hold or Continue? UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a I. Improve SPAM Solved By Hsueh-. 1:00(+) \u9898\u610f\uff1a \u7ed9\u5b9a\u4e00\u4e2a DAG \u7684 SPAM\uff0c\u5176\u4e2d\u6709 L \u4e2a\u90ae\u4ef6\u5217\u8868\uff0c n n \u4e2a\u5ba2\u6237\uff0c\u90ae\u4ef6\u5217\u8868\u4f1a\u50cf\u91cc\u9762\u7684\u90ae\u4ef6\u5ba2\u6237\u7aef\u7684\u4eba\u53d1\u90ae\u4ef6\uff0c\u95ee\u4ece 1 \u5f00\u59cb\u53d1\u90ae\u4ef6\uff0c\u7528\u6237\u5ba2\u6237\u7aef\u4f1a\u6536\u5230\u591a\u5c11\u90ae\u4ef6\uff0c\u6709\u591a\u5c11\u7528\u6237\u6536\u5230\u90ae\u4ef6\u3002 \u601d\u8def\uff1a \u641c\u7d22\u6c34\u9898\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 2e3 + 10 ; const ll p = 1e9 + 7 ; int n , l ; vector < vector < int >> G ; ll f [ N ]; int vis [ N ]; ll gao ( int u ) { if ( vis [ u ]) return f [ u ]; vis [ u ] = 1 ; if ( u > l ) f [ u ] = 1 ; for ( auto v : G [ u ]) { f [ u ] = ( f [ u ] + gao ( v )) % p ; } return f [ u ]; } int main () { scanf ( \"%d %d\" , & n , & l ); G . clear (); G . resize ( n + 1 ); for ( int i = 1 , m ; i <= l ; ++ i ) { scanf ( \"%d\" , & m ); for ( int j = 1 , x ; j <= m ; ++ j ) { scanf ( \"%d\" , & x ); G [ i ]. push_back ( x ); } } ll res1 = gao ( 1 ), res2 = 0 ; for ( int i = l + 1 ; i <= n ; ++ i ) { res2 += vis [ i ]; } printf ( \"%lld %lld \\n \" , res1 , res2 ); return 0 ; } J. Jumping Grasshoper UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a K. Know your Aliens Solved By Dup4. 1:23(+) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e3a n n \u7684\u5b57\u7b26\u4e32 S S \uff0c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709 H \u548c A \u4e24\u79cd\u5b57\u7b26\u3002 \u73b0\u5728\u8981\u6784\u9020\u4e00\u4e2a\u591a\u9879\u5f0f P P \uff0c\u5bf9\u4e8e\u7b2c i i \u4e2a\u5b57\u7b26\uff1a \u5982\u679c\u662f H \uff0c\u90a3\u4e48\u8981\u6ee1\u8db3 P(2i) > 0 P(2i) > 0 \u3002 \u5982\u679c\u662f A \uff0c\u90a3\u4e48\u8981\u6ee1\u8db3 P(2i) < 0 P(2i) < 0 \u3002 \u8fd9\u4e2a\u591a\u9879\u5f0f\u8981\u6ee1\u8db3\u7cfb\u6570\u548c\u6839\u5747\u4e3a\u6574\u6570\uff0c\u6700\u9ad8\u9879\u7cfb\u6570\u53ea\u80fd\u4e3a 1 1 \u548c -1 -1 \uff0c\u5e76\u4e14\u5728\u6240\u6709\u53ef\u884c\u7b54\u6848\u4e2d\u6700\u9ad8\u9879\u8981\u5c3d\u53ef\u80fd\u5c0f\u3002 \u601d\u8def\uff1a \u8003\u8651\u5c06\u591a\u9879\u5f0f\u5199\u6210 \\prod (a_i - x) \\prod (a_i - x) \u7684\u5f62\u5f0f\uff0c\u90a3\u4e48\u5982\u679c P(2i) < 0 P(2i) < 0 \uff0c\u5373\u6709\u5947\u6570\u4e2a\u5c0f\u4e8e 0 0 \u7684\u6570\u76f8\u4e58\uff0c\u5426\u5219\u662f\u5076\u6570\u4e2a\u3002 \u90a3\u4e48\u8003\u8651\u5b57\u7b26\u4e32\u4e2d\u6bcf\u4e2a H \u548c A \u7684\u53d8\u6362\u7684\u5730\u65b9\uff0c\u5047\u8bbe\u7b2c i i \u548c\u7b2c i + 1 i + 1 \u4e2a\u5b57\u7b26\u4e0d\u540c\uff0c\u90a3\u4e48\u6211\u4eec\u5728\u591a\u9879\u5f0f\u4e2d\u63d2\u5165 (i \\cdot 2 + 1 - x) (i \\cdot 2 + 1 - x) \uff0c\u5373\u53ef\u7b26\u5408\u9898\u610f\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define SZ(x) (int((x).size())) const int N = 1e4 + 10 ; char s [ N ]; int n ; vector < ll > vec ; void gao ( ll x ) { ll t = vec . back (); for ( int i = SZ ( vec ) - 2 ; i >= 0 ; -- i ) { vec [ i + 1 ] = vec [ i + 1 ] * x - vec [ i ]; } vec [ 0 ] *= x ; vec . push_back ( - t ); } int main () { scanf ( \"%s\" , s + 1 ); n = strlen ( s + 1 ); if ( s [ 1 ] == 'H' ) vec . push_back ( 1 ); else vec . push_back ( -1 ); for ( int i = 2 ; i <= n ; ++ i ) { if ( s [ i ] != s [ i - 1 ]) { // cout << (i - 1) * 2 + 1 << endl; gao (( i - 1 ) * 2 + 1 ); } } reverse ( vec . begin (), vec . end ()); printf ( \"%d \\n \" , SZ ( vec ) - 1 ); for ( int i = 0 ; i < SZ ( vec ); ++ i ) printf ( \"%lld%c\" , vec [ i ], \" \\n \" [ i == SZ ( vec ) - 1 ]); return 0 ; } L. Leverage MDT Solved By Hsueh-. 1:42(+) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a 01 \u4e8c\u7ef4\u77e9\u9635\uff0c\u6bcf\u6b21\u53ef\u4ee5\u5c06\u67d0\u4e00\u884c\u7684\u72b6\u6001\u7ffb\u8f6c\uff0c\u95ee\u4efb\u610f\u7ffb\u8f6c\u540e\uff0c\u80fd\u5426\u627e\u4e00\u4e2a\u6700\u5927\u7684\u6b63\u65b9\u5f62\uff0c\u4f7f\u5f97\u6b63\u65b9\u5f62\u5185\u5168\u662f 0 0 \uff0c\u95ee\u6700\u5927\u7684\u6b63\u65b9\u5f62\u9762\u79ef\u662f\u591a\u5c11\u3002 \u601d\u8def\uff1a \u9898\u610f\u7b49\u4ef7\u4e8e\u627e\u4e00\u4e2a\u6700\u5927\u7684\u6b63\u65b9\u5f62\uff0c\u4f7f\u5f97\u6b63\u65b9\u5f62\u5185\u6bcf\u4e00\u884c\u5143\u7d20\u4e00\u81f4\u3002 \u5148\u5bf9\u6bcf\u4e00\u884c\u5904\u7406\u51fa\u5f53\u524d\u70b9\u5f80\u540e\u6709\u591a\u5c11\u4e2a\u8fde\u7eed\u76f8\u540c\u7684\u5143\u7d20\uff0c\u7136\u540e\u4e8c\u5206\u6b63\u65b9\u5f62\u8fb9\u957f x x \uff0c\u7136\u540e\u7528\u540c\u6837\u7684\u601d\u60f3\u5bf9\u4e8e\u6bcf\u4e00\u5217\u6309\u884c\u679a\u4e3e\u8fdb\u884c check \u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 ; int n , m ; char s [ N ][ N ]; int suf [ N ][ N ]; bool check ( int x ) { for ( int j = 1 ; j <= m ; ++ j ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( suf [ i ][ j ] >= x ) ++ cnt ; else cnt = 0 ; if ( cnt >= x ) return true ; } } return false ; } int main () { scanf ( \"%d %d\" , & n , & m ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%s\" , s [ i ] + 1 ); suf [ i ][ m ] = 1 ; for ( int j = m - 1 ; j >= 1 ; -- j ) { if ( s [ i ][ j ] == s [ i ][ j + 1 ]) suf [ i ][ j ] = suf [ i ][ j + 1 ] + 1 ; else suf [ i ][ j ] = 1 ; } } int l = 1 , r = 1000 , res = -1 ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( check ( mid )) { l = mid + 1 ; res = mid ; } else { r = mid - 1 ; } } printf ( \"%d \\n \" , res * res ); return 0 ; } M. Mountain Ranges Solved By Hsueh-. 0:08(+) \u9898\u610f\uff1a \u95ee\u6700\u957f\u7684\u589e\u91cf\u4e0d\u8d85\u8fc7 x x \u7684\u5e8f\u5217\u3002 \u601d\u8def\uff1a \u7b7e\u5230\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 ; int n , x ; int a [ N ], b [ N ]; int main () { scanf ( \"%d %d\" , & n , & x ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); b [ i ] = a [ i ] - a [ i - 1 ]; } int res = 1 , cnt = 1 ; for ( int i = 2 ; i <= n ; ++ i ) { if ( b [ i ] <= x ) { ++ cnt ; } else { cnt = 1 ; } res = max ( res , cnt ); // cout << i << \" \" << cnt << endl; } printf ( \"%d \\n \" , res ); return 0 ; }","title":"2019-2020 ACM-ICPC Latin American Regional Programming Contest"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Latin-American-Regional-Programming-Contest/#contest-info","text":"Practice Link Solved A B C D E F G H I J K L M 9/13 - - \u00d8 O O - O \u00d8 O - O O O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5","title":"Contest Info"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Latin-American-Regional-Programming-Contest/#solutions","text":"","title":"Solutions"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Latin-American-Regional-Programming-Contest/#a-algorithm-teaching","text":"UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"A. Algorithm Teaching"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Latin-American-Regional-Programming-Contest/#b-build-the-perfect-house","text":"UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"B. Build the Perfect House"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Latin-American-Regional-Programming-Contest/#c-cut-inequality-down","text":"UpSolved by Dup4. \u9898\u610f\uff1a \u6709\u4e00\u4e2a\u5e8f\u5217 a_i a_i \uff0c\u957f\u5ea6\u4e3a n n \uff0c\u548c\u4e24\u4e2a\u53c2\u6570 L, U L, U \uff0c\u73b0\u5728\u6bcf\u6b21\u8be2\u95ee\u7ed9\u51fa B, E, X B, E, X \uff0c\u8981\u6c42\u4f5c\u5982\u4e0b\u64cd\u4f5c\uff1a \u4ee4 i i \u4ece B B \u904d\u5386\u5230 E E \u3002 \u7136\u540e\u4ee4 \\displaystyle X = max(L, min(R, X + a_i)) \\displaystyle X = max(L, min(R, X + a_i)) \u3002 \u8f93\u51fa\u6700\u540e\u7684 X X \u3002 \u601d\u8def\uff1a \u8003\u8651\u5bf9\u4e8e\u6bcf\u4e00\u6b21\u67e5\u8be2\uff0c\u53ef\u4ee5 O(\\log n) O(\\log n) \u7684\u65f6\u95f4\u627e\u5230\u4e0b\u4e00\u4e2a\u53d8\u5316\u7684\u70b9\uff0c\u90a3\u4e48\u4ece\u4e0b\u4e00\u4e2a\u53d8\u5316\u7684\u70b9\u5f00\u59cb\u5f80\u4e0b\u8d70\uff0c\u90a3\u4e48\u5bb9\u6613\u53d1\u73b0\u4ece\u4e0b\u4e00\u4e2a\u53d8\u5316\u7684\u70b9\u5f00\u59cb\u8d70\u7684\u521d\u59cb\u503c\u8981\u4e48\u662f L L \uff0c\u8981\u4e48\u662f U U \uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5c06\u6bcf\u4e2a a_i a_i \u62c6\u6210\u4e24\u4e2a\u70b9\uff0c\u4e00\u4e2a\u662f\u8d77\u59cb\u503c\u4e3a L L \uff0c\u4ece\u7b2c i i \u4e2a\u70b9\u5f00\u59cb\u5f80\u4e0b\u8d70\uff0c\u4e00\u4e2a\u662f\u8d77\u59cb\u503c\u4e3a U U \uff0c\u4ece\u7b2c i i \u4e2a\u70b9\u5f00\u59cb\u5f80\u4e0b\u8d70\uff0c\u53d1\u73b0\u4f1a\u5f62\u6210\u6811\u5f62\u7ed3\u6784\u3002 \u90a3\u4e48\u6211\u4eec\u6bcf\u6b21\u4ece\u521d\u59cb\u503c\u627e\u5230\u7b2c\u4e00\u4e2a\u53d8\u5316\u7684\u70b9\u4e4b\u540e\u76f4\u63a5\u5728\u6811\u4e0a\u500d\u589e\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; using pII = pair < int , int > ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } #define fi first #define se second #define SZ(x) (int(x.size())) const int N = 1e5 + 10 , M = 20 ; const ll INFLL = 1e18 ; int n , L , R , q , a [ N ]; // 0 L 1 R ll S [ N ]; vector < vector < int >> G ; struct RMQ { ll Max [ N ][ M ]; ll Min [ N ][ M ]; int mm [ N ]; void init ( int n , ll * b ) { mm [ 0 ] = -1 ; for ( int i = 1 ; i <= n ; ++ i ) { mm [ i ] = (( i & ( i - 1 )) == 0 ) ? mm [ i - 1 ] + 1 : mm [ i - 1 ]; Max [ i ][ 0 ] = b [ i ]; Min [ i ][ 0 ] = b [ i ]; } for ( int j = 1 ; j <= mm [ n ]; ++ j ) { for ( int i = 1 ; i + ( 1 << j ) - 1 <= n ; ++ i ) { Max [ i ][ j ] = max ( Max [ i ][ j - 1 ], Max [ i + ( 1 << ( j - 1 ))][ j - 1 ]); Min [ i ][ j ] = min ( Min [ i ][ j - 1 ], Min [ i + ( 1 << ( j - 1 ))][ j - 1 ]); } } } ll queryMax ( int x , int y ) { int k = mm [ y - x + 1 ]; return max ( Max [ x ][ k ], Max [ y - ( 1 << k ) + 1 ][ k ]); } ll queryMin ( int x , int y ) { int k = mm [ y - x + 1 ]; return min ( Min [ x ][ k ], Min [ y - ( 1 << k ) + 1 ][ k ]); } int queryL ( int x , ll ini ) { int l = x , r = n , res = n ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( ini + queryMin ( x , mid ) - S [ x - 1 ] <= L ) { res = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return res + 1 ; } int queryR ( int x , ll ini ) { int l = x , r = n , res = n ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( ini + queryMax ( x , mid ) - S [ x - 1 ] >= R ) { res = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return res + 1 ; } } rmq ; void addEdge ( int ini , int id ) { int nl = rmq . queryL ( id / 2 , ini ); int nr = rmq . queryR ( id / 2 , ini ); if ( nl < nr ) { // dbg(nl * 2, id); G [ nl * 2 ]. push_back ( id ); } else { // dbg(nr * 2 + 1, id); G [ nr * 2 + 1 ]. push_back ( id ); } } int fa [ M ][ N * 2 + 10 ]; void dfs ( int u ) { for ( int i = 1 ; i < M ; ++ i ) fa [ i ][ u ] = fa [ i - 1 ][ fa [ i - 1 ][ u ]]; for ( auto & v : G [ u ]) { fa [ 0 ][ v ] = u ; dfs ( v ); } } ll get ( int u , int E ) { // dbg(u, E); for ( int i = M - 1 ; i >= 0 ; -- i ) { if ( fa [ i ][ u ] / 2 <= E ) u = fa [ i ][ u ]; } // dbg(u, E); ll ans = u % 2 ? R : L ; ans += S [ E ] - S [ u / 2 - 1 ]; if ( ans > R ) ans = R ; if ( ans < L ) ans = L ; return ans ; } int main () { scanf ( \"%d%d%d\" , & n , & L , & R ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ), S [ i ] = S [ i - 1 ] + a [ i ]; rmq . init ( n , S ); G . clear (); G . resize ( n * 2 + 20 ); for ( int i = 1 ; i <= n ; ++ i ) { addEdge ( L , 2 * i ); addEdge ( R , 2 * i + 1 ); } fa [ 0 ][ 2 * ( n + 1 )] = 2 * ( n + 1 ); fa [ 0 ][ 2 * ( n + 1 ) + 1 ] = 2 * ( n + 1 ) + 1 ; dfs ( 2 * ( n + 1 )); dfs ( 2 * ( n + 1 ) + 1 ); scanf ( \"%d\" , & q ); for ( int i = 1 , B , E , X ; i <= q ; ++ i ) { scanf ( \"%d%d%d\" , & B , & E , & X ); int nl = rmq . queryL ( B , X ); int nr = rmq . queryR ( B , X ); if ( min ( nl , nr ) - 1 >= E ) { ll ans = S [ E ] - S [ B - 1 ] + X ; if ( ans > R ) ans = R ; if ( ans < L ) ans = L ; printf ( \"%lld \\n \" , ans ); } else { int id ; if ( nl < nr ) id = nl * 2 ; else id = nr * 2 + 1 ; printf ( \"%lld \\n \" , get ( id , E )); } } return 0 ; }","title":"C. Cut Inequality Down"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Latin-American-Regional-Programming-Contest/#d-dazzling-stars","text":"Solved By Hsueh-. 3:47(+1) \u9898\u610f\uff1a \u6709 n \u4e2a\u661f\u661f\uff0c\u6bcf\u4e2a\u661f\u661f\u6709\u5750\u6807\u548c\u4eae\u5ea6\uff0c\u95ee\u662f\u5426\u5b58\u5728\u4e00\u4e2a\u65b9\u5411\uff0c\u4f7f\u5f97\u8fd9\u4e2a\u65b9\u5411\u8fc7\u6765\u4eae\u5ea6\u4ece\u9ad8\u5230\u4f4e\u9012\u51cf\u3002 \u601d\u8def\uff1a \u5904\u7406\u51fa\u6bcf\u5bf9\u4ece\u4eae\u7684\u5230\u6697\u7684\u65b9\u5411\u5411\u91cf\u8303\u56f4\uff0c\u770b\u6709\u6ca1\u6709\u4ea4\u96c6\u3002 Code #include <bits/stdc++.h> using namespace std ; using db = double ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const db PI = acos ( -1.0 ), eps = 1e-8 ; const int N = 2e3 + 10 ; int sgn ( db x ) { if ( fabs ( x ) < eps ) return 0 ; else return x > 0 ? 1 : -1 ; } struct Point { int x , y ; Point () {} Point ( int x , int y ) : x ( x ), y ( y ) {} Point operator - ( const Point & other ) const { return { x - other . x , y - other . y }; } Point rot () { return { - y , x }; } } a [ N ]; struct node { Point p ; int val , id ; db arc ; bool operator < ( const node & other ) const { if ( sgn ( arc - other . arc ) == 0 ) return val > other . val ; else return arc < other . arc ; } }; int n , tot ; vector < node > vec ; int b [ N ]; int add [ N * N ]; int l [ N * N ], r [ N * N ]; bool ok () { if ( vec . empty ()) return true ; for ( auto & it : vec ) { it . arc = atan2 ( it . p . y , it . p . x ); } sort ( vec . begin (), vec . end ()); for ( int i = 0 , len = vec . size (); i < len ; ++ i ) { if ( vec [ i ]. val == 1 ) l [ vec [ i ]. id ] = i ; else r [ vec [ i ]. id ] = i ; } for ( int i = 0 ; i < tot ; ++ i ) { if ( l [ i ] < r [ i ]) { add [ l [ i ]] ++ ; add [ r [ i ] + 1 ] -- ; } else { add [ l [ i ]] ++ ; add [ 0 ] ++ ; add [ r [ i ] + 1 ] -- ; } } int cnt = 0 ; for ( int i = 0 ; i < 2 * tot ; ++ i ) { cnt += add [ i ]; if ( cnt == tot ) return true ; } return false ; } void push ( Point a , Point b ) { vec . push_back ({( a - b ). rot (), -1 , tot }); vec . push_back ({( b - a ). rot (), 1 , tot }); tot ++ ; } int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d %d %d\" , & a [ i ]. x , & a [ i ]. y , & b [ i ]); } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j < i ; ++ j ) { if ( b [ i ] == b [ j ]) continue ; if ( b [ i ] > b [ j ]) { push ( a [ i ], a [ j ]); } else { push ( a [ j ], a [ i ]); } } } if ( ok ()) puts ( \"Y\" ); else puts ( \"N\" ); return 0 ; }","title":"D. Dazzling stars"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Latin-American-Regional-Programming-Contest/#e-eggfruit-cake","text":"Solved By Dup4. 0:14(+) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32\u73af\uff0c\u91cc\u9762\u53ea\u6709 E \u548c P \u4e24\u79cd\u5b57\u7b26\uff0c\u73b0\u5728\u95ee\u6709\u591a\u5c11\u533a\u95f4\uff0c\u6ee1\u8db3\u8fd9\u4e2a\u533a\u95f4\u957f\u5ea6\u5c0f\u4e8e\u7b49\u4e8e S S \uff0c\u5e76\u4e14\u91cc\u9762\u81f3\u5c11\u6709\u4e00\u4e2a E \u3002 \u601d\u8def\uff1a \u590d\u5236\u4e00\u904d\uff0c\u62d3\u5c55\u6210 2n 2n \uff0c\u7136\u540e\u626b\u4e00\u904d\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 2e5 + 10 ; int n , S ; char s [ N ]; int main () { scanf ( \"%s%d\" , s + 1 , & S ); n = strlen ( s + 1 ); for ( int i = 1 ; i <= n ; ++ i ) s [ i + n ] = s [ i ]; int pre = 0 ; for ( int i = 1 ; i <= n ; ++ i ) if ( s [ i ] == 'E' ) pre = i ; ll res = 0 ; for ( int i = n + 1 ; i <= n * 2 ; ++ i ) { if ( s [ i ] == 'E' ) pre = i ; int last = i - S ; res += max ( 0 , pre - last ); } printf ( \"%lld \\n \" , res ); return 0 ; }","title":"E. Eggfruit Cake"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Latin-American-Regional-Programming-Contest/#f-fabricating-sculptures","text":"UpSolved by Dup4. \u9898\u610f\uff1a \u5806\u7bb1\u5b50\uff0c\u6700\u5e95\u5c42\u6709 S S \u4e2a\uff0c\u4e00\u5171\u6709 B B \u4e2a\u7bb1\u5b50\uff0c\u4e00\u5c42\u4e00\u5c42\u5f80\u4e0a\u5806\uff0c\u6bcf\u4e00\u5c42\u5fc5\u987b\u8fde\u7eed\uff0c\u4e14\u4e2a\u6570\u4e0d\u8d85\u8fc7\u4e4b\u524d\u90a3\u4e00\u5c42\uff0c\u5e76\u4e14\u5f53\u524d\u5c42\u7684\u7bb1\u5b50\u5fc5\u987b\u90fd\u8981\u4e0a\u4e00\u5c42\u7684\u7bb1\u5b50\u4e4b\u4e0a\u3002 \u601d\u8def\uff1a f[i][j] f[i][j] \u8868\u793a\u7528\u4e86 i i \u4e2a\u7bb1\u5b50\uff0c\u6700\u4e0a\u5c42\u6709 j j \u4e2a\uff0c\u90a3\u4e48\u8f6c\u79fb\u6709\uff1a f[i][j] = \\sum\\limits_{k = j}^S f[i - k][k] \\cdot (k - j + 1) f[i][j] = \\sum\\limits_{k = j}^S f[i - k][k] \\cdot (k - j + 1) \u7136\u540e\u7ef4\u62a4 f[i][j] \\cdot j f[i][j] \\cdot j \u4ee5\u53ca f[i][j] f[i][j] \u7684\u540e\u7f00\u548c\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int mod = 1e9 + 7 ; const int N = 5e3 + 10 ; int n , S , B ; ll f [ N ][ N ], g [ N ][ N ], h [ N ][ N ]; // f[i][j] \u7528\u4e86i\u4e2a \u6700\u4e0a\u9762\u4e00\u5c42\u6709j \u4e2a\u7684\u65b9\u6848\u6570 int main () { scanf ( \"%d%d\" , & S , & B ); memset ( f , 0 , sizeof f ); memset ( g , 0 , sizeof g ); memset ( h , 0 , sizeof h ); f [ S ][ S ] = 1 ; for ( int i = S ; i >= 1 ; -- i ) { g [ S ][ i ] = ( g [ S ][ i + 1 ] + f [ S ][ i ]) % mod ; h [ S ][ i ] = ( h [ S ][ i + 1 ] + f [ S ][ i ] * i % mod ) % mod ; } for ( int i = S + 1 ; i <= B ; ++ i ) { for ( int j = 1 ; j <= S ; ++ j ) { f [ i ][ j ] = 1l l * ( 1 - j + mod ) % mod * ( g [ i - j ][ j ] - g [ i - j ][ S + 1 ] + mod ) % mod ; f [ i ][ j ] = ( f [ i ][ j ] + ( h [ i - j ][ j ] - h [ i - j ][ S + 1 ] + mod ) % mod ) % mod ; // if (f[i][j]) dbg(i, j, f[i][j]); } for ( int j = S ; j >= 1 ; -- j ) { g [ i ][ j ] = ( g [ i ][ j + 1 ] + f [ i ][ j ]) % mod ; h [ i ][ j ] = ( h [ i ][ j + 1 ] + f [ i ][ j ] * j % mod ) % mod ; } } ll res = 0 ; for ( int i = 1 ; i <= S ; ++ i ) { res = ( res + f [ B ][ i ]) % mod ; } printf ( \"%lld \\n \" , res ); return 0 ; }","title":"F. Fabricating Sculptures"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Latin-American-Regional-Programming-Contest/#g-gluing-pictures","text":"Solved By Dup4. 0:54(+) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32 S S \uff0c\u6709 q q \u6b21\u8be2\u95ee\uff0c\u6bcf\u6b21\u8be2\u95ee\u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32 T T \uff0c\u95ee T T \u6700\u5c11\u80fd\u5206\u6210\u591a\u5c11\u6bb5\uff0c\u4f7f\u5f97\u6bcf\u6bb5\u90fd\u662f S S \u7684\u4e00\u4e2a\u5b50\u4e32\u3002 \u601d\u8def\uff1a \u8003\u8651 f[i] f[i] \u8868\u793a T T \u4e2d\u7684\u524d i i \u4e2a\u5b57\u7b26\u6700\u5c11\u9700\u8981\u591a\u5c11\u6bb5\uff0c\u663e\u7136 f f \u5177\u6709\u5355\u8c03\u4e0d\u51cf\u6027\u8d28\u3002 \u7136\u540e\u6211\u4eec\u5bf9 S S \u5efa SAM \uff0c\u7136\u540e\u7528 T T \u5728 SAM \u4e0a\u8dd1\u5339\u914d\uff0c\u5982\u679c\u4e0d\u80fd\u5f80\u4e0b\u62d3\u5c55\u4e86\u5c31\u8df3\u540e\u7f00\uff0c\u7ef4\u62a4\u5f53\u524d\u5339\u914d\u7684\u6700\u957f\u540e\u7f00\u957f\u5ea6\uff0c\u8fdb\u884c\u8f6c\u79fb\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 2e5 + 10 , ALP = 26 ; int n , q , f [ N ]; char s [ N ], t [ N ]; struct SAM { struct node { int maxlen , cnt , fa , nx [ ALP ]; void init () { maxlen = cnt = fa = 0 ; memset ( nx , 0 , sizeof nx ); } } t [ N << 1 ]; int tot , lst ; int newnode () { ++ tot ; t [ tot ]. init (); return tot ; } void init () { tot = 0 ; lst = newnode (); } void extend ( int id ) { int cur = newnode (), p ; t [ cur ]. cnt = 1 ; t [ cur ]. maxlen = t [ lst ]. maxlen + 1 ; for ( p = lst ; p && ! t [ p ]. nx [ id ]; p = t [ p ]. fa ) t [ p ]. nx [ id ] = cur ; if ( ! p ) { t [ cur ]. fa = 1 ; } else { int q = t [ p ]. nx [ id ]; if ( t [ q ]. maxlen == t [ p ]. maxlen + 1 ) { t [ cur ]. fa = q ; } else { int clone = newnode (); t [ clone ] = t [ q ]; t [ clone ]. cnt = 0 ; t [ clone ]. maxlen = t [ p ]. maxlen + 1 ; for (; p && t [ p ]. nx [ id ] == q ; p = t [ p ]. fa ) t [ p ]. nx [ id ] = clone ; t [ cur ]. fa = t [ q ]. fa = clone ; } } lst = cur ; } void build ( char * s ) { init (); for ( int i = 1 ; s [ i ]; ++ i ) { extend ( s [ i ] - 'A' ); } } int solve ( char * s ) { int len = strlen ( s + 1 ); memset ( f , -1 , sizeof ( f [ 0 ]) * ( len + 5 )); f [ 0 ] = 0 ; int cur = 1 ; int curlen = 0 ; for ( int i = 1 ; i <= len ; ++ i ) { while ( cur && t [ cur ]. nx [ s [ i ] - 'A' ] == 0 ) { cur = t [ cur ]. fa ; curlen = min ( curlen , t [ cur ]. maxlen ); } if ( cur == 0 ) return -1 ; cur = t [ cur ]. nx [ s [ i ] - 'A' ]; ++ curlen ; f [ i ] = f [ i - curlen ] + 1 ; } return f [ len ]; } } sam ; int main () { scanf ( \"%s\" , s + 1 ); scanf ( \"%d\" , & q ); sam . build ( s ); while ( q -- ) { scanf ( \"%s\" , t + 1 ); printf ( \"%d \\n \" , sam . solve ( t )); } return 0 ; }","title":"G. Gluing Pictures"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Latin-American-Regional-Programming-Contest/#h-hold-or-continue","text":"UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"H. Hold or Continue?"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Latin-American-Regional-Programming-Contest/#i-improve-spam","text":"Solved By Hsueh-. 1:00(+) \u9898\u610f\uff1a \u7ed9\u5b9a\u4e00\u4e2a DAG \u7684 SPAM\uff0c\u5176\u4e2d\u6709 L \u4e2a\u90ae\u4ef6\u5217\u8868\uff0c n n \u4e2a\u5ba2\u6237\uff0c\u90ae\u4ef6\u5217\u8868\u4f1a\u50cf\u91cc\u9762\u7684\u90ae\u4ef6\u5ba2\u6237\u7aef\u7684\u4eba\u53d1\u90ae\u4ef6\uff0c\u95ee\u4ece 1 \u5f00\u59cb\u53d1\u90ae\u4ef6\uff0c\u7528\u6237\u5ba2\u6237\u7aef\u4f1a\u6536\u5230\u591a\u5c11\u90ae\u4ef6\uff0c\u6709\u591a\u5c11\u7528\u6237\u6536\u5230\u90ae\u4ef6\u3002 \u601d\u8def\uff1a \u641c\u7d22\u6c34\u9898\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 2e3 + 10 ; const ll p = 1e9 + 7 ; int n , l ; vector < vector < int >> G ; ll f [ N ]; int vis [ N ]; ll gao ( int u ) { if ( vis [ u ]) return f [ u ]; vis [ u ] = 1 ; if ( u > l ) f [ u ] = 1 ; for ( auto v : G [ u ]) { f [ u ] = ( f [ u ] + gao ( v )) % p ; } return f [ u ]; } int main () { scanf ( \"%d %d\" , & n , & l ); G . clear (); G . resize ( n + 1 ); for ( int i = 1 , m ; i <= l ; ++ i ) { scanf ( \"%d\" , & m ); for ( int j = 1 , x ; j <= m ; ++ j ) { scanf ( \"%d\" , & x ); G [ i ]. push_back ( x ); } } ll res1 = gao ( 1 ), res2 = 0 ; for ( int i = l + 1 ; i <= n ; ++ i ) { res2 += vis [ i ]; } printf ( \"%lld %lld \\n \" , res1 , res2 ); return 0 ; }","title":"I. Improve SPAM"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Latin-American-Regional-Programming-Contest/#j-jumping-grasshoper","text":"UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"J. Jumping Grasshoper"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Latin-American-Regional-Programming-Contest/#k-know-your-aliens","text":"Solved By Dup4. 1:23(+) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u957f\u5ea6\u4e3a n n \u7684\u5b57\u7b26\u4e32 S S \uff0c\u5b57\u7b26\u4e32\u4e2d\u53ea\u6709 H \u548c A \u4e24\u79cd\u5b57\u7b26\u3002 \u73b0\u5728\u8981\u6784\u9020\u4e00\u4e2a\u591a\u9879\u5f0f P P \uff0c\u5bf9\u4e8e\u7b2c i i \u4e2a\u5b57\u7b26\uff1a \u5982\u679c\u662f H \uff0c\u90a3\u4e48\u8981\u6ee1\u8db3 P(2i) > 0 P(2i) > 0 \u3002 \u5982\u679c\u662f A \uff0c\u90a3\u4e48\u8981\u6ee1\u8db3 P(2i) < 0 P(2i) < 0 \u3002 \u8fd9\u4e2a\u591a\u9879\u5f0f\u8981\u6ee1\u8db3\u7cfb\u6570\u548c\u6839\u5747\u4e3a\u6574\u6570\uff0c\u6700\u9ad8\u9879\u7cfb\u6570\u53ea\u80fd\u4e3a 1 1 \u548c -1 -1 \uff0c\u5e76\u4e14\u5728\u6240\u6709\u53ef\u884c\u7b54\u6848\u4e2d\u6700\u9ad8\u9879\u8981\u5c3d\u53ef\u80fd\u5c0f\u3002 \u601d\u8def\uff1a \u8003\u8651\u5c06\u591a\u9879\u5f0f\u5199\u6210 \\prod (a_i - x) \\prod (a_i - x) \u7684\u5f62\u5f0f\uff0c\u90a3\u4e48\u5982\u679c P(2i) < 0 P(2i) < 0 \uff0c\u5373\u6709\u5947\u6570\u4e2a\u5c0f\u4e8e 0 0 \u7684\u6570\u76f8\u4e58\uff0c\u5426\u5219\u662f\u5076\u6570\u4e2a\u3002 \u90a3\u4e48\u8003\u8651\u5b57\u7b26\u4e32\u4e2d\u6bcf\u4e2a H \u548c A \u7684\u53d8\u6362\u7684\u5730\u65b9\uff0c\u5047\u8bbe\u7b2c i i \u548c\u7b2c i + 1 i + 1 \u4e2a\u5b57\u7b26\u4e0d\u540c\uff0c\u90a3\u4e48\u6211\u4eec\u5728\u591a\u9879\u5f0f\u4e2d\u63d2\u5165 (i \\cdot 2 + 1 - x) (i \\cdot 2 + 1 - x) \uff0c\u5373\u53ef\u7b26\u5408\u9898\u610f\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define SZ(x) (int((x).size())) const int N = 1e4 + 10 ; char s [ N ]; int n ; vector < ll > vec ; void gao ( ll x ) { ll t = vec . back (); for ( int i = SZ ( vec ) - 2 ; i >= 0 ; -- i ) { vec [ i + 1 ] = vec [ i + 1 ] * x - vec [ i ]; } vec [ 0 ] *= x ; vec . push_back ( - t ); } int main () { scanf ( \"%s\" , s + 1 ); n = strlen ( s + 1 ); if ( s [ 1 ] == 'H' ) vec . push_back ( 1 ); else vec . push_back ( -1 ); for ( int i = 2 ; i <= n ; ++ i ) { if ( s [ i ] != s [ i - 1 ]) { // cout << (i - 1) * 2 + 1 << endl; gao (( i - 1 ) * 2 + 1 ); } } reverse ( vec . begin (), vec . end ()); printf ( \"%d \\n \" , SZ ( vec ) - 1 ); for ( int i = 0 ; i < SZ ( vec ); ++ i ) printf ( \"%lld%c\" , vec [ i ], \" \\n \" [ i == SZ ( vec ) - 1 ]); return 0 ; }","title":"K. Know your Aliens"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Latin-American-Regional-Programming-Contest/#l-leverage-mdt","text":"Solved By Hsueh-. 1:42(+) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a 01 \u4e8c\u7ef4\u77e9\u9635\uff0c\u6bcf\u6b21\u53ef\u4ee5\u5c06\u67d0\u4e00\u884c\u7684\u72b6\u6001\u7ffb\u8f6c\uff0c\u95ee\u4efb\u610f\u7ffb\u8f6c\u540e\uff0c\u80fd\u5426\u627e\u4e00\u4e2a\u6700\u5927\u7684\u6b63\u65b9\u5f62\uff0c\u4f7f\u5f97\u6b63\u65b9\u5f62\u5185\u5168\u662f 0 0 \uff0c\u95ee\u6700\u5927\u7684\u6b63\u65b9\u5f62\u9762\u79ef\u662f\u591a\u5c11\u3002 \u601d\u8def\uff1a \u9898\u610f\u7b49\u4ef7\u4e8e\u627e\u4e00\u4e2a\u6700\u5927\u7684\u6b63\u65b9\u5f62\uff0c\u4f7f\u5f97\u6b63\u65b9\u5f62\u5185\u6bcf\u4e00\u884c\u5143\u7d20\u4e00\u81f4\u3002 \u5148\u5bf9\u6bcf\u4e00\u884c\u5904\u7406\u51fa\u5f53\u524d\u70b9\u5f80\u540e\u6709\u591a\u5c11\u4e2a\u8fde\u7eed\u76f8\u540c\u7684\u5143\u7d20\uff0c\u7136\u540e\u4e8c\u5206\u6b63\u65b9\u5f62\u8fb9\u957f x x \uff0c\u7136\u540e\u7528\u540c\u6837\u7684\u601d\u60f3\u5bf9\u4e8e\u6bcf\u4e00\u5217\u6309\u884c\u679a\u4e3e\u8fdb\u884c check \u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 ; int n , m ; char s [ N ][ N ]; int suf [ N ][ N ]; bool check ( int x ) { for ( int j = 1 ; j <= m ; ++ j ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( suf [ i ][ j ] >= x ) ++ cnt ; else cnt = 0 ; if ( cnt >= x ) return true ; } } return false ; } int main () { scanf ( \"%d %d\" , & n , & m ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%s\" , s [ i ] + 1 ); suf [ i ][ m ] = 1 ; for ( int j = m - 1 ; j >= 1 ; -- j ) { if ( s [ i ][ j ] == s [ i ][ j + 1 ]) suf [ i ][ j ] = suf [ i ][ j + 1 ] + 1 ; else suf [ i ][ j ] = 1 ; } } int l = 1 , r = 1000 , res = -1 ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( check ( mid )) { l = mid + 1 ; res = mid ; } else { r = mid - 1 ; } } printf ( \"%d \\n \" , res * res ); return 0 ; }","title":"L. Leverage MDT"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Latin-American-Regional-Programming-Contest/#m-mountain-ranges","text":"Solved By Hsueh-. 0:08(+) \u9898\u610f\uff1a \u95ee\u6700\u957f\u7684\u589e\u91cf\u4e0d\u8d85\u8fc7 x x \u7684\u5e8f\u5217\u3002 \u601d\u8def\uff1a \u7b7e\u5230\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 ; int n , x ; int a [ N ], b [ N ]; int main () { scanf ( \"%d %d\" , & n , & x ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); b [ i ] = a [ i ] - a [ i - 1 ]; } int res = 1 , cnt = 1 ; for ( int i = 2 ; i <= n ; ++ i ) { if ( b [ i ] <= x ) { ++ cnt ; } else { cnt = 1 ; } res = max ( res , cnt ); // cout << i << \" \" << cnt << endl; } printf ( \"%d \\n \" , res ); return 0 ; }","title":"M. Mountain Ranges"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-1/","text":"2019-2020 ACM-ICPC Pacific Northwest Regional Contest (Div. 1) Contents Contest Info Solutions A. Radio Prize B. Perfect Flush C. Coloring Contention D. Dividing by Two E. Rainbow Strings F. Carny Magician G. Glow, Little Pixel, Glow H. Pivoting Points I.Error Correction J. Interstellar Travel K. Computer Cache L. Carry Cam Failure M. Maze Connec Contest Info Practice Link Editorials Link Solved A B C D E F G H I J K L M 9/13 O O O O O - - - O - O O O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5 Solutions A. Radio Prize Solved By Dup4. 2:26(+) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u68f5\u6811\uff0c\u6bcf\u4e2a\u70b9\u6709\u70b9\u6743 t_i t_i , \u6bcf\u6761\u8fb9\u6709\u8fb9\u6743 w_i w_i , \u73b0\u5728\u8981\u5bf9\u4e8e\u6bcf\u4e2a\u70b9 i i \uff0c\u8ba1\u7b97 \\sum\\limits_{j = 1}^n [i \\neq j](t_i + t_j) \\cdot d(i, j) \\sum\\limits_{j = 1}^n [i \\neq j](t_i + t_j) \\cdot d(i, j) \uff0c\u5176\u4e2d d(i, j) d(i, j) \u8868\u793a i \\to j i \\to j \u7684\u7b80\u5355\u8def\u5f84\u7684\u957f\u5ea6\u3002 \u601d\u8def\uff1a \u5c06\u8d21\u732e\u62c6\u6210 t_id(i, j) + t_jd(i, j) t_id(i, j) + t_jd(i, j) \uff0c\u7136\u540e\u7ef4\u62a4\u8ddd\u79bb\u548c\u3001\u70b9\u6743\u548c\u3001\u4e58\u79ef\u548c\uff0c\u6362\u6839 dp \u5373\u53ef\u3002 Code #include <bits/stdc++.h> #define fi first #define se second using namespace std ; using ll = long long ; using pLL = pair < ll , ll > ; const int N = 1e5 + 10 ; int n , a [ N ], fa [ N ], sze [ N ]; ll res [ N ]; struct Graph { struct E { int to , nx , w ; } e [ N << 1 ]; int h [ N ], cnt ; void init ( int n ) { for ( int i = 0 ; i <= n ; ++ i ) h [ i ] = -1 ; cnt = -1 ; } void addedge ( int u , int v , int w = 0 ) { e [ ++ cnt ] = { v , h [ u ], w }; h [ u ] = cnt ; } } G ; struct E { ll Sdis , Sval , S ; } f [ N ], g [ N ]; void dfs ( int u ) { f [ u ] = { 0 , 0 , 0 }; sze [ u ] = 1 ; for ( int i = G . h [ u ]; ~ i ; i = G . e [ i ]. nx ) { int v = G . e [ i ]. to , w = G . e [ i ]. w ; if ( v == fa [ u ]) continue ; fa [ v ] = u ; dfs ( v ); sze [ u ] += sze [ v ]; f [ u ]. Sdis += f [ v ]. Sdis + 1l l * sze [ v ] * w ; f [ u ]. Sval += f [ v ]. Sval ; f [ u ]. S += f [ v ]. S + f [ v ]. Sval * w ; } res [ u ] += 1l l * a [ u ] * f [ u ]. Sdis + f [ u ]. S ; f [ u ]. Sval += a [ u ]; } void dfs1 ( int u ) { for ( int i = G . h [ u ]; ~ i ; i = G . e [ i ]. nx ) { int v = G . e [ i ]. to , w = G . e [ i ]. w ; if ( v == fa [ u ]) continue ; g [ v ]. Sdis = g [ u ]. Sdis + f [ u ]. Sdis - f [ v ]. Sdis - 1l l * sze [ v ] * w + 1l l * ( n - sze [ v ]) * w ; g [ v ]. Sval = g [ u ]. Sval + f [ u ]. Sval - f [ v ]. Sval ; g [ v ]. S = g [ u ]. S + f [ u ]. S - f [ v ]. S - f [ v ]. Sval * w + g [ v ]. Sval * w ; res [ v ] += 1l l * a [ v ] * g [ v ]. Sdis + g [ v ]. S ; dfs1 ( v ); } } int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ), res [ i ] = 0 ; G . init ( n ); for ( int i = 1 , u , v , w ; i < n ; ++ i ) { scanf ( \"%d%d%d\" , & u , & v , & w ); G . addedge ( u , v , w ); G . addedge ( v , u , w ); } dfs ( 1 ); g [ 1 ] = { 0 , 0 , 0 }; dfs1 ( 1 ); for ( int i = 1 ; i <= n ; ++ i ) printf ( \"%lld \\n \" , res [ i ]); return 0 ; } B. Perfect Flush Solved By Hsueh-. 3:00(+1) \u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u6570 x_i x_i , \u4fdd\u8bc1 1 \\leq x_i \\leq k 1 \\leq x_i \\leq k \uff0c\u5e76\u4e14\u4fdd\u8bc1 1, \\cdots k 1, \\cdots k \u4e2d\u6bcf\u4e2a\u6570\u81f3\u5c11\u51fa\u73b0\u4e86\u4e00\u6b21\uff0c\u73b0\u5728\u8981\u627e\u51fa\u4e00\u4e2a\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u5b50\u5e8f\u5217\uff0c\u4f7f\u5f97\u8fd9\u4e2a\u5b50\u5e8f\u5217\u662f\u4e00\u4e2a\u957f\u5ea6\u4e3a k k \u7684\u6392\u5217\u3002 \u601d\u8def\uff1a \u5229\u7528\u5355\u8c03\u6808\uff0c\u5982\u679c\u6808\u9876\u5143\u7d20\u5728\u540e\u9762\u5b58\u5728\u4e14\u6bd4\u5f53\u524d\u5143\u7d20\u5927\uff0c\u5219 pop \u6389\uff0c\u5982\u679c\u5f53\u524d\u5143\u7d20\u672c\u8eab\u5c31\u5728\u6808\u4e2d\u5219 continue\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 2e5 + 10 ; int n , k ; int a [ N ]; int res [ N ]; int cnt [ N ]; int in [ N ]; stack < int > st ; int main () { scanf ( \"%d %d\" , & n , & k ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); cnt [ a [ i ]] ++ ; } for ( int i = 1 ; i <= n ; ++ i ) { cnt [ a [ i ]] -- ; if ( in [ a [ i ]]) continue ; while ( ! st . empty () && a [ i ] < st . top () && cnt [ st . top ()]) { in [ st . top ()] = 0 ; st . pop (); } in [ a [ i ]] = 1 ; st . push ( a [ i ]); } for ( int i = k ; i >= 1 ; -- i ) { res [ i ] = st . top (); st . pop (); } for ( int i = 1 ; i <= k ; ++ i ) { printf ( \"%d%c\" , res [ i ], \" \\n \" [ i == k ]); } return 0 ; } C. Coloring Contention Solved By Hsueh-. 0:48(+) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a n n \u4e2a\u70b9 m m \u6761\u8fb9\u7684\u65e0\u5411\u56fe\uff0c\u6ca1\u6709\u91cd\u8fb9\uff0c\u6ca1\u6709\u81ea\u73af\uff0c Alice \u53ef\u4ee5\u5c06\u8fb9\u67d3\u6210\u7ea2\u8272\u6216\u8005\u84dd\u8272\uff0c\u5b9a\u4e49\u4e00\u6761\u8def\u5f84\u7684 color change \u6b21\u6570\u4e3a\u5c06\u8def\u5f84\u4e0a\u7ecf\u8fc7\u7684\u8fb9\u6309\u987a\u5e8f\u6392\u5217\uff0c\u4efb\u610f\u4e24\u4e2a\u76f8\u90bb\u7684\u8fb9\u989c\u8272\u4e0d\u540c\u5373\u8bb0\u4e00\u6b21 color change \u3002 \u73b0\u5728 Bob \u8981\u9009\u62e9\u4e00\u6761 1 \\to n 1 \\to n \u7684\u8def\u5f84\uff0c\u95ee Alice \u5982\u679c\u67d3\u8272\uff0c\u4f7f\u5f97 Bob \u7684\u6700\u4f18\u89e3\u6700\u5927\uff0c\u5373 color change \u6b21\u6570\u6700\u591a\u3002\u8f93\u51fa\u8fd9\u4e2a\u6700\u5927\u503c\u3002 \u601d\u8def\uff1a \u663e\u7136\u7b54\u6848\u7684\u4e0a\u754c\u4e3a 1 \\to n 1 \\to n \u7684 \\mbox{\u6700\u77ed\u8def\u957f\u5ea6} - 1 \\mbox{\u6700\u77ed\u8def\u957f\u5ea6} - 1 \uff0c\u731c\u6d4b\u4e00\u5b9a\u80fd\u6709\u4e00\u79cd\u65b9\u6848\u80fd\u591f\u505a\u5230\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 , INF = 1e9 ; int n , m ; vector < vector < int >> G ; int dis [ N ], use [ N ]; void bfs ( int st ) { for ( int i = 1 ; i <= n ; ++ i ) { dis [ i ] = INF ; use [ i ] = 0 ; } queue < int > que ; que . push ( st ); dis [ st ] = 0 ; use [ st ] = 1 ; while ( ! que . empty ()) { int u = que . front (); que . pop (); for ( auto & v : G [ u ]) { if ( dis [ v ] > dis [ u ] + 1 ) { dis [ v ] = dis [ u ] + 1 ; que . push ( v ); } } } } int main () { scanf ( \"%d%d\" , & n , & m ); G . clear (); G . resize ( n + 1 ); for ( int i = 1 , u , v ; i <= m ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); G [ u ]. push_back ( v ); G [ v ]. push_back ( u ); } bfs ( 1 ); printf ( \"%d \\n \" , dis [ n ] - 1 ); return 0 ; } D. Dividing by Two Solved By Hsueh-. 0:14(+) \u9898\u610f\uff1a \u7ed9\u5b9a\u4e24\u4e2a\u6570\u5b57 A A , B B \uff0c\u5bf9\u4e8e A A \u6709\u4e24\u79cd\u64cd\u4f5c\uff1a \u5f53 A A \u662f\u5076\u6570\u5219\u53ef\u4ee5\u9664\u4ee5 2 2 \u3002 \u52a0\u4e00\u3002 \u95ee\u6700\u5c0f\u7684\u64cd\u4f5c\u6b21\u6570\u4f7f\u5f97 A \u53d8\u6210 B\u3002 \u601d\u8def\uff1a \u5982\u679c A < B A < B \u5219\u5f88\u663e\u7136\u7b54\u6848\u662f\u4e24\u8005\u5dee\u503c\u3002 \u5982\u679c A = B A = B \u5219\u5f88\u663e\u7136\u7b54\u6848\u662f 0 0 \u3002 \u5269\u4e0b\u7684\u6a21\u62df\u5373\u53ef. Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; ll a , b ; int main () { scanf ( \"%lld %lld\" , & a , & b ); ll res = 0 ; while ( a > b ) { if ( a & 1 ) ++ a ; else a /= 2 ; ++ res ; } res += b - a ; printf ( \"%lld \\n \" , res ); return 0 ; } E. Rainbow Strings Solved By Hsueh-. 0:18(+) \u9898\u610f\uff1a \u5b9a\u4e49\u4e00\u4e2a rainbow string \u4e3a\u5b57\u7b26\u4e32\u4e2d\u4efb\u610f\u4e24\u4e2a\u5b57\u7b26\u90fd\u4e0d\u76f8\u540c\uff0c\u73b0\u5728\u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32 s s \uff0c\u95ee\u5b83\u6709\u591a\u5c11\u4e2a\u5b50\u5e8f\u5217\u662f rainbow string \u3002 \u601d\u8def\uff1a \u7b54\u6848\u4e3a \\prod (\\mbox{\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u6b21\u6570 + 1}) \\prod (\\mbox{\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u6b21\u6570 + 1}) \u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 1e5 + 10 ; const ll p = 11092019 ; char s [ N ]; ll cnt [ N ]; int main () { scanf ( \"%s\" , s + 1 ); int n = strlen ( s + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { cnt [ s [ i ]] ++ ; } ll res = 1 ; for ( int i = 'a' ; i <= 'z' ; ++ i ) { res = res * ( cnt [ i ] + 1 ) % p ; } printf ( \"%lld \\n \" , res ); return 0 ; } F. Carny Magician UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a G. Glow, Little Pixel, Glow UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a H. Pivoting Points UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a I.Error Correction Solved By Hsueh- & Dup4. 1:28(+1) \u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u5b57\u7b26\u4e32\uff0c\u6bcf\u4e2a\u5b57\u7b26\u4e32\u7b49\u957f\uff0c\u5e76\u4e14\u4efb\u610f\u4e24\u4e2a\u5b57\u7b26\u4e0d\u76f8\u540c\uff0c\u5b9a\u4e49\u4efb\u610f\u4e24\u4e2a\u5b57\u7b26\u4e32\u4e0d\u53ef\u4ee5\u5171\u5b58\u5f53\u4e14\u4ec5\u5f53\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\u53ef\u4ee5\u901a\u8fc7\u4ea4\u6362\u4e00\u5bf9\u5b57\u7b26\u53d8\u6210\u53e6\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u73b0\u5728\u8981\u6c42\u9009\u51fa\u6700\u5927\u7684\u5b57\u7b26\u4e32\u5b50\u96c6\uff0c\u4f7f\u5f97\u5176\u4e2d\u4efb\u610f\u4e24\u4e2a\u5b57\u7b26\u4e32\u90fd\u53ef\u4ee5\u5171\u5b58\u3002 \u601d\u8def\uff1a \u5c06\u4e0d\u80fd\u5171\u5b58\u7684\u8fde\u8fb9\uff0c\u7b49\u4ef7\u4e8e\u6c42\u6700\u5927\u72ec\u7acb\u96c6\u3002 \u4f46\u662f\u6c42\u6700\u5927\u72ec\u7acb\u96c6\u7684\u6734\u7d20\u7b97\u6cd5\u662f O(n^4) O(n^4) \uff0c\u4f46\u662f\u5982\u679c\u5b83\u662f\u4e8c\u5206\u56fe\uff0c\u5c31\u7b49\u4ef7\u4e8e\u6c42\u6700\u5927\u5339\u914d\u3002 \u90a3\u4e48\u8003\u8651\u8be5\u56fe\u4e2d\u4e0d\u4f1a\u6709\u5947\u73af\uff0c\u56e0\u4e3a\u4e00\u6b21\u4ea4\u6362\u53ef\u4ee5\u7406\u89e3\u4e3a\u4e00\u4e2a\u9006\u5e8f\u5bf9\uff0c\u4e00\u4e2a\u5b57\u7b26\u4e32\u7ecf\u8fc7\u82e5\u5e72\u6b21\u4ea4\u6362\u56de\u5230\u672c\u8eab\uff0c\u80af\u5b9a\u662f\u7ecf\u8fc7\u5076\u6570\u6b21\u4ea4\u6362\u3002 \u90a3\u4e48\u6839\u636e\u9006\u5e8f\u5bf9\u6570\u91cf\u7684\u5947\u5076\u6027\u5c06\u5b57\u7b26\u4e32\u5206\u6210\u5de6\u53f3\u4e24\u8fb9\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 5e2 + 10 ; int n ; int inv [ N ]; string s [ N ]; vector < vector < int > > G ; int linker [ N ], used [ N ]; bool dfs ( int u ) { for ( auto v : G [ u ]) { if ( ! used [ v ]) { used [ v ] = true ; if ( linker [ v ] == -1 || dfs ( linker [ v ])) { linker [ v ] = u ; return true ; } } } return false ; } int hungray () { int res = 0 ; memset ( linker , -1 , sizeof linker ); for ( int u = 1 ; u <= n ; ++ u ) { if ( inv [ u ] % 2 == 0 ) continue ; memset ( used , false , sizeof used ); if ( dfs ( u )) ++ res ; } return res ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ), cout . tie ( nullptr ); cin >> n ; G . resize ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { cin >> s [ i ]; } for ( int i = 1 ; i <= n ; ++ i ) { int sze = s [ i ]. size (); for ( int j = 1 ; j <= n ; ++ j ) { int cnt = 0 ; for ( int k = 0 ; k < sze ; ++ k ) { cnt += s [ i ][ k ] != s [ j ][ k ]; } if ( cnt == 2 ) { G [ i ]. push_back ( j ); } } for ( int j = 0 ; j < sze ; ++ j ) { for ( int k = j + 1 ; k < sze ; ++ k ) { inv [ i ] += ( s [ i ][ j ] > s [ i ][ k ]); } } } // for (int i = 1; i <= n; ++i) { // cout << i << \" \" << inv[i] % 2 << endl; // } int res = hungray (); // cout << res << endl; cout << n - res << endl ; return 0 ; } J. Interstellar Travel UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a K. Computer Cache Solved By Dup4. 3:40(+) \u9898\u610f\uff1a \u6709 m m \u4e2a\u6570\u636e\u5757\uff0c\u7b2c i i \u4e2a\u6570\u636e\u5757\u7684\u957f\u5ea6\u4e3a s_i s_i \u3002 \u6709\u4e00\u4e2a cache \uff0c\u652f\u6301\u4e09\u79cd\u64cd\u4f5c\uff1a 1 i p , \u5c06\u7b2c i i \u4e2a\u6570\u636e\u5757\u52a0\u8f7d\u8fdb cache , \u8d77\u59cb\u4f4d\u7f6e\u4e3a p p \u3002 2 p , \u8f93\u51fa cache \u4e2d\u7b2c p p \u4e2a\u4f4d\u7f6e\u7684\u6570\u503c\u3002 3 i l r , \u5c06\u7b2c i i \u4e2a\u6570\u636e\u5757\u4e2d\u7684 [l, r] [l, r] \u4e2d\u6bcf\u4e2a\u6570\u5b57\u90fd +1 \\bmod 256 +1 \\bmod 256 \uff0c\u5373 x_i = (x_i + 1) \\bmod 256 x_i = (x_i + 1) \\bmod 256 \u3002 \u601d\u8def\uff1a \u8003\u8651\u67e5\u8be2\u53ef\u80fd\u4f1a\u67e5\u8be2\u5386\u53f2\u7248\u672c\uff0c\u5bb9\u6613\u60f3\u5230\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\u3002 \u4f46\u662f 5 \\cdot 10^5 5 \\cdot 10^5 \u7684\u6570\u636e\u91cf\uff0c\u5728\u65f6\u95f4\u548c\u7a7a\u95f4\u4e0a\u90fd\u4e0d\u592a\u5141\u8bb8\uff0c\u53ef\u4ee5\u76f4\u63a5\u79bb\u7ebf\uff0c\u8bb0\u5f55\u7248\u672c\u53f7\u3002 Code #include <bits/stdc++.h> #define SZ(x) (int(x.size())) #define fi first #define se second using namespace std ; using ll = long long ; using pII = pair < int , int > ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 5e5 + 10 ; int n , m , q , ver [ N ], sze [ N ], res [ N ], isQuery [ N ]; vector < vector < int >> vec ; struct W { int i , p , ver ; }; struct SEG { struct node { W val , lazy ; void init () { val = lazy = { -1 , -1 , -1 }; } void up ( W _lazy ) { val = _lazy ; lazy = _lazy ; } } t [ N << 2 ], res ; void down ( int id ) { W & lazy = t [ id ]. lazy ; if ( lazy . i == -1 ) return ; t [ id << 1 ]. up ( lazy ); t [ id << 1 | 1 ]. up ( lazy ); lazy = { -1 , -1 , -1 }; } void build ( int id , int l , int r ) { t [ id ]. init (); if ( l == r ) return ; int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); } void update ( int id , int l , int r , int ql , int qr , W v ) { if ( l >= ql && r <= qr ) { t [ id ]. up ( v ); return ; } int mid = ( l + r ) >> 1 ; down ( id ); if ( ql <= mid ) update ( id << 1 , l , mid , ql , qr , v ); if ( qr > mid ) update ( id << 1 | 1 , mid + 1 , r , ql , qr , v ); } W query ( int id , int l , int r , int pos ) { if ( l == r ) return t [ id ]. val ; int mid = ( l + r ) >> 1 ; down ( id ); if ( pos <= mid ) return query ( id << 1 , l , mid , pos ); else return query ( id << 1 | 1 , mid + 1 , r , pos ); } } seg ; struct TSEG { struct node { int lazy , sum ; node () { lazy = sum = 0 ; } void up ( int _lazy ) { sum += _lazy ; lazy += _lazy ; } node operator + ( const node & other ) const { node res = node (); res . sum = sum + other . sum ; return res ; } } t [ N << 2 ]; void down ( int id ) { int & lazy = t [ id ]. lazy ; t [ id << 1 ]. up ( lazy ); t [ id << 1 | 1 ]. up ( lazy ); lazy = 0 ; } void build ( int id , int l , int r , const vector < int > & a ) { if ( l == r ) { t [ id ]. sum = a [ l ]; return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid , a ); build ( id << 1 | 1 , mid + 1 , r , a ); t [ id ] = t [ id << 1 ] + t [ id << 1 | 1 ]; } void update ( int id , int l , int r , int ql , int qr , int v ) { if ( l >= ql && r <= qr ) { t [ id ]. up ( v ); return ; } int mid = ( l + r ) >> 1 ; down ( id ); if ( ql <= mid ) update ( id << 1 , l , mid , ql , qr , v ); if ( qr > mid ) update ( id << 1 | 1 , mid + 1 , r , ql , qr , v ); } int query ( int id , int l , int r , int pos ) { if ( l == r ) return t [ id ]. sum ; int mid = ( l + r ) >> 1 ; down ( id ); if ( pos <= mid ) return query ( id << 1 , l , mid , pos ); else return query ( id << 1 | 1 , mid + 1 , r , pos ); } } tseg ; struct E { int l , r ; vector < pII > vec ; }; vector < vector < E >> OP ; int main () { scanf ( \"%d%d%d\" , & n , & m , & q ); vec . resize ( m + 1 ); OP . clear (); OP . resize ( m + 1 ); seg . build ( 1 , 1 , n ); for ( int i = 1 , sz ; i <= m ; ++ i ) { scanf ( \"%d\" , & sz ); sze [ i ] = sz ; ver [ i ] = 0 ; vector < int > tmp ( sz + 1 ); for ( int j = 1 , x ; j <= sz ; ++ j ) { scanf ( \"%d\" , & x ); tmp [ j ] = x ; } vec [ i ] = tmp ; // dbg(i, sz); } for ( int _q = 1 ; _q <= q ; ++ _q ) { isQuery [ _q ] = 0 ; int op , i , l , r , p ; scanf ( \"%d\" , & op ); if ( op == 1 ) { scanf ( \"%d%d\" , & i , & p ); seg . update ( 1 , 1 , n , p , p + sze [ i ] - 1 , { i , p , ver [ i ]}); } else if ( op == 2 ) { scanf ( \"%d\" , & p ); isQuery [ _q ] = 1 ; W tmp = seg . query ( 1 , 1 , n , p ); // dbg(_q, tmp.i, tmp.p, tmp.ver); if ( tmp . i == -1 ) { res [ _q ] = 0 ; } else if ( tmp . ver == 0 ) { res [ _q ] = vec [ tmp . i ][ p - tmp . p + 1 ]; } else { // dbg(_q); OP [ tmp . i ][ tmp . ver - 1 ]. vec . push_back ( pII ( _q , p - tmp . p + 1 )); } } else { scanf ( \"%d%d%d\" , & i , & l , & r ); ++ ver [ i ]; OP [ i ]. push_back ({ l , r , {}}); } } for ( int i = 1 ; i <= m ; ++ i ) { int _n = sze [ i ]; tseg . build ( 1 , 1 , _n , vec [ i ]); for ( auto & _it : OP [ i ]) { tseg . update ( 1 , 1 , _n , _it . l , _it . r , 1 ); for ( auto & it : _it . vec ) { res [ it . fi ] = tseg . query ( 1 , 1 , _n , it . se ); } } } for ( int i = 1 ; i <= q ; ++ i ) if ( isQuery [ i ]) printf ( \"%d \\n \" , res [ i ] % 256 ); return 0 ; } L. Carry Cam Failure Solved By ltslts. 1:59(+) \u9898\u610f\uff1a \u5b9a\u4e49\u5341\u8fdb\u5236\u4e0b\u7684\u5f02\u6216\u548c\uff08\u5373\u4e0d\u8fdb\u4f4d\u52a0\u6cd5\uff09\uff0c\u548c\u4ee5\u6b64\u4e3a\u57fa\u7840\u7684\u4e58\u6cd5\u8fd0\u7b97\u3002\u7ed9\u51fa\u4e00\u4e2a n n \uff0c\u6c42 n n \u5728\u8fd9\u4e2a\u89c4\u5219\u4e0b\u7684\u6700\u5c0f\u7684\u5e73\u65b9\u6839\uff0c\u5982\u679c\u4e0d\u5b58\u5728\u8f93\u51fa -1 -1 \u3002 \u601d\u8def\uff1a \u56e0\u4e3a\u4e0d\u4f1a\u8fdb\u4f4d\uff0c\u6240\u4ee5 n n \u5982\u679c\u62e5\u6709\u5076\u6570\u4f4d\uff0c\u80af\u5b9a\u4e0d\u5b58\u5728\u5e73\u65b9\u6839\uff0c\u6240\u4ee5\u5e73\u65b9\u6839\u7684\u957f\u5ea6\u4e3a \\displaystyle \\frac{len(n)+1}{2} \\displaystyle \\frac{len(n)+1}{2} \u3002\u56e0\u4e3a len(n)<= 25 len(n)<= 25 \uff0c\u5e76\u4e14\u5e73\u65b9\u6839\u6bcf\u4e00\u4f4d\u53ef\u80fd\u7684\u6570\u5b57\u6700\u591a\u53ea\u6709\u4e24\u4e2a\uff0c\u66b4\u529b\u641c\u7d22\u8bb0\u5f55\u6700\u5c0f\u7684\u5408\u6cd5\u7684\u5e73\u65b9\u6839\u5373\u53ef\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 \\displaystyle O(2^{len(n) / 2}) \\displaystyle O(2^{len(n) / 2}) \u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 100 ; string st ; int a [ N ], b [ N ]; int n ; bool flag ; long long ans ; void gao ( int t ) { if ( t > ( n + 1 ) / 2 ) { for ( int i = t ; i <= n ; ++ i ) { int x = 0 ; for ( int j = 1 ; j < t ; ++ j ) { x += b [ j ] * b [ i - j + 1 ]; } x = x % 10 ; if ( x != a [ i ]) return ; } flag = false ; long long y = 0 ; for ( int i = t - 1 ; i > 0 ; -- i ) y = y * 10 + b [ i ]; if ( y < ans ) ans = y ; } else for ( int i = 0 ; i < 10 ; ++ i ) { int x = 0 , y = 0 ; b [ t ] = i ; for ( int j = 1 ; j <= t ; ++ j ) { x += b [ j ] * b [ t - j + 1 ]; } x = x % 10 ; if ( x == a [ t ]) gao ( t + 1 ); } } int main () { cin >> st ; n = st . length (); ans = 100000000000000 ; for ( int i = 0 ; i < n ; ++ i ) { a [ n - i ] = st [ i ] - 48 ; } if ( n & 1 ) { flag = true ; gao ( 1 ); if ( flag ) cout << -1 << endl ; else cout << ans << endl ; } else cout << -1 << endl ; return 0 ; } M. Maze Connec Solved By Hsueh-. 2:10(+) \u9898\u610f\uff1a \u601d\u8def\uff1a \u5b58\u5728\u4e00\u5f20\u8ff7\u5bab\uff0c\u5c06\u5176\u65cb\u8f6c 45^o 45^o \uff0c\u95ee\u6700\u5c0f\u7834\u574f\u51e0\u9762\u5899\u4f7f\u5f97\u6240\u6709\u4f4d\u7f6e\u90fd\u53ef\u4ee5\u9003\u51fa\u8ff7\u5bab \u7b54\u6848\u5f88\u663e\u7136\u662f\u8054\u901a\u5757\u6570\u91cf\u51cf\u4e00\uff0c\u7136\u540e\u7814\u7a76\u4e00\u4e0b\u8054\u901a\u89c4\u5219\u5224\u65ad\u5373\u53ef Code #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 ; int n , m ; char s [ N ][ N ]; int vis [ N ][ N ]; void gao ( int x , int y ) { if ( x < 0 || x > n + 1 || y < 0 || y > m + 1 ) return ; vis [ x ][ y ] = true ; if ( s [ x + 1 ][ y ] == '.' && ! vis [ x + 1 ][ y ]) gao ( x + 1 , y ); if ( s [ x - 1 ][ y ] == '.' && ! vis [ x - 1 ][ y ]) gao ( x - 1 , y ); if ( s [ x ][ y + 1 ] == '.' && ! vis [ x ][ y + 1 ]) gao ( x , y + 1 ); if ( s [ x ][ y - 1 ] == '.' && ! vis [ x ][ y - 1 ]) gao ( x , y - 1 ); if ( s [ x + 1 ][ y + 1 ] == '.' && ! vis [ x + 1 ][ y + 1 ] && s [ x + 1 ][ y ] == '\\\\' ) gao ( x + 1 , y + 1 ); if ( s [ x - 1 ][ y + 1 ] == '.' && ! vis [ x - 1 ][ y + 1 ] && s [ x - 1 ][ y ] == '/' ) gao ( x - 1 , y + 1 ); if ( s [ x + 1 ][ y - 1 ] == '.' && ! vis [ x + 1 ][ y - 1 ] && s [ x + 1 ][ y ] == '/' ) gao ( x + 1 , y - 1 ); if ( s [ x - 1 ][ y - 1 ] == '.' && ! vis [ x - 1 ][ y - 1 ] && s [ x - 1 ][ y ] == '\\\\' ) gao ( x - 1 , y - 1 ); } int main () { scanf ( \"%d %d\" , & n , & m ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%s\" , s [ i ] + 1 ); for ( int i = 0 ; i <= m + 1 ; ++ i ) { gao ( 0 , i ); gao ( n + 1 , i ); } for ( int i = 0 ; i <= n + 1 ; ++ i ) { gao ( i , 0 ); gao ( i , m + 1 ); } int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( s [ i ][ j ] == '/' && s [ i ][ j + 1 ] == '\\\\' && s [ i + 1 ][ j ] == '\\\\' && s [ i + 1 ][ j + 1 ] == '/' ) res ++ ; else if ( s [ i ][ j ] == '.' && ! vis [ i ][ j ]) { res ++ ; gao ( i , j ); } } } printf ( \"%d \\n \" , res ); return 0 ; }","title":"2019-2020 ACM-ICPC Pacific Northwest Regional Contest (Div. 1)"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-1/#contest-info","text":"Practice Link Editorials Link Solved A B C D E F G H I J K L M 9/13 O O O O O - - - O - O O O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 - \u6ca1\u6709\u5c1d\u8bd5","title":"Contest Info"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-1/#solutions","text":"","title":"Solutions"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-1/#a-radio-prize","text":"Solved By Dup4. 2:26(+) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u68f5\u6811\uff0c\u6bcf\u4e2a\u70b9\u6709\u70b9\u6743 t_i t_i , \u6bcf\u6761\u8fb9\u6709\u8fb9\u6743 w_i w_i , \u73b0\u5728\u8981\u5bf9\u4e8e\u6bcf\u4e2a\u70b9 i i \uff0c\u8ba1\u7b97 \\sum\\limits_{j = 1}^n [i \\neq j](t_i + t_j) \\cdot d(i, j) \\sum\\limits_{j = 1}^n [i \\neq j](t_i + t_j) \\cdot d(i, j) \uff0c\u5176\u4e2d d(i, j) d(i, j) \u8868\u793a i \\to j i \\to j \u7684\u7b80\u5355\u8def\u5f84\u7684\u957f\u5ea6\u3002 \u601d\u8def\uff1a \u5c06\u8d21\u732e\u62c6\u6210 t_id(i, j) + t_jd(i, j) t_id(i, j) + t_jd(i, j) \uff0c\u7136\u540e\u7ef4\u62a4\u8ddd\u79bb\u548c\u3001\u70b9\u6743\u548c\u3001\u4e58\u79ef\u548c\uff0c\u6362\u6839 dp \u5373\u53ef\u3002 Code #include <bits/stdc++.h> #define fi first #define se second using namespace std ; using ll = long long ; using pLL = pair < ll , ll > ; const int N = 1e5 + 10 ; int n , a [ N ], fa [ N ], sze [ N ]; ll res [ N ]; struct Graph { struct E { int to , nx , w ; } e [ N << 1 ]; int h [ N ], cnt ; void init ( int n ) { for ( int i = 0 ; i <= n ; ++ i ) h [ i ] = -1 ; cnt = -1 ; } void addedge ( int u , int v , int w = 0 ) { e [ ++ cnt ] = { v , h [ u ], w }; h [ u ] = cnt ; } } G ; struct E { ll Sdis , Sval , S ; } f [ N ], g [ N ]; void dfs ( int u ) { f [ u ] = { 0 , 0 , 0 }; sze [ u ] = 1 ; for ( int i = G . h [ u ]; ~ i ; i = G . e [ i ]. nx ) { int v = G . e [ i ]. to , w = G . e [ i ]. w ; if ( v == fa [ u ]) continue ; fa [ v ] = u ; dfs ( v ); sze [ u ] += sze [ v ]; f [ u ]. Sdis += f [ v ]. Sdis + 1l l * sze [ v ] * w ; f [ u ]. Sval += f [ v ]. Sval ; f [ u ]. S += f [ v ]. S + f [ v ]. Sval * w ; } res [ u ] += 1l l * a [ u ] * f [ u ]. Sdis + f [ u ]. S ; f [ u ]. Sval += a [ u ]; } void dfs1 ( int u ) { for ( int i = G . h [ u ]; ~ i ; i = G . e [ i ]. nx ) { int v = G . e [ i ]. to , w = G . e [ i ]. w ; if ( v == fa [ u ]) continue ; g [ v ]. Sdis = g [ u ]. Sdis + f [ u ]. Sdis - f [ v ]. Sdis - 1l l * sze [ v ] * w + 1l l * ( n - sze [ v ]) * w ; g [ v ]. Sval = g [ u ]. Sval + f [ u ]. Sval - f [ v ]. Sval ; g [ v ]. S = g [ u ]. S + f [ u ]. S - f [ v ]. S - f [ v ]. Sval * w + g [ v ]. Sval * w ; res [ v ] += 1l l * a [ v ] * g [ v ]. Sdis + g [ v ]. S ; dfs1 ( v ); } } int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , a + i ), res [ i ] = 0 ; G . init ( n ); for ( int i = 1 , u , v , w ; i < n ; ++ i ) { scanf ( \"%d%d%d\" , & u , & v , & w ); G . addedge ( u , v , w ); G . addedge ( v , u , w ); } dfs ( 1 ); g [ 1 ] = { 0 , 0 , 0 }; dfs1 ( 1 ); for ( int i = 1 ; i <= n ; ++ i ) printf ( \"%lld \\n \" , res [ i ]); return 0 ; }","title":"A. Radio Prize"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-1/#b-perfect-flush","text":"Solved By Hsueh-. 3:00(+1) \u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u6570 x_i x_i , \u4fdd\u8bc1 1 \\leq x_i \\leq k 1 \\leq x_i \\leq k \uff0c\u5e76\u4e14\u4fdd\u8bc1 1, \\cdots k 1, \\cdots k \u4e2d\u6bcf\u4e2a\u6570\u81f3\u5c11\u51fa\u73b0\u4e86\u4e00\u6b21\uff0c\u73b0\u5728\u8981\u627e\u51fa\u4e00\u4e2a\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u5b50\u5e8f\u5217\uff0c\u4f7f\u5f97\u8fd9\u4e2a\u5b50\u5e8f\u5217\u662f\u4e00\u4e2a\u957f\u5ea6\u4e3a k k \u7684\u6392\u5217\u3002 \u601d\u8def\uff1a \u5229\u7528\u5355\u8c03\u6808\uff0c\u5982\u679c\u6808\u9876\u5143\u7d20\u5728\u540e\u9762\u5b58\u5728\u4e14\u6bd4\u5f53\u524d\u5143\u7d20\u5927\uff0c\u5219 pop \u6389\uff0c\u5982\u679c\u5f53\u524d\u5143\u7d20\u672c\u8eab\u5c31\u5728\u6808\u4e2d\u5219 continue\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 2e5 + 10 ; int n , k ; int a [ N ]; int res [ N ]; int cnt [ N ]; int in [ N ]; stack < int > st ; int main () { scanf ( \"%d %d\" , & n , & k ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , a + i ); cnt [ a [ i ]] ++ ; } for ( int i = 1 ; i <= n ; ++ i ) { cnt [ a [ i ]] -- ; if ( in [ a [ i ]]) continue ; while ( ! st . empty () && a [ i ] < st . top () && cnt [ st . top ()]) { in [ st . top ()] = 0 ; st . pop (); } in [ a [ i ]] = 1 ; st . push ( a [ i ]); } for ( int i = k ; i >= 1 ; -- i ) { res [ i ] = st . top (); st . pop (); } for ( int i = 1 ; i <= k ; ++ i ) { printf ( \"%d%c\" , res [ i ], \" \\n \" [ i == k ]); } return 0 ; }","title":"B. Perfect Flush"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-1/#c-coloring-contention","text":"Solved By Hsueh-. 0:48(+) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a n n \u4e2a\u70b9 m m \u6761\u8fb9\u7684\u65e0\u5411\u56fe\uff0c\u6ca1\u6709\u91cd\u8fb9\uff0c\u6ca1\u6709\u81ea\u73af\uff0c Alice \u53ef\u4ee5\u5c06\u8fb9\u67d3\u6210\u7ea2\u8272\u6216\u8005\u84dd\u8272\uff0c\u5b9a\u4e49\u4e00\u6761\u8def\u5f84\u7684 color change \u6b21\u6570\u4e3a\u5c06\u8def\u5f84\u4e0a\u7ecf\u8fc7\u7684\u8fb9\u6309\u987a\u5e8f\u6392\u5217\uff0c\u4efb\u610f\u4e24\u4e2a\u76f8\u90bb\u7684\u8fb9\u989c\u8272\u4e0d\u540c\u5373\u8bb0\u4e00\u6b21 color change \u3002 \u73b0\u5728 Bob \u8981\u9009\u62e9\u4e00\u6761 1 \\to n 1 \\to n \u7684\u8def\u5f84\uff0c\u95ee Alice \u5982\u679c\u67d3\u8272\uff0c\u4f7f\u5f97 Bob \u7684\u6700\u4f18\u89e3\u6700\u5927\uff0c\u5373 color change \u6b21\u6570\u6700\u591a\u3002\u8f93\u51fa\u8fd9\u4e2a\u6700\u5927\u503c\u3002 \u601d\u8def\uff1a \u663e\u7136\u7b54\u6848\u7684\u4e0a\u754c\u4e3a 1 \\to n 1 \\to n \u7684 \\mbox{\u6700\u77ed\u8def\u957f\u5ea6} - 1 \\mbox{\u6700\u77ed\u8def\u957f\u5ea6} - 1 \uff0c\u731c\u6d4b\u4e00\u5b9a\u80fd\u6709\u4e00\u79cd\u65b9\u6848\u80fd\u591f\u505a\u5230\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e5 + 10 , INF = 1e9 ; int n , m ; vector < vector < int >> G ; int dis [ N ], use [ N ]; void bfs ( int st ) { for ( int i = 1 ; i <= n ; ++ i ) { dis [ i ] = INF ; use [ i ] = 0 ; } queue < int > que ; que . push ( st ); dis [ st ] = 0 ; use [ st ] = 1 ; while ( ! que . empty ()) { int u = que . front (); que . pop (); for ( auto & v : G [ u ]) { if ( dis [ v ] > dis [ u ] + 1 ) { dis [ v ] = dis [ u ] + 1 ; que . push ( v ); } } } } int main () { scanf ( \"%d%d\" , & n , & m ); G . clear (); G . resize ( n + 1 ); for ( int i = 1 , u , v ; i <= m ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); G [ u ]. push_back ( v ); G [ v ]. push_back ( u ); } bfs ( 1 ); printf ( \"%d \\n \" , dis [ n ] - 1 ); return 0 ; }","title":"C. Coloring Contention"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-1/#d-dividing-by-two","text":"Solved By Hsueh-. 0:14(+) \u9898\u610f\uff1a \u7ed9\u5b9a\u4e24\u4e2a\u6570\u5b57 A A , B B \uff0c\u5bf9\u4e8e A A \u6709\u4e24\u79cd\u64cd\u4f5c\uff1a \u5f53 A A \u662f\u5076\u6570\u5219\u53ef\u4ee5\u9664\u4ee5 2 2 \u3002 \u52a0\u4e00\u3002 \u95ee\u6700\u5c0f\u7684\u64cd\u4f5c\u6b21\u6570\u4f7f\u5f97 A \u53d8\u6210 B\u3002 \u601d\u8def\uff1a \u5982\u679c A < B A < B \u5219\u5f88\u663e\u7136\u7b54\u6848\u662f\u4e24\u8005\u5dee\u503c\u3002 \u5982\u679c A = B A = B \u5219\u5f88\u663e\u7136\u7b54\u6848\u662f 0 0 \u3002 \u5269\u4e0b\u7684\u6a21\u62df\u5373\u53ef. Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; ll a , b ; int main () { scanf ( \"%lld %lld\" , & a , & b ); ll res = 0 ; while ( a > b ) { if ( a & 1 ) ++ a ; else a /= 2 ; ++ res ; } res += b - a ; printf ( \"%lld \\n \" , res ); return 0 ; }","title":"D. Dividing by Two"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-1/#e-rainbow-strings","text":"Solved By Hsueh-. 0:18(+) \u9898\u610f\uff1a \u5b9a\u4e49\u4e00\u4e2a rainbow string \u4e3a\u5b57\u7b26\u4e32\u4e2d\u4efb\u610f\u4e24\u4e2a\u5b57\u7b26\u90fd\u4e0d\u76f8\u540c\uff0c\u73b0\u5728\u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32 s s \uff0c\u95ee\u5b83\u6709\u591a\u5c11\u4e2a\u5b50\u5e8f\u5217\u662f rainbow string \u3002 \u601d\u8def\uff1a \u7b54\u6848\u4e3a \\prod (\\mbox{\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u6b21\u6570 + 1}) \\prod (\\mbox{\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u6b21\u6570 + 1}) \u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 1e5 + 10 ; const ll p = 11092019 ; char s [ N ]; ll cnt [ N ]; int main () { scanf ( \"%s\" , s + 1 ); int n = strlen ( s + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { cnt [ s [ i ]] ++ ; } ll res = 1 ; for ( int i = 'a' ; i <= 'z' ; ++ i ) { res = res * ( cnt [ i ] + 1 ) % p ; } printf ( \"%lld \\n \" , res ); return 0 ; }","title":"E. Rainbow Strings"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-1/#f-carny-magician","text":"UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"F. Carny Magician"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-1/#g-glow-little-pixel-glow","text":"UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"G. Glow, Little Pixel, Glow"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-1/#h-pivoting-points","text":"UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"H. Pivoting Points"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-1/#ierror-correction","text":"Solved By Hsueh- & Dup4. 1:28(+1) \u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u5b57\u7b26\u4e32\uff0c\u6bcf\u4e2a\u5b57\u7b26\u4e32\u7b49\u957f\uff0c\u5e76\u4e14\u4efb\u610f\u4e24\u4e2a\u5b57\u7b26\u4e0d\u76f8\u540c\uff0c\u5b9a\u4e49\u4efb\u610f\u4e24\u4e2a\u5b57\u7b26\u4e32\u4e0d\u53ef\u4ee5\u5171\u5b58\u5f53\u4e14\u4ec5\u5f53\u5176\u4e2d\u4e00\u4e2a\u5b57\u7b26\u4e32\u53ef\u4ee5\u901a\u8fc7\u4ea4\u6362\u4e00\u5bf9\u5b57\u7b26\u53d8\u6210\u53e6\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u73b0\u5728\u8981\u6c42\u9009\u51fa\u6700\u5927\u7684\u5b57\u7b26\u4e32\u5b50\u96c6\uff0c\u4f7f\u5f97\u5176\u4e2d\u4efb\u610f\u4e24\u4e2a\u5b57\u7b26\u4e32\u90fd\u53ef\u4ee5\u5171\u5b58\u3002 \u601d\u8def\uff1a \u5c06\u4e0d\u80fd\u5171\u5b58\u7684\u8fde\u8fb9\uff0c\u7b49\u4ef7\u4e8e\u6c42\u6700\u5927\u72ec\u7acb\u96c6\u3002 \u4f46\u662f\u6c42\u6700\u5927\u72ec\u7acb\u96c6\u7684\u6734\u7d20\u7b97\u6cd5\u662f O(n^4) O(n^4) \uff0c\u4f46\u662f\u5982\u679c\u5b83\u662f\u4e8c\u5206\u56fe\uff0c\u5c31\u7b49\u4ef7\u4e8e\u6c42\u6700\u5927\u5339\u914d\u3002 \u90a3\u4e48\u8003\u8651\u8be5\u56fe\u4e2d\u4e0d\u4f1a\u6709\u5947\u73af\uff0c\u56e0\u4e3a\u4e00\u6b21\u4ea4\u6362\u53ef\u4ee5\u7406\u89e3\u4e3a\u4e00\u4e2a\u9006\u5e8f\u5bf9\uff0c\u4e00\u4e2a\u5b57\u7b26\u4e32\u7ecf\u8fc7\u82e5\u5e72\u6b21\u4ea4\u6362\u56de\u5230\u672c\u8eab\uff0c\u80af\u5b9a\u662f\u7ecf\u8fc7\u5076\u6570\u6b21\u4ea4\u6362\u3002 \u90a3\u4e48\u6839\u636e\u9006\u5e8f\u5bf9\u6570\u91cf\u7684\u5947\u5076\u6027\u5c06\u5b57\u7b26\u4e32\u5206\u6210\u5de6\u53f3\u4e24\u8fb9\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 5e2 + 10 ; int n ; int inv [ N ]; string s [ N ]; vector < vector < int > > G ; int linker [ N ], used [ N ]; bool dfs ( int u ) { for ( auto v : G [ u ]) { if ( ! used [ v ]) { used [ v ] = true ; if ( linker [ v ] == -1 || dfs ( linker [ v ])) { linker [ v ] = u ; return true ; } } } return false ; } int hungray () { int res = 0 ; memset ( linker , -1 , sizeof linker ); for ( int u = 1 ; u <= n ; ++ u ) { if ( inv [ u ] % 2 == 0 ) continue ; memset ( used , false , sizeof used ); if ( dfs ( u )) ++ res ; } return res ; } int main () { ios :: sync_with_stdio ( false ); cin . tie ( nullptr ), cout . tie ( nullptr ); cin >> n ; G . resize ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { cin >> s [ i ]; } for ( int i = 1 ; i <= n ; ++ i ) { int sze = s [ i ]. size (); for ( int j = 1 ; j <= n ; ++ j ) { int cnt = 0 ; for ( int k = 0 ; k < sze ; ++ k ) { cnt += s [ i ][ k ] != s [ j ][ k ]; } if ( cnt == 2 ) { G [ i ]. push_back ( j ); } } for ( int j = 0 ; j < sze ; ++ j ) { for ( int k = j + 1 ; k < sze ; ++ k ) { inv [ i ] += ( s [ i ][ j ] > s [ i ][ k ]); } } } // for (int i = 1; i <= n; ++i) { // cout << i << \" \" << inv[i] % 2 << endl; // } int res = hungray (); // cout << res << endl; cout << n - res << endl ; return 0 ; }","title":"I.Error Correction"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-1/#j-interstellar-travel","text":"UnSolved. \u9898\u610f\uff1a \u601d\u8def\uff1a","title":"J. Interstellar Travel"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-1/#k-computer-cache","text":"Solved By Dup4. 3:40(+) \u9898\u610f\uff1a \u6709 m m \u4e2a\u6570\u636e\u5757\uff0c\u7b2c i i \u4e2a\u6570\u636e\u5757\u7684\u957f\u5ea6\u4e3a s_i s_i \u3002 \u6709\u4e00\u4e2a cache \uff0c\u652f\u6301\u4e09\u79cd\u64cd\u4f5c\uff1a 1 i p , \u5c06\u7b2c i i \u4e2a\u6570\u636e\u5757\u52a0\u8f7d\u8fdb cache , \u8d77\u59cb\u4f4d\u7f6e\u4e3a p p \u3002 2 p , \u8f93\u51fa cache \u4e2d\u7b2c p p \u4e2a\u4f4d\u7f6e\u7684\u6570\u503c\u3002 3 i l r , \u5c06\u7b2c i i \u4e2a\u6570\u636e\u5757\u4e2d\u7684 [l, r] [l, r] \u4e2d\u6bcf\u4e2a\u6570\u5b57\u90fd +1 \\bmod 256 +1 \\bmod 256 \uff0c\u5373 x_i = (x_i + 1) \\bmod 256 x_i = (x_i + 1) \\bmod 256 \u3002 \u601d\u8def\uff1a \u8003\u8651\u67e5\u8be2\u53ef\u80fd\u4f1a\u67e5\u8be2\u5386\u53f2\u7248\u672c\uff0c\u5bb9\u6613\u60f3\u5230\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\u3002 \u4f46\u662f 5 \\cdot 10^5 5 \\cdot 10^5 \u7684\u6570\u636e\u91cf\uff0c\u5728\u65f6\u95f4\u548c\u7a7a\u95f4\u4e0a\u90fd\u4e0d\u592a\u5141\u8bb8\uff0c\u53ef\u4ee5\u76f4\u63a5\u79bb\u7ebf\uff0c\u8bb0\u5f55\u7248\u672c\u53f7\u3002 Code #include <bits/stdc++.h> #define SZ(x) (int(x.size())) #define fi first #define se second using namespace std ; using ll = long long ; using pII = pair < int , int > ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } const int N = 5e5 + 10 ; int n , m , q , ver [ N ], sze [ N ], res [ N ], isQuery [ N ]; vector < vector < int >> vec ; struct W { int i , p , ver ; }; struct SEG { struct node { W val , lazy ; void init () { val = lazy = { -1 , -1 , -1 }; } void up ( W _lazy ) { val = _lazy ; lazy = _lazy ; } } t [ N << 2 ], res ; void down ( int id ) { W & lazy = t [ id ]. lazy ; if ( lazy . i == -1 ) return ; t [ id << 1 ]. up ( lazy ); t [ id << 1 | 1 ]. up ( lazy ); lazy = { -1 , -1 , -1 }; } void build ( int id , int l , int r ) { t [ id ]. init (); if ( l == r ) return ; int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid ); build ( id << 1 | 1 , mid + 1 , r ); } void update ( int id , int l , int r , int ql , int qr , W v ) { if ( l >= ql && r <= qr ) { t [ id ]. up ( v ); return ; } int mid = ( l + r ) >> 1 ; down ( id ); if ( ql <= mid ) update ( id << 1 , l , mid , ql , qr , v ); if ( qr > mid ) update ( id << 1 | 1 , mid + 1 , r , ql , qr , v ); } W query ( int id , int l , int r , int pos ) { if ( l == r ) return t [ id ]. val ; int mid = ( l + r ) >> 1 ; down ( id ); if ( pos <= mid ) return query ( id << 1 , l , mid , pos ); else return query ( id << 1 | 1 , mid + 1 , r , pos ); } } seg ; struct TSEG { struct node { int lazy , sum ; node () { lazy = sum = 0 ; } void up ( int _lazy ) { sum += _lazy ; lazy += _lazy ; } node operator + ( const node & other ) const { node res = node (); res . sum = sum + other . sum ; return res ; } } t [ N << 2 ]; void down ( int id ) { int & lazy = t [ id ]. lazy ; t [ id << 1 ]. up ( lazy ); t [ id << 1 | 1 ]. up ( lazy ); lazy = 0 ; } void build ( int id , int l , int r , const vector < int > & a ) { if ( l == r ) { t [ id ]. sum = a [ l ]; return ; } int mid = ( l + r ) >> 1 ; build ( id << 1 , l , mid , a ); build ( id << 1 | 1 , mid + 1 , r , a ); t [ id ] = t [ id << 1 ] + t [ id << 1 | 1 ]; } void update ( int id , int l , int r , int ql , int qr , int v ) { if ( l >= ql && r <= qr ) { t [ id ]. up ( v ); return ; } int mid = ( l + r ) >> 1 ; down ( id ); if ( ql <= mid ) update ( id << 1 , l , mid , ql , qr , v ); if ( qr > mid ) update ( id << 1 | 1 , mid + 1 , r , ql , qr , v ); } int query ( int id , int l , int r , int pos ) { if ( l == r ) return t [ id ]. sum ; int mid = ( l + r ) >> 1 ; down ( id ); if ( pos <= mid ) return query ( id << 1 , l , mid , pos ); else return query ( id << 1 | 1 , mid + 1 , r , pos ); } } tseg ; struct E { int l , r ; vector < pII > vec ; }; vector < vector < E >> OP ; int main () { scanf ( \"%d%d%d\" , & n , & m , & q ); vec . resize ( m + 1 ); OP . clear (); OP . resize ( m + 1 ); seg . build ( 1 , 1 , n ); for ( int i = 1 , sz ; i <= m ; ++ i ) { scanf ( \"%d\" , & sz ); sze [ i ] = sz ; ver [ i ] = 0 ; vector < int > tmp ( sz + 1 ); for ( int j = 1 , x ; j <= sz ; ++ j ) { scanf ( \"%d\" , & x ); tmp [ j ] = x ; } vec [ i ] = tmp ; // dbg(i, sz); } for ( int _q = 1 ; _q <= q ; ++ _q ) { isQuery [ _q ] = 0 ; int op , i , l , r , p ; scanf ( \"%d\" , & op ); if ( op == 1 ) { scanf ( \"%d%d\" , & i , & p ); seg . update ( 1 , 1 , n , p , p + sze [ i ] - 1 , { i , p , ver [ i ]}); } else if ( op == 2 ) { scanf ( \"%d\" , & p ); isQuery [ _q ] = 1 ; W tmp = seg . query ( 1 , 1 , n , p ); // dbg(_q, tmp.i, tmp.p, tmp.ver); if ( tmp . i == -1 ) { res [ _q ] = 0 ; } else if ( tmp . ver == 0 ) { res [ _q ] = vec [ tmp . i ][ p - tmp . p + 1 ]; } else { // dbg(_q); OP [ tmp . i ][ tmp . ver - 1 ]. vec . push_back ( pII ( _q , p - tmp . p + 1 )); } } else { scanf ( \"%d%d%d\" , & i , & l , & r ); ++ ver [ i ]; OP [ i ]. push_back ({ l , r , {}}); } } for ( int i = 1 ; i <= m ; ++ i ) { int _n = sze [ i ]; tseg . build ( 1 , 1 , _n , vec [ i ]); for ( auto & _it : OP [ i ]) { tseg . update ( 1 , 1 , _n , _it . l , _it . r , 1 ); for ( auto & it : _it . vec ) { res [ it . fi ] = tseg . query ( 1 , 1 , _n , it . se ); } } } for ( int i = 1 ; i <= q ; ++ i ) if ( isQuery [ i ]) printf ( \"%d \\n \" , res [ i ] % 256 ); return 0 ; }","title":"K. Computer Cache"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-1/#l-carry-cam-failure","text":"Solved By ltslts. 1:59(+) \u9898\u610f\uff1a \u5b9a\u4e49\u5341\u8fdb\u5236\u4e0b\u7684\u5f02\u6216\u548c\uff08\u5373\u4e0d\u8fdb\u4f4d\u52a0\u6cd5\uff09\uff0c\u548c\u4ee5\u6b64\u4e3a\u57fa\u7840\u7684\u4e58\u6cd5\u8fd0\u7b97\u3002\u7ed9\u51fa\u4e00\u4e2a n n \uff0c\u6c42 n n \u5728\u8fd9\u4e2a\u89c4\u5219\u4e0b\u7684\u6700\u5c0f\u7684\u5e73\u65b9\u6839\uff0c\u5982\u679c\u4e0d\u5b58\u5728\u8f93\u51fa -1 -1 \u3002 \u601d\u8def\uff1a \u56e0\u4e3a\u4e0d\u4f1a\u8fdb\u4f4d\uff0c\u6240\u4ee5 n n \u5982\u679c\u62e5\u6709\u5076\u6570\u4f4d\uff0c\u80af\u5b9a\u4e0d\u5b58\u5728\u5e73\u65b9\u6839\uff0c\u6240\u4ee5\u5e73\u65b9\u6839\u7684\u957f\u5ea6\u4e3a \\displaystyle \\frac{len(n)+1}{2} \\displaystyle \\frac{len(n)+1}{2} \u3002\u56e0\u4e3a len(n)<= 25 len(n)<= 25 \uff0c\u5e76\u4e14\u5e73\u65b9\u6839\u6bcf\u4e00\u4f4d\u53ef\u80fd\u7684\u6570\u5b57\u6700\u591a\u53ea\u6709\u4e24\u4e2a\uff0c\u66b4\u529b\u641c\u7d22\u8bb0\u5f55\u6700\u5c0f\u7684\u5408\u6cd5\u7684\u5e73\u65b9\u6839\u5373\u53ef\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 \\displaystyle O(2^{len(n) / 2}) \\displaystyle O(2^{len(n) / 2}) \u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 100 ; string st ; int a [ N ], b [ N ]; int n ; bool flag ; long long ans ; void gao ( int t ) { if ( t > ( n + 1 ) / 2 ) { for ( int i = t ; i <= n ; ++ i ) { int x = 0 ; for ( int j = 1 ; j < t ; ++ j ) { x += b [ j ] * b [ i - j + 1 ]; } x = x % 10 ; if ( x != a [ i ]) return ; } flag = false ; long long y = 0 ; for ( int i = t - 1 ; i > 0 ; -- i ) y = y * 10 + b [ i ]; if ( y < ans ) ans = y ; } else for ( int i = 0 ; i < 10 ; ++ i ) { int x = 0 , y = 0 ; b [ t ] = i ; for ( int j = 1 ; j <= t ; ++ j ) { x += b [ j ] * b [ t - j + 1 ]; } x = x % 10 ; if ( x == a [ t ]) gao ( t + 1 ); } } int main () { cin >> st ; n = st . length (); ans = 100000000000000 ; for ( int i = 0 ; i < n ; ++ i ) { a [ n - i ] = st [ i ] - 48 ; } if ( n & 1 ) { flag = true ; gao ( 1 ); if ( flag ) cout << -1 << endl ; else cout << ans << endl ; } else cout << -1 << endl ; return 0 ; }","title":"L. Carry Cam Failure"},{"location":"trainings/random-trainings/2019-2020-ACM-ICPC-Pacific-Northwest-Regional-Contest-Div-1/#m-maze-connec","text":"Solved By Hsueh-. 2:10(+) \u9898\u610f\uff1a \u601d\u8def\uff1a \u5b58\u5728\u4e00\u5f20\u8ff7\u5bab\uff0c\u5c06\u5176\u65cb\u8f6c 45^o 45^o \uff0c\u95ee\u6700\u5c0f\u7834\u574f\u51e0\u9762\u5899\u4f7f\u5f97\u6240\u6709\u4f4d\u7f6e\u90fd\u53ef\u4ee5\u9003\u51fa\u8ff7\u5bab \u7b54\u6848\u5f88\u663e\u7136\u662f\u8054\u901a\u5757\u6570\u91cf\u51cf\u4e00\uff0c\u7136\u540e\u7814\u7a76\u4e00\u4e0b\u8054\u901a\u89c4\u5219\u5224\u65ad\u5373\u53ef Code #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 ; int n , m ; char s [ N ][ N ]; int vis [ N ][ N ]; void gao ( int x , int y ) { if ( x < 0 || x > n + 1 || y < 0 || y > m + 1 ) return ; vis [ x ][ y ] = true ; if ( s [ x + 1 ][ y ] == '.' && ! vis [ x + 1 ][ y ]) gao ( x + 1 , y ); if ( s [ x - 1 ][ y ] == '.' && ! vis [ x - 1 ][ y ]) gao ( x - 1 , y ); if ( s [ x ][ y + 1 ] == '.' && ! vis [ x ][ y + 1 ]) gao ( x , y + 1 ); if ( s [ x ][ y - 1 ] == '.' && ! vis [ x ][ y - 1 ]) gao ( x , y - 1 ); if ( s [ x + 1 ][ y + 1 ] == '.' && ! vis [ x + 1 ][ y + 1 ] && s [ x + 1 ][ y ] == '\\\\' ) gao ( x + 1 , y + 1 ); if ( s [ x - 1 ][ y + 1 ] == '.' && ! vis [ x - 1 ][ y + 1 ] && s [ x - 1 ][ y ] == '/' ) gao ( x - 1 , y + 1 ); if ( s [ x + 1 ][ y - 1 ] == '.' && ! vis [ x + 1 ][ y - 1 ] && s [ x + 1 ][ y ] == '/' ) gao ( x + 1 , y - 1 ); if ( s [ x - 1 ][ y - 1 ] == '.' && ! vis [ x - 1 ][ y - 1 ] && s [ x - 1 ][ y ] == '\\\\' ) gao ( x - 1 , y - 1 ); } int main () { scanf ( \"%d %d\" , & n , & m ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%s\" , s [ i ] + 1 ); for ( int i = 0 ; i <= m + 1 ; ++ i ) { gao ( 0 , i ); gao ( n + 1 , i ); } for ( int i = 0 ; i <= n + 1 ; ++ i ) { gao ( i , 0 ); gao ( i , m + 1 ); } int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { if ( s [ i ][ j ] == '/' && s [ i ][ j + 1 ] == '\\\\' && s [ i + 1 ][ j ] == '\\\\' && s [ i + 1 ][ j + 1 ] == '/' ) res ++ ; else if ( s [ i ][ j ] == '.' && ! vis [ i ][ j ]) { res ++ ; gao ( i , j ); } } } printf ( \"%d \\n \" , res ); return 0 ; }","title":"M. Maze Connec"},{"location":"trainings/random-trainings/2020-XIII-Samara-Regional-Intercollegiate-Programming-Contest/","text":"2020, XIII Samara Regional Intercollegiate Programming Contest Contents Contest Info Solutions A. Array\u2019s Hash B. Bonuses on a Line C. Manhattan Distance D. Lexicographically Minimal Shortest Path E. Fluctuations of Mana F. Moving Target G. Nuts and Bolts H. Tree Painting I. Sorting Colored Array J. The Battle of Mages K. Table L. The Dragon Land M. Notifications Contest Info Practice Link Solved A B C D E F G H I J K L M 13/13 O O O O O O O O O O O O O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 . \u6ca1\u6709\u5c1d\u8bd5 Solutions A. Array\u2019s Hash Solved By Hsueh-. 0:29(+) \u9898\u610f\uff1a \u7ed9\u5b9a\u4e00\u4e2a\u5e8f\u5217\uff0c\u6bcf\u6b21\u5c06 a_2 a_2 \u548c a_1 a_1 \u62ff\u51fa\u6765\uff0c\u7136\u540e\u5c06 a_2-a_1 a_2-a_1 \u63d2\u5165\u5230\u5e8f\u5217\u4e2d\uff0c\u95ee\u6700\u540e\u7684\u5e8f\u5217\u7ed3\u679c\u3002 \u4f46\u662f\u73b0\u5728\u6709 k k \u6b21\u64cd\u4f5c\uff0c\u6bcf\u6b21\u5c06 [L_i,R_i] [L_i,R_i] \u533a\u95f4\u5185\u6240\u6709\u6570\u5b57\u52a0\u4e0a v_i v_i . \u601d\u8def\uff1a \u5982\u679c n n \u662f\u5947\u6570\uff0c\u7b54\u6848\u662f\u5947\u6570\u4f4d\u7f6e\u7684\u548c\u51cf\u53bb\u5076\u6570\u4f4d\u7f6e\u7684\u548c\uff0c\u5982\u679c n n \u662f\u5076\u6570\uff0c\u5219\u76f8\u53cd\u3002 \u90a3\u4e48\u5bf9\u4e8e\u6bcf\u4e2a\u64cd\u4f5c\u7edf\u8ba1\u6709\u591a\u5c11\u4e2a\u6280\u672f\u4f4d\u7f6e\u548c\u5076\u6570\u4f4d\u7f6e\uff0c\u52a0\u52a0\u51cf\u51cf\u4e58\u4e58\u5c31\u597d\u4e86\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 5e5 + 10 ; int n , q ; ll a [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld\" , a + i ); } ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( i % 2 == n % 2 ) { res += a [ i ]; } else { res -= a [ i ]; } } scanf ( \"%d\" , & q ); for ( int _q = 1 , l , r , v ; _q <= q ; ++ _q ) { scanf ( \"%d %d %d\" , & l , & r , & v ); int even = r / 2 - ( l - 1 ) / 2 ; int odd = r - l + 1 - even ; if ( n & 1 ) { res += 1l l * ( odd - even ) * v ; } else { res += 1l l * ( even - odd ) * v ; } printf ( \"%lld \\n \" , res ); } return 0 ; } B. Bonuses on a Line Solved By Dup4. 0:18(+) \u9898\u610f\uff1a \u6709 n n \u4e2a\u7269\u54c1\uff0c\u5206\u522b\u5728 x_i x_i \u7684\u4f4d\u7f6e\u4e0a\uff0c\u4f60\u5f53\u524d\u5728 x = 0 x = 0 \u7684\u4f4d\u7f6e\u4e0a\uff0c\u6bcf\u79d2\u53ef\u4ee5\u5411\u5de6\u6216\u8005\u5411\u53f3\u79fb\u52a8\u4e00\u683c\uff0c\u5982\u679c\u6240\u5728\u7684\u4f4d\u7f6e\u6709\u7269\u54c1\uff0c\u90a3\u4e48\u6361\u8d77\u8be5\u7269\u54c1\uff0c\u53cd\u590d\u7ecf\u8fc7\u540c\u4e00\u4f4d\u7f6e\u7269\u54c1\u4e0d\u4f1a\u8ba1\u7b97\u591a\u6b21\uff0c\u95ee\u5728 t t \u65f6\u95f4\u5185\uff0c\u6700\u591a\u6361\u8d77\u591a\u5c11\u7269\u54c1\u3002 \u601d\u8def\uff1a \u53ea\u4f1a\u8f6c\u5411\u4e00\u6b21\uff0c\u8ba8\u8bba\u4e00\u4e0b\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define SZ(x) (int(x.size())) const int N = 2e6 + 10 ; int n , t , x [ N ]; void chmax ( int & x , int y ) { if ( x < y ) x = y ; } int main () { scanf ( \"%d%d\" , & n , & t ); vector < int > A , B ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , x + i ); if ( x [ i ] <= 0 ) A . push_back ( x [ i ]); else if ( x [ i ] > 0 ) B . push_back ( x [ i ]); } int res = 0 ; for ( int i = 0 ; i < SZ ( A ); ++ i ) { if ( abs ( A [ i ]) > t ) continue ; ll need = abs ( A [ i ]); chmax ( res , SZ ( A ) - i ); if ( need * 2 <= t ) { ll remind = t - need * 2 ; int pos = upper_bound ( B . begin (), B . end (), remind ) - B . begin (); chmax ( res , SZ ( A ) - i + pos ); } } for ( auto & it : A ) { it = - it ; } sort ( A . begin (), A . end ()); for ( int i = 0 ; i < SZ ( B ); ++ i ) { if ( B [ i ] > t ) continue ; ll need = B [ i ]; chmax ( res , i + 1 ); if ( need * 2 <= t ) { ll remind = t - need * 2 ; int pos = upper_bound ( A . begin (), A . end (), remind ) - A . begin (); chmax ( res , i + 1 + pos ); } } printf ( \"%d \\n \" , res ); return 0 ; } C. Manhattan Distance Solved By Dup4. 3:53(+2) \u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u4e8c\u7ef4\u5e73\u9762\u4e0a\u7684\u70b9\uff0c\u5b9a\u4e49\u4e00\u4e2a\u70b9\u5bf9\u7684\u6743\u503c\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u7684\u66fc\u54c8\u987f\u8ddd\u79bb\uff0c\u73b0\u5728\u8981\u8f93\u51fa\u7b2c k k \u5c0f\u7684\u70b9\u5bf9\u7684\u6743\u503c\u3002 \u601d\u8def\uff1a \u4e8c\u5206\u6743\u503c\uff0c\u8f6c\u5316\u6210\u8ba1\u6570\u95ee\u9898\u3002 \u5c06\u66fc\u54c8\u987f\u8ddd\u79bb\u8f6c\u5316\u6210\u5207\u6bd4\u96ea\u592b\u8ddd\u79bb\uff0c\u8f6c\u5316\u6210\u77e9\u5f62\u6846\u5185\u7684\u8ba1\u6570\u95ee\u9898\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n \\log V) O(n \\log n \\log V) \uff0c\u5176\u4e2d V V \u4e3a\u8ddd\u79bb\u7684\u8303\u56f4\u3002 \u9700\u8981\u5361\u5e38\uff0c\u6ce8\u610f\u5230\u6709\u5355\u8c03\u6027\uff0c\u53ef\u4ee5\u9002\u5f53\u7684\u4e00\u4e9b\u6392\u5e8f\u64cd\u4f5c\u8f6c\u5316\u6210\u6709\u5e8f\u8868\u7684\u5408\u5e76\u3002 Code #include <bits/stdc++.h> #define fi first #define se second #define SZ(x) (int(x.size())) using namespace std ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } using ll = long long ; using pII = pair < int , int > ; const int N = 4e5 + 10 ; int n ; pII p [ N ]; ll K ; int a [ N ]; struct Hash { int a [ N ]; int size () { return * a ; } void init () { * a = 0 ; } void add ( int x ) { a [ ++* a ] = x ; } void gao () { sort ( a + 1 , a + 1 + * a ); * a = unique ( a + 1 , a + 1 + * a ) - a - 1 ; } int get ( int x ) { return lower_bound ( a + 1 , a + 1 + * a , x ) - a ; } } hy ; struct BIT { int a [ N ], n ; void init ( int _n ) { n = _n ; memset ( a , 0 , sizeof ( a [ 0 ]) * ( n + 5 )); } void update ( int x , int v ) { for (; x <= n ; x += x & - x ) a [ x ] += v ; } int query ( int x ) { int res = 0 ; for (; x ; x -= x & - x ) res += a [ x ]; return res ; } int query ( int l , int r ) { return query ( r ) - query ( l - 1 ); } } bit ; struct E { int op , x , l , r ; inline bool operator < ( const E & other ) const { return x < other . x ; } }; inline int get ( int x ) { return lower_bound ( a + 1 , a + 1 + * a , x ) - a ; } E A [ N ], B [ N ], vec [ N ]; inline ll calc ( int dis ) { ll res = 0 ; * a = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { a [ ++* a ] = p [ i ]. se ; a [ ++* a ] = p [ i ]. se - dis ; a [ ++* a ] = p [ i ]. se + dis ; } sort ( a + 1 , a + 1 + * a ); * a = unique ( a + 1 , a + 1 + * a ) - a - 1 ; int m = * a ; int cA = 0 , cB = 0 , cVec = 0 ; for ( int i = n ; i >= 1 ; -- i ) { int l = get ( p [ i ]. se - dis ), r = get ( p [ i ]. se + dis ); A [ ++ cA ] = { -1 , p [ i ]. fi - dis - 1 , l , r }; B [ ++ cB ] = { 1 , p [ i ]. fi + dis , l , r }; } for ( int i = 1 , sze = n * 2 ; i <= sze ; ++ i ) { if ( ! cA ) vec [ ++ cVec ] = B [ cB -- ]; else if ( ! cB ) vec [ ++ cVec ] = A [ cA -- ]; else if ( A [ cA ]. x < B [ cB ]. x ) { vec [ ++ cVec ] = A [ cA -- ]; } else { vec [ ++ cVec ] = B [ cB -- ]; } } int pos = 0 ; bit . init ( m ); for ( int i = 1 ; i <= cVec ; ++ i ) { while ( pos < n && p [ pos + 1 ]. fi <= vec [ i ]. x ) { ++ pos ; bit . update ( get ( p [ pos ]. se ), 1 ); } res += bit . query ( vec [ i ]. l , vec [ i ]. r ) * vec [ i ]. op ; } res -= n ; res /= 2 ; return res ; } int main () { scanf ( \"%d%lld\" , & n , & K ); for ( int i = 1 , _x , _y ; i <= n ; ++ i ) { scanf ( \"%d%d\" , & _x , & _y ); p [ i ]. fi = _x + _y ; p [ i ]. se = _x - _y ; } sort ( p + 1 , p + 1 + n ); // for (int i = 1; i <= n; ++i) // dbg(i, p[i].fi, p[i].se); int l = 0 , r = 4e8 , res = 0 ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( calc ( mid ) >= K ) { res = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } printf ( \"%d \\n \" , res ); return 0 ; } D. Lexicographically Minimal Shortest Path Solved By Hsueh-. 1:48(+) \u9898\u610f\uff1a \u6709 n n \u4e2a\u70b9 m m \u6761\u8fb9\u7684\u65e0\u5411\u56fe\uff0c\u65e0\u91cd\u8fb9\u548c\u81ea\u73af\uff0c\u4f46\u662f\u6bcf\u6761\u8fb9\u4e0a\u6709\u4e00\u4e2a\u5c0f\u5199\u5b57\u6bcd c c , \u627e 1 \\to n 1 \\to n \u7684\u6700\u77ed\u8def\uff0c\u5982\u679c\u6709\u591a\u5c11\uff0c\u8f93\u51fa\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u90a3\u6761\uff0c\u8fd9\u91cc\u7684\u5b57\u5178\u5e8f\u6307\u7684\u662f\u6700\u77ed\u8def\u4e0a\u7684\u8fb9\u4e0a\u7684\u5b57\u6bcd\u6309\u987a\u5e8f\u94fe\u63a5\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\u5b57\u5178\u5e8f\u3002 \u601d\u8def\uff1a \u4ece n n \u51fa\u53d1\u8dd1\u4e00\u4e2a\u6700\u77ed\u8def\uff0c\u7136\u540e\u518d\u4ece 1 1 \u51fa\u53d1\uff0c\u6bcf\u6b21\u53bb\u627e\u662f\u6700\u77ed\u8def\u540c\u65f6\u5b57\u6bcd\u6700\u5c0f\u7684\uff0c\u5982\u679c\u6709\u591a\u4e2a\u6700\u5c0f\u7684\uff0c\u90a3\u5c31\u7528 vector \u5b58\u8d77\u6765\uff0c\u6bcf\u4e2a\u8282\u70b9\u90fd\u8dd1\u4e00\u6b21\u3002 \u7531\u4e8e\u662f\u5206\u5c42\u56fe\uff0c\u6bcf\u4e2a\u70b9\u53ea\u4f1a\u88ab\u653e\u5728 vector \u91cc\u9762\u4e00\u6b21\uff0c\u6240\u4ee5\u590d\u6742\u5ea6\u4e3a O(m+nlog_2n) O(m+nlog_2n) \u3002 Code #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } using pIC = pair < int , char > ; const int N = 2e5 + 10 ; int n , m ; vector < vector < pIC >> G ; vector < int > vec [ 2 ]; int pre [ N ]; int d [ N ]; char s [ N ]; int pos [ N ]; int main () { memset ( d , -1 , sizeof d ); scanf ( \"%d %d\" , & n , & m ); G . resize ( n + 1 ); for ( int i = 1 ; i <= m ; ++ i ) { int u , v ; char c ; scanf ( \"%d %d %c\" , & u , & v , & c ); G [ u ]. push_back ( pIC ( v , c )); G [ v ]. push_back ( pIC ( u , c )); } queue < int > q ; d [ n ] = 0 ; q . push ( n ); while ( ! q . empty ()) { int u = q . front (); q . pop (); for ( auto it : G [ u ]) { int v = it . first ; if ( d [ v ] == -1 ) { d [ v ] = d [ u ] + 1 ; q . push ( v ); } } } vec [ 0 ]. push_back ( 1 ); for ( int cas = 1 ; cas <= d [ 1 ]; ++ cas ) { char Max = 'z' + 1 ; for ( auto u : vec [ 0 ]) { for ( auto it : G [ u ]) { if ( d [ u ] == d [ it . first ] + 1 && it . second < Max ) { Max = it . second ; } } } vec [ 1 ]. clear (); for ( auto u : vec [ 0 ]) { for ( auto it : G [ u ]) { if ( d [ u ] == d [ it . first ] + 1 && it . second == Max ) { pre [ it . first ] = u ; vec [ 1 ]. push_back ( it . first ); } } } sort ( vec [ 1 ]. begin (), vec [ 1 ]. end ()); vec [ 1 ]. resize ( unique ( vec [ 1 ]. begin (), vec [ 1 ]. end ()) - vec [ 1 ]. begin ()); swap ( vec [ 0 ], vec [ 1 ]); s [ cas ] = Max ; } s [ d [ 1 ] + 1 ] = 0 ; int u = n , cnt = 0 ; while ( true ) { pos [ ++ cnt ] = u ; if ( u == 1 ) break ; u = pre [ u ]; } reverse ( pos + 1 , pos + 1 + cnt ); printf ( \"%d \\n \" , d [ 1 ]); for ( int i = 1 ; i <= cnt ; ++ i ) { printf ( \"%d%c\" , pos [ i ], \" \\n \" [ i == cnt ]); } puts ( s + 1 ); return 0 ; } E. Fluctuations of Mana Solved By Hsueh-. 0:15(+1) \u9898\u610f\uff1a \u6709 n n \u4e2a\u5750\u6807\uff0c\u6bcf\u8d70\u5230\u7b2c i i \u4e2a\u4f4d\u7f6e\uff0c\u81ea\u8eab\u6cd5\u529b\u503c\u4f1a\u53d8\u5316 a_i a_i \uff0c\u5982\u679c\u6cd5\u529b\u503c \\leq 0 \\leq 0 \u5c31\u4f1a\u6b7b\u4ea1\uff0c\u6c42\u521a\u5f00\u59cb\u7684\u6700\u5c0f\u6cd5\u529b\u503c\u3002 \u601d\u8def\uff1a \u7edf\u8ba1\u524d\u7f00\u548c\uff0c\u7136\u540e\u770b\u6700\u5c0f\u7684\u8d1f\u503c\uff0c\u90a3\u4e48\u521a\u5f00\u59cb\u6cd5\u529b\u503c\u5c31\u8981\u4e3a\u6700\u5c0f\u7684\u8d1f\u6570\u7684\u76f8\u53cd\u6570\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 5e5 + 10 ; int n ; ll a [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld\" , a + i ); a [ i ] += a [ i - 1 ]; } ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( a [ i ] <= 0 ) { res = max ( res , - a [ i ]); } } printf ( \"%lld \\n \" , res ); return 0 ; } F. Moving Target Solved By Hsueh-. 0:54(+) \u9898\u610f\uff1a \u6709 n n \u4e2a\u7a97\u6237\uff0c\u6709\u4e00\u4e2a\u76ee\u6807\u5728\u67d0\u4e00\u4e2a\u7a97\u6237\u540e\u9762\uff0c\u4f46\u662f\u5e76\u4e0d\u77e5\u9053\u5728\u54ea\u4e2a\u7a97\u6237\u540e\u9762\u3002 \u73b0\u5728\u53ef\u4ee5\u5c04\u51fb\uff0c\u5982\u679c\u6ca1\u6709\u51fb\u4e2d\uff0c\u5e76\u4e14\u76ee\u6807\u4e0d\u5728\u7b2c n n \u4e2a\u7a97\u6237\u540e\u9762\uff0c\u90a3\u4e48\u76ee\u6807\u4f1a\u5f80\u53f3\u8fb9\u79fb\u52a8\u4e00\u4e2a\u7a97\u6237\u7684\u4f4d\u7f6e\uff0c\u95ee\u6700\u5c11\u7684\u5c04\u51fb\u6b21\u6570\u4fdd\u8bc1\u4e0d\u7ba1\u76ee\u6807\u5728\u54ea\u513f\uff0c\u90fd\u80fd\u5c06\u4ed6\u51fb\u4e2d\u3002 \u7ed9\u51fa\u5c04\u51fb\u7684\u4f4d\u7f6e\u5e8f\u5217\u3002 \u601d\u8def\uff1a \u4e3a\u4ec0\u4e48\u53ea\u5c04\u51fb 1 1 , n n \u548c\u5947\u6570\u4f4d\u7f6e\u4e0a\u7684\u7a97\u6237\u5c31\u53ef\u4ee5\u4e86\uff0c\u6709\u66f4\u5c0f\u7684\u5c04\u51fb\u6b21\u6570\u5e8f\u5217\u5417\uff1f Code #include <bits/stdc++.h> using namespace std ; int n ; int main () { scanf ( \"%d\" , & n ); printf ( \"%d \\n \" , n / 2 + 1 ); for ( int i = 1 ; i <= n / 2 + 1 ; ++ i ) { printf ( \"%d%c\" , min ( n , 2 * i - 1 ), \" \\n \" [ min ( n , 2 * i - 1 ) == n ]); } return 0 ; } G. Nuts and Bolts Solved By Hsueh- & ltslts. 3:00(+) \u9898\u610f\uff1a \u6709 n n \u4e2a A \u7269\u54c1\uff0c\u548c n n \u4e2a B \u7269\u54c1\uff0c\u6240\u6709\u7684 A \u7269\u54c1\u7684\u5927\u5c0f\u4e3a [1, n] [1, n] \u4e14\u4e24\u4e24\u4e0d\u540c\uff0c B \u7269\u54c1\u4ea6\u5982\u6b64\u3002 \u4f46\u662f\u5e76\u4e0d\u77e5\u9053\u7b2c i i \u4e2a\u7269\u54c1\u7684\u5927\u5c0f\uff0c\u53ef\u4ee5\u8be2\u95ee 5n \\log n 5n \\log n \u6b21\uff0c\u6bcf\u6b21\u8be2\u95ee\u7ed9\u51fa (i, j) (i, j) \uff0c\u6839\u636e\u7b2c i i \u4e2a A \u7269\u54c1\u548c\u7b2c j j \u4e2a B \u7269\u54c1\u7684\u5927\u5c0f\u5173\u7cfb\u8fd4\u56de < , = , > \u4e09\u79cd\u7ed3\u679c\u3002 \u6700\u540e\u8981\u8f93\u51fa\u4e00\u4e2a\u6392\u5217\uff0c\u8868\u793a\u7b2c i i \u4e2a A \u7269\u54c1\u548c\u7b2c p_i p_i \u4e2a B \u7269\u54c1\u7684\u5927\u5c0f\u76f8\u540c\u3002 \u601d\u8def\uff1a \u7c7b\u4f3c\u4e8e\u5feb\u6392\uff0c\u6bcf\u6b21\u5c06 L,R L,R \u4e24\u4e2a\u96c6\u5408\u5206\u6210\u5c0f\u4e8e pos pos \u548c\u5927\u4e8e pos pos \u7684\u6570\u5b57\uff0c\u7136\u540e\u4e0d\u65ad\u9012\u5f52\u4e0b\u53bb\uff0c\u590d\u6742\u5ea6\u5927\u7ea6\u4e3a O(n \\log n) O(n \\log n) , \u7edf\u8ba1\u6b21\u6570\u5927\u6982\u662f n \\log n n \\log n \u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } mt19937 rnd ( time ( 0 )); // int cnt; int ask ( int x , int y ) { // cnt++; // if (x > y) // return 1; // else if (x < y) // return -1; // else // return 0; printf ( \"? %d %d \\n \" , x , y ); fflush ( stdout ); char c ; scanf ( \" %c\" , & c ); if ( c == '>' ) return 1 ; else if ( c == '<' ) return -1 ; else return 0 ; } int n ; int res [ N ]; void gao ( vector < int > L , vector < int > R ) { // dbg(L.size(), R.size()); if ( L . empty ()) return ; if ( L . size () == 1 ) { res [ L [ 0 ]] = R [ 0 ]; return ; } int pos = rnd () % L . size (); vector < int > rl , rr ; int cur = 0 ; for ( auto it : R ) { int op = ask ( L [ pos ], it ); if ( op == -1 ) { rl . push_back ( it ); } else if ( op == 1 ) { rr . push_back ( it ); } else { cur = it ; } } // dbg(cur, pos); vector < int > ll , lr ; for ( auto it : L ) { if ( it == L [ pos ]) continue ; int op = ask ( it , cur ); if ( op == -1 ) lr . push_back ( it ); else ll . push_back ( it ); } res [ L [ pos ]] = cur ; gao ( ll , rl ); gao ( lr , rr ); } vector < int > a , b ; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { a . push_back ( i ); b . push_back ( i ); } gao ( a , b ); // assert(cnt <= 5 * n * log2(n)); printf ( \"! \" ); for ( int i = 1 ; i <= n ; ++ i ) { printf ( \"%d%c\" , res [ i ], \" \\n \" [ i == n ]); } fflush ( stdout ); return 0 ; } H. Tree Painting Solved By All. 0:23(+) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u68f5\u6811\uff0c\u6bcf\u6b21\u80fd\u591f\u9009\u62e9\u4e24\u4e2a\u8282\u70b9\uff0c\u5c06\u8fd9\u4e24\u4e2a\u8282\u70b9\u4e4b\u95f4\u7684\u7b80\u5355\u8def\u5f84\u4e0a\u7684\u6240\u6709\u70b9\u548c\u8fb9\u90fd\u6d82\u8272\uff0c\u95ee\u6700\u5c11\u51e0\u6b21\u64cd\u4f5c\u80fd\u591f\u5c06\u8fd9\u68f5\u6811\u7684\u6240\u6709\u70b9\u548c\u8fb9\u90fd\u6d82\u8272\u3002 \u601d\u8def\uff1a \u7b54\u6848\u4e3a \\frac{\\mbox{\u5ea6\u6570\u4e3a1\u7684\u70b9\u7684\u4e2a\u6570} + 1}{2} \\frac{\\mbox{\u5ea6\u6570\u4e3a1\u7684\u70b9\u7684\u4e2a\u6570} + 1}{2} \u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 2e5 + 10 ; int n , d [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 , u , v ; i < n ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); ++ d [ u ], ++ d [ v ]; } int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) res += ( d [ i ] == 1 ); printf ( \"%d \\n \" , ( res + 1 ) / 2 ); return 0 ; } I. Sorting Colored Array Solved By Dup4 & ltslts. 0:32(+) \u9898\u610f\uff1a \u6709 n n \u4e2a\u6570\u5b57\uff0c\u6bcf\u4e2a\u6570\u5b57\u6709\u4e00\u79cd\u989c\u8272 c_i c_i \uff0c\u548c\u4e00\u4e2a\u6743\u503c a_i a_i , \u6bcf\u6b21\u53ef\u4ee5\u9009\u62e9\u4efb\u610f\u4e24\u4e2a\u76f8\u90bb\u7684\u5e76\u4e14\u989c\u8272\u4e0d\u540c\u7684\u6570\u5b57\u8fdb\u884c\u4ea4\u6362\uff0c\u95ee\u80fd\u5426\u5728\u6709\u9650\u6b65\u5185\u4f7f\u5f97\u8be5\u5e8f\u5217\u53d8\u6210\u5347\u5e8f\u3002 \u601d\u8def\uff1a \u663e\u7136\u540c\u4e00\u79cd\u989c\u8272\u7684\u6570\u5b57\u7684\u76f8\u5bf9\u4f4d\u7f6e\u4e0d\u4f1a\u6539\u53d8\uff0c\u4e0d\u7528\u989c\u8272\u7684\u53ef\u4ee5\u4efb\u610f\u4ea4\u6362\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u5224\u65ad\u6bcf\u4e00\u79cd\u989c\u8272\u5bf9\u5e94\u7684\u5b50\u5e8f\u5217\u662f\u5426\u4e3a\u5347\u5e8f\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 2e5 + 10 ; int n ; int main () { scanf ( \"%d\" , & n ); vector < int > vec [ N ]; for ( int i = 1 , a , c ; i <= n ; ++ i ) { scanf ( \"%d%d\" , & a , & c ); vec [ c ]. push_back ( a ); } int ok = 1 ; for ( auto & it : vec ) if ( ! it . empty ()) { int pre = -2e9 ; for ( auto & v : it ) { if ( pre > v ) { ok = 0 ; break ; } pre = v ; } } puts ( ok ? \"YES\" : \"NO\" ); return 0 ; } J. The Battle of Mages Solved By Hsueh- & ltslts. 2:06(+) \u9898\u610f\uff1a \u6784\u9020\u4e24\u4e2a\u957f\u5ea6\u4e3a n,m(3 \\leq n, m \\leq 10) n,m(3 \\leq n, m \\leq 10) \u7684\u5e8f\u5217\uff0c\u4f7f\u5f97\u5206\u522b\u968f\u610f\u9009\u53d6\u4e00\u4e2a\u6216\u4e09\u4e2a\u5e8f\u5217\u4e2d\u7684\u5143\u7d20\uff0c\u7136\u540e\u5e8f\u5217\u4e00\u7684\u548c\u5927\u4e8e\u5e8f\u5217\u4e8c\u7684\u548c\u7684\u6982\u7387\u9ad8\uff0c\u5206\u522b\u968f\u610f\u9009\u53d6\u4e24\u4e2a\u5e8f\u5217\u4e2d\u7684\u5143\u7d20\uff0c\u7136\u540e\u5e8f\u5217\u4e00\u7684\u548c\u5927\u4e8e\u5e8f\u5217\u4e8c\u7684\u548c\u7684\u6982\u7387\u4f4e \u601d\u8def\uff1a \u5feb\u4e50\u6253\u8868\u9898\u3002 Code #include <bits/stdc++.h> using namespace std ; int main () { printf ( \"5 \\n \" ); printf ( \"1 2 7 8 10 \\n \" ); printf ( \"5 \\n \" ); printf ( \"2 4 6 7 9 \\n \" ); return 0 ; } \u6253\u8868\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; bool ok1 ( vector < int > v1 , vector < int > v2 ) { int cnt = 0 ; for ( auto it1 : v1 ) { for ( auto it2 : v2 ) { if ( it1 > it2 ) { cnt ++ ; } if ( it1 < it2 ) { cnt -- ; } } } return cnt > 0 ; } bool ok2 ( vector < int > v1 , vector < int > v2 ) { int cnt = 0 ; for ( int i = 0 , len1 = v1 . size (); i < len1 ; ++ i ) { for ( int j = 0 , len2 = v2 . size (); j < len2 ; ++ j ) { for ( int ii = i + 1 ; ii < len1 ; ++ ii ) { for ( int jj = j + 1 ; jj < len2 ; ++ jj ) { if ( v1 [ i ] + v1 [ ii ] > v2 [ j ] + v2 [ jj ]) { cnt ++ ; } if ( v1 [ i ] + v1 [ ii ] < v2 [ j ] + v2 [ jj ]) { cnt -- ; } } } } } return cnt < 0 ; } bool ok3 ( vector < int > v1 , vector < int > v2 ) { int cnt = 0 ; for ( int i = 0 ; i < v1 . size (); ++ i ) { for ( int j = 0 ; j < v2 . size (); ++ j ) { for ( int ii = i + 1 ; ii < v1 . size (); ++ ii ) { for ( int jj = j + 1 ; jj < v2 . size (); ++ jj ) { for ( int iii = ii + 1 ; iii < v1 . size (); ++ iii ) { for ( int jjj = jj + 1 ; jjj < v2 . size (); ++ jjj ) { if ( v1 [ i ] + v1 [ ii ] + v1 [ iii ] > v2 [ j ] + v2 [ jj ] + v2 [ jjj ]) { cnt ++ ; } if ( v1 [ i ] + v1 [ ii ] + v1 [ iii ] < v2 [ j ] + v2 [ jj ] + v2 [ jjj ]) { cnt -- ; } } } } } } } return cnt > 0 ; } mt19937 rnd ( time ( 0 )); int main () { while ( true ) { vector < int > v1 , v2 ; for ( int i = 1 ; i <= 10 ; ++ i ) { if ( rnd () % 2 == 0 ) { v1 . push_back ( i ); } if ( rnd () % 2 == 0 ) { v2 . push_back ( i ); } } if ( v1 . size () < 3 || v2 . size () < 3 ) continue ; if ( ok1 ( v1 , v2 ) && ok2 ( v1 , v2 ) && ok3 ( v1 , v2 )) { cout << \"ok\" << endl ; for ( auto it : v1 ) { cout << it << \" \" ; } cout << endl ; for ( auto it : v2 ) { cout << it << \" \" ; } cout << endl ; system ( \"pause\" ); } } return 0 ; } K. Table Solved By ltslts. 1:14(+) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u684c\u5b50\u76844\u6761\u684c\u817f\u957f\u5ea6\uff0c\u8981\u6c42\u684c\u817f\u5b89\u88c5\u5782\u76f4\u4e8e\u684c\u9762\uff0c\u5e76\u4e14\u684c\u817f\u5728\u684c\u9762\u7684\u6295\u5f71\u4e3a\u4e00\u4e2a\u77e9\u5f62\u76844\u4e2a\u9876\u70b9\uff0c\u5224\u65ad\u53ef\u5426\u4f7f\u5f97\u684c\u5b50\u7a33\u5b9a\u7ad9\u7acb\uff08\u684c\u9762\u53ef\u4ee5\u503e\u659c\uff09 \u601d\u8def\uff1a \u4ee5\u684c\u9762\u4e3a\u5e95\u9762\uff0c\u53ea\u8981\u4f7f\u5f97 ABCD ABCD \u56db\u70b9\u5171\u9762\uff0c\u684c\u5b50\u5373\u53ef\u7a33\u5b9a\u3002 \u56e0\u4e3a\u5e95\u9762\u7684\u56db\u8fb9\u5f62\u4e3a\u77e9\u5f62\uff0c\u6240\u4ee5\u53ea\u8981\u8bc1\u660e AB=CD AB=CD \u6216\u8005 AC=BD AC=BD \u5373\u53ef\u8bc1\u660e\u56db\u8fb9\u5f62 ABDC ABDC \u662f\u5e73\u884c\u56db\u8fb9\u5f62\u3002 Code #include <bits/stdc++.h> using namespace std ; int a [ 5 ]; int main () { for ( int i = 1 ; i <= 4 ; ++ i ) { scanf ( \"%d\" , a + i ); } sort ( a + 1 , a + 1 + 4 ); if ( a [ 4 ] - a [ 3 ] == a [ 2 ] - a [ 1 ]) puts ( \"YES\" ); else puts ( \"NO\" ); return 0 ; } L. The Dragon Land Solved By Hsueh- & ltslts. 0:59(+) \u9898\u610f\uff1a \u6709 n n \u53ea\u6050\u9f99\uff0c\u6253\u8d25\u7b2c i i \u53ea\u6050\u9f99\u53ef\u4ee5\u83b7\u5f97 a_i a_i \u7684\u91d1\u5e01\uff0c\u4f46\u662f\u8981\u6263\u9664\u82b1\u8d39\uff0c\u82b1\u8d39\u4e3a\u4f60\u5df2\u7ecf\u51fb\u8d25\u8fc7\u7684\u6050\u9f99\u4e2a\u6570 +1 +1 \uff0c\u8fd9\u91cc\u662f\u5148\u52a0\u4e0a\u91d1\u5e01\uff0c\u518d\u6263\u9664\u82b1\u8d39\u3002 \u6309\u987a\u5e8f\u6253\u6050\u9f99\uff0c\u6bcf\u6b21\u53ef\u4ee5\u9009\u62e9\u6253\u6216\u8005\u4e0d\u6253\uff0c\u95ee\u6700\u5927\u6536\u76ca\u3002 \u601d\u8def\uff1a \u5f88\u663e\u7136\u987a\u5e8f\u662f\u968f\u610f\u7684\uff0c\u56e0\u4e3a\u6253\u7684\u6050\u9f99\u4e00\u6837\uff0c\u6536\u76ca\u4e00\u6837\uff0c\u4e2a\u6570\u4e00\u6837\uff0c\u6240\u4ee5\u6700\u7ec8\u7ed3\u679c\u4e00\u6837\u3002 \u5bf9\u6050\u9f99\u6392\u5e8f\uff0c\u627e\u6700\u5927\u7684\u51e0\u4e2a\u6253\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 2e5 + 10 ; int n ; ll a [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld\" , a + i ); } sort ( a + 1 , a + 1 + n ); ll res = 0 ; for ( int i = n , j = 1 ; i >= 1 ; -- i , ++ j ) { res += max ( 0l l , 1l l * a [ i ] - j ); } printf ( \"%lld \\n \" , res ); return 0 ; } M. Notifications Solved By Hsueh-. 0:39(+) \u9898\u610f\uff1a \u6709 n n \u4e2a\u4efb\u52a1\uff0c\u6bcf\u4e2a\u4efb\u52a1\u6709\u5230\u8fbe\u65f6\u95f4\u548c\u6301\u7eed\u65f6\u95f4\uff0c\u4e3a\u9700\u8981\u591a\u4e45\u624d\u80fd\u5b8c\u6210\u6240\u6709\u4efb\u52a1\u3002 \u601d\u8def\uff1a \u6a21\u62df\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 2e5 + 10 ; int n ; int t [ N ], d [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d %d\" , t + i , d + i ); } ll res = 0 ; int pos = 1 ; priority_queue < int , vector < int > , greater < int >> q ; while ( true ) { if ( pos > n && q . empty ()) break ; while ( pos <= n && t [ pos ] <= res ) { q . push ( d [ pos ]); pos ++ ; } if ( ! q . empty ()) { res += q . top (); q . pop (); } else { res = t [ pos ]; } } printf ( \"%lld \\n \" , res ); return 0 ; }","title":"2020, XIII Samara Regional Intercollegiate Programming Contest"},{"location":"trainings/random-trainings/2020-XIII-Samara-Regional-Intercollegiate-Programming-Contest/#contest-info","text":"Practice Link Solved A B C D E F G H I J K L M 13/13 O O O O O O O O O O O O O O \u5728\u6bd4\u8d5b\u4e2d\u901a\u8fc7 \u00d8 \u8d5b\u540e\u901a\u8fc7 ! \u5c1d\u8bd5\u4e86\u4f46\u662f\u5931\u8d25\u4e86 . \u6ca1\u6709\u5c1d\u8bd5","title":"Contest Info"},{"location":"trainings/random-trainings/2020-XIII-Samara-Regional-Intercollegiate-Programming-Contest/#solutions","text":"","title":"Solutions"},{"location":"trainings/random-trainings/2020-XIII-Samara-Regional-Intercollegiate-Programming-Contest/#a-arrays-hash","text":"Solved By Hsueh-. 0:29(+) \u9898\u610f\uff1a \u7ed9\u5b9a\u4e00\u4e2a\u5e8f\u5217\uff0c\u6bcf\u6b21\u5c06 a_2 a_2 \u548c a_1 a_1 \u62ff\u51fa\u6765\uff0c\u7136\u540e\u5c06 a_2-a_1 a_2-a_1 \u63d2\u5165\u5230\u5e8f\u5217\u4e2d\uff0c\u95ee\u6700\u540e\u7684\u5e8f\u5217\u7ed3\u679c\u3002 \u4f46\u662f\u73b0\u5728\u6709 k k \u6b21\u64cd\u4f5c\uff0c\u6bcf\u6b21\u5c06 [L_i,R_i] [L_i,R_i] \u533a\u95f4\u5185\u6240\u6709\u6570\u5b57\u52a0\u4e0a v_i v_i . \u601d\u8def\uff1a \u5982\u679c n n \u662f\u5947\u6570\uff0c\u7b54\u6848\u662f\u5947\u6570\u4f4d\u7f6e\u7684\u548c\u51cf\u53bb\u5076\u6570\u4f4d\u7f6e\u7684\u548c\uff0c\u5982\u679c n n \u662f\u5076\u6570\uff0c\u5219\u76f8\u53cd\u3002 \u90a3\u4e48\u5bf9\u4e8e\u6bcf\u4e2a\u64cd\u4f5c\u7edf\u8ba1\u6709\u591a\u5c11\u4e2a\u6280\u672f\u4f4d\u7f6e\u548c\u5076\u6570\u4f4d\u7f6e\uff0c\u52a0\u52a0\u51cf\u51cf\u4e58\u4e58\u5c31\u597d\u4e86\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 5e5 + 10 ; int n , q ; ll a [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld\" , a + i ); } ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( i % 2 == n % 2 ) { res += a [ i ]; } else { res -= a [ i ]; } } scanf ( \"%d\" , & q ); for ( int _q = 1 , l , r , v ; _q <= q ; ++ _q ) { scanf ( \"%d %d %d\" , & l , & r , & v ); int even = r / 2 - ( l - 1 ) / 2 ; int odd = r - l + 1 - even ; if ( n & 1 ) { res += 1l l * ( odd - even ) * v ; } else { res += 1l l * ( even - odd ) * v ; } printf ( \"%lld \\n \" , res ); } return 0 ; }","title":"A. Array\u2019s Hash"},{"location":"trainings/random-trainings/2020-XIII-Samara-Regional-Intercollegiate-Programming-Contest/#b-bonuses-on-a-line","text":"Solved By Dup4. 0:18(+) \u9898\u610f\uff1a \u6709 n n \u4e2a\u7269\u54c1\uff0c\u5206\u522b\u5728 x_i x_i \u7684\u4f4d\u7f6e\u4e0a\uff0c\u4f60\u5f53\u524d\u5728 x = 0 x = 0 \u7684\u4f4d\u7f6e\u4e0a\uff0c\u6bcf\u79d2\u53ef\u4ee5\u5411\u5de6\u6216\u8005\u5411\u53f3\u79fb\u52a8\u4e00\u683c\uff0c\u5982\u679c\u6240\u5728\u7684\u4f4d\u7f6e\u6709\u7269\u54c1\uff0c\u90a3\u4e48\u6361\u8d77\u8be5\u7269\u54c1\uff0c\u53cd\u590d\u7ecf\u8fc7\u540c\u4e00\u4f4d\u7f6e\u7269\u54c1\u4e0d\u4f1a\u8ba1\u7b97\u591a\u6b21\uff0c\u95ee\u5728 t t \u65f6\u95f4\u5185\uff0c\u6700\u591a\u6361\u8d77\u591a\u5c11\u7269\u54c1\u3002 \u601d\u8def\uff1a \u53ea\u4f1a\u8f6c\u5411\u4e00\u6b21\uff0c\u8ba8\u8bba\u4e00\u4e0b\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; #define SZ(x) (int(x.size())) const int N = 2e6 + 10 ; int n , t , x [ N ]; void chmax ( int & x , int y ) { if ( x < y ) x = y ; } int main () { scanf ( \"%d%d\" , & n , & t ); vector < int > A , B ; for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , x + i ); if ( x [ i ] <= 0 ) A . push_back ( x [ i ]); else if ( x [ i ] > 0 ) B . push_back ( x [ i ]); } int res = 0 ; for ( int i = 0 ; i < SZ ( A ); ++ i ) { if ( abs ( A [ i ]) > t ) continue ; ll need = abs ( A [ i ]); chmax ( res , SZ ( A ) - i ); if ( need * 2 <= t ) { ll remind = t - need * 2 ; int pos = upper_bound ( B . begin (), B . end (), remind ) - B . begin (); chmax ( res , SZ ( A ) - i + pos ); } } for ( auto & it : A ) { it = - it ; } sort ( A . begin (), A . end ()); for ( int i = 0 ; i < SZ ( B ); ++ i ) { if ( B [ i ] > t ) continue ; ll need = B [ i ]; chmax ( res , i + 1 ); if ( need * 2 <= t ) { ll remind = t - need * 2 ; int pos = upper_bound ( A . begin (), A . end (), remind ) - A . begin (); chmax ( res , i + 1 + pos ); } } printf ( \"%d \\n \" , res ); return 0 ; }","title":"B. Bonuses on a Line"},{"location":"trainings/random-trainings/2020-XIII-Samara-Regional-Intercollegiate-Programming-Contest/#c-manhattan-distance","text":"Solved By Dup4. 3:53(+2) \u9898\u610f\uff1a \u7ed9\u51fa n n \u4e2a\u4e8c\u7ef4\u5e73\u9762\u4e0a\u7684\u70b9\uff0c\u5b9a\u4e49\u4e00\u4e2a\u70b9\u5bf9\u7684\u6743\u503c\u4e3a\u8fd9\u4e24\u4e2a\u70b9\u7684\u66fc\u54c8\u987f\u8ddd\u79bb\uff0c\u73b0\u5728\u8981\u8f93\u51fa\u7b2c k k \u5c0f\u7684\u70b9\u5bf9\u7684\u6743\u503c\u3002 \u601d\u8def\uff1a \u4e8c\u5206\u6743\u503c\uff0c\u8f6c\u5316\u6210\u8ba1\u6570\u95ee\u9898\u3002 \u5c06\u66fc\u54c8\u987f\u8ddd\u79bb\u8f6c\u5316\u6210\u5207\u6bd4\u96ea\u592b\u8ddd\u79bb\uff0c\u8f6c\u5316\u6210\u77e9\u5f62\u6846\u5185\u7684\u8ba1\u6570\u95ee\u9898\u3002 \u65f6\u95f4\u590d\u6742\u5ea6 O(n \\log n \\log V) O(n \\log n \\log V) \uff0c\u5176\u4e2d V V \u4e3a\u8ddd\u79bb\u7684\u8303\u56f4\u3002 \u9700\u8981\u5361\u5e38\uff0c\u6ce8\u610f\u5230\u6709\u5355\u8c03\u6027\uff0c\u53ef\u4ee5\u9002\u5f53\u7684\u4e00\u4e9b\u6392\u5e8f\u64cd\u4f5c\u8f6c\u5316\u6210\u6709\u5e8f\u8868\u7684\u5408\u5e76\u3002 Code #include <bits/stdc++.h> #define fi first #define se second #define SZ(x) (int(x.size())) using namespace std ; #define dbg(x...) \\ do { \\ cout << \"\\033[32;1m\" << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << \" \\033 [39;0m\" << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } using ll = long long ; using pII = pair < int , int > ; const int N = 4e5 + 10 ; int n ; pII p [ N ]; ll K ; int a [ N ]; struct Hash { int a [ N ]; int size () { return * a ; } void init () { * a = 0 ; } void add ( int x ) { a [ ++* a ] = x ; } void gao () { sort ( a + 1 , a + 1 + * a ); * a = unique ( a + 1 , a + 1 + * a ) - a - 1 ; } int get ( int x ) { return lower_bound ( a + 1 , a + 1 + * a , x ) - a ; } } hy ; struct BIT { int a [ N ], n ; void init ( int _n ) { n = _n ; memset ( a , 0 , sizeof ( a [ 0 ]) * ( n + 5 )); } void update ( int x , int v ) { for (; x <= n ; x += x & - x ) a [ x ] += v ; } int query ( int x ) { int res = 0 ; for (; x ; x -= x & - x ) res += a [ x ]; return res ; } int query ( int l , int r ) { return query ( r ) - query ( l - 1 ); } } bit ; struct E { int op , x , l , r ; inline bool operator < ( const E & other ) const { return x < other . x ; } }; inline int get ( int x ) { return lower_bound ( a + 1 , a + 1 + * a , x ) - a ; } E A [ N ], B [ N ], vec [ N ]; inline ll calc ( int dis ) { ll res = 0 ; * a = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { a [ ++* a ] = p [ i ]. se ; a [ ++* a ] = p [ i ]. se - dis ; a [ ++* a ] = p [ i ]. se + dis ; } sort ( a + 1 , a + 1 + * a ); * a = unique ( a + 1 , a + 1 + * a ) - a - 1 ; int m = * a ; int cA = 0 , cB = 0 , cVec = 0 ; for ( int i = n ; i >= 1 ; -- i ) { int l = get ( p [ i ]. se - dis ), r = get ( p [ i ]. se + dis ); A [ ++ cA ] = { -1 , p [ i ]. fi - dis - 1 , l , r }; B [ ++ cB ] = { 1 , p [ i ]. fi + dis , l , r }; } for ( int i = 1 , sze = n * 2 ; i <= sze ; ++ i ) { if ( ! cA ) vec [ ++ cVec ] = B [ cB -- ]; else if ( ! cB ) vec [ ++ cVec ] = A [ cA -- ]; else if ( A [ cA ]. x < B [ cB ]. x ) { vec [ ++ cVec ] = A [ cA -- ]; } else { vec [ ++ cVec ] = B [ cB -- ]; } } int pos = 0 ; bit . init ( m ); for ( int i = 1 ; i <= cVec ; ++ i ) { while ( pos < n && p [ pos + 1 ]. fi <= vec [ i ]. x ) { ++ pos ; bit . update ( get ( p [ pos ]. se ), 1 ); } res += bit . query ( vec [ i ]. l , vec [ i ]. r ) * vec [ i ]. op ; } res -= n ; res /= 2 ; return res ; } int main () { scanf ( \"%d%lld\" , & n , & K ); for ( int i = 1 , _x , _y ; i <= n ; ++ i ) { scanf ( \"%d%d\" , & _x , & _y ); p [ i ]. fi = _x + _y ; p [ i ]. se = _x - _y ; } sort ( p + 1 , p + 1 + n ); // for (int i = 1; i <= n; ++i) // dbg(i, p[i].fi, p[i].se); int l = 0 , r = 4e8 , res = 0 ; while ( r - l >= 0 ) { int mid = ( l + r ) >> 1 ; if ( calc ( mid ) >= K ) { res = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } printf ( \"%d \\n \" , res ); return 0 ; }","title":"C. Manhattan Distance"},{"location":"trainings/random-trainings/2020-XIII-Samara-Regional-Intercollegiate-Programming-Contest/#d-lexicographically-minimal-shortest-path","text":"Solved By Hsueh-. 1:48(+) \u9898\u610f\uff1a \u6709 n n \u4e2a\u70b9 m m \u6761\u8fb9\u7684\u65e0\u5411\u56fe\uff0c\u65e0\u91cd\u8fb9\u548c\u81ea\u73af\uff0c\u4f46\u662f\u6bcf\u6761\u8fb9\u4e0a\u6709\u4e00\u4e2a\u5c0f\u5199\u5b57\u6bcd c c , \u627e 1 \\to n 1 \\to n \u7684\u6700\u77ed\u8def\uff0c\u5982\u679c\u6709\u591a\u5c11\uff0c\u8f93\u51fa\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u90a3\u6761\uff0c\u8fd9\u91cc\u7684\u5b57\u5178\u5e8f\u6307\u7684\u662f\u6700\u77ed\u8def\u4e0a\u7684\u8fb9\u4e0a\u7684\u5b57\u6bcd\u6309\u987a\u5e8f\u94fe\u63a5\u7ec4\u6210\u7684\u5b57\u7b26\u4e32\u5b57\u5178\u5e8f\u3002 \u601d\u8def\uff1a \u4ece n n \u51fa\u53d1\u8dd1\u4e00\u4e2a\u6700\u77ed\u8def\uff0c\u7136\u540e\u518d\u4ece 1 1 \u51fa\u53d1\uff0c\u6bcf\u6b21\u53bb\u627e\u662f\u6700\u77ed\u8def\u540c\u65f6\u5b57\u6bcd\u6700\u5c0f\u7684\uff0c\u5982\u679c\u6709\u591a\u4e2a\u6700\u5c0f\u7684\uff0c\u90a3\u5c31\u7528 vector \u5b58\u8d77\u6765\uff0c\u6bcf\u4e2a\u8282\u70b9\u90fd\u8dd1\u4e00\u6b21\u3002 \u7531\u4e8e\u662f\u5206\u5c42\u56fe\uff0c\u6bcf\u4e2a\u70b9\u53ea\u4f1a\u88ab\u653e\u5728 vector \u91cc\u9762\u4e00\u6b21\uff0c\u6240\u4ee5\u590d\u6742\u5ea6\u4e3a O(m+nlog_2n) O(m+nlog_2n) \u3002 Code #include <bits/stdc++.h> using namespace std ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } using pIC = pair < int , char > ; const int N = 2e5 + 10 ; int n , m ; vector < vector < pIC >> G ; vector < int > vec [ 2 ]; int pre [ N ]; int d [ N ]; char s [ N ]; int pos [ N ]; int main () { memset ( d , -1 , sizeof d ); scanf ( \"%d %d\" , & n , & m ); G . resize ( n + 1 ); for ( int i = 1 ; i <= m ; ++ i ) { int u , v ; char c ; scanf ( \"%d %d %c\" , & u , & v , & c ); G [ u ]. push_back ( pIC ( v , c )); G [ v ]. push_back ( pIC ( u , c )); } queue < int > q ; d [ n ] = 0 ; q . push ( n ); while ( ! q . empty ()) { int u = q . front (); q . pop (); for ( auto it : G [ u ]) { int v = it . first ; if ( d [ v ] == -1 ) { d [ v ] = d [ u ] + 1 ; q . push ( v ); } } } vec [ 0 ]. push_back ( 1 ); for ( int cas = 1 ; cas <= d [ 1 ]; ++ cas ) { char Max = 'z' + 1 ; for ( auto u : vec [ 0 ]) { for ( auto it : G [ u ]) { if ( d [ u ] == d [ it . first ] + 1 && it . second < Max ) { Max = it . second ; } } } vec [ 1 ]. clear (); for ( auto u : vec [ 0 ]) { for ( auto it : G [ u ]) { if ( d [ u ] == d [ it . first ] + 1 && it . second == Max ) { pre [ it . first ] = u ; vec [ 1 ]. push_back ( it . first ); } } } sort ( vec [ 1 ]. begin (), vec [ 1 ]. end ()); vec [ 1 ]. resize ( unique ( vec [ 1 ]. begin (), vec [ 1 ]. end ()) - vec [ 1 ]. begin ()); swap ( vec [ 0 ], vec [ 1 ]); s [ cas ] = Max ; } s [ d [ 1 ] + 1 ] = 0 ; int u = n , cnt = 0 ; while ( true ) { pos [ ++ cnt ] = u ; if ( u == 1 ) break ; u = pre [ u ]; } reverse ( pos + 1 , pos + 1 + cnt ); printf ( \"%d \\n \" , d [ 1 ]); for ( int i = 1 ; i <= cnt ; ++ i ) { printf ( \"%d%c\" , pos [ i ], \" \\n \" [ i == cnt ]); } puts ( s + 1 ); return 0 ; }","title":"D. Lexicographically Minimal Shortest Path"},{"location":"trainings/random-trainings/2020-XIII-Samara-Regional-Intercollegiate-Programming-Contest/#e-fluctuations-of-mana","text":"Solved By Hsueh-. 0:15(+1) \u9898\u610f\uff1a \u6709 n n \u4e2a\u5750\u6807\uff0c\u6bcf\u8d70\u5230\u7b2c i i \u4e2a\u4f4d\u7f6e\uff0c\u81ea\u8eab\u6cd5\u529b\u503c\u4f1a\u53d8\u5316 a_i a_i \uff0c\u5982\u679c\u6cd5\u529b\u503c \\leq 0 \\leq 0 \u5c31\u4f1a\u6b7b\u4ea1\uff0c\u6c42\u521a\u5f00\u59cb\u7684\u6700\u5c0f\u6cd5\u529b\u503c\u3002 \u601d\u8def\uff1a \u7edf\u8ba1\u524d\u7f00\u548c\uff0c\u7136\u540e\u770b\u6700\u5c0f\u7684\u8d1f\u503c\uff0c\u90a3\u4e48\u521a\u5f00\u59cb\u6cd5\u529b\u503c\u5c31\u8981\u4e3a\u6700\u5c0f\u7684\u8d1f\u6570\u7684\u76f8\u53cd\u6570\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 5e5 + 10 ; int n ; ll a [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld\" , a + i ); a [ i ] += a [ i - 1 ]; } ll res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( a [ i ] <= 0 ) { res = max ( res , - a [ i ]); } } printf ( \"%lld \\n \" , res ); return 0 ; }","title":"E. Fluctuations of Mana"},{"location":"trainings/random-trainings/2020-XIII-Samara-Regional-Intercollegiate-Programming-Contest/#f-moving-target","text":"Solved By Hsueh-. 0:54(+) \u9898\u610f\uff1a \u6709 n n \u4e2a\u7a97\u6237\uff0c\u6709\u4e00\u4e2a\u76ee\u6807\u5728\u67d0\u4e00\u4e2a\u7a97\u6237\u540e\u9762\uff0c\u4f46\u662f\u5e76\u4e0d\u77e5\u9053\u5728\u54ea\u4e2a\u7a97\u6237\u540e\u9762\u3002 \u73b0\u5728\u53ef\u4ee5\u5c04\u51fb\uff0c\u5982\u679c\u6ca1\u6709\u51fb\u4e2d\uff0c\u5e76\u4e14\u76ee\u6807\u4e0d\u5728\u7b2c n n \u4e2a\u7a97\u6237\u540e\u9762\uff0c\u90a3\u4e48\u76ee\u6807\u4f1a\u5f80\u53f3\u8fb9\u79fb\u52a8\u4e00\u4e2a\u7a97\u6237\u7684\u4f4d\u7f6e\uff0c\u95ee\u6700\u5c11\u7684\u5c04\u51fb\u6b21\u6570\u4fdd\u8bc1\u4e0d\u7ba1\u76ee\u6807\u5728\u54ea\u513f\uff0c\u90fd\u80fd\u5c06\u4ed6\u51fb\u4e2d\u3002 \u7ed9\u51fa\u5c04\u51fb\u7684\u4f4d\u7f6e\u5e8f\u5217\u3002 \u601d\u8def\uff1a \u4e3a\u4ec0\u4e48\u53ea\u5c04\u51fb 1 1 , n n \u548c\u5947\u6570\u4f4d\u7f6e\u4e0a\u7684\u7a97\u6237\u5c31\u53ef\u4ee5\u4e86\uff0c\u6709\u66f4\u5c0f\u7684\u5c04\u51fb\u6b21\u6570\u5e8f\u5217\u5417\uff1f Code #include <bits/stdc++.h> using namespace std ; int n ; int main () { scanf ( \"%d\" , & n ); printf ( \"%d \\n \" , n / 2 + 1 ); for ( int i = 1 ; i <= n / 2 + 1 ; ++ i ) { printf ( \"%d%c\" , min ( n , 2 * i - 1 ), \" \\n \" [ min ( n , 2 * i - 1 ) == n ]); } return 0 ; }","title":"F. Moving Target"},{"location":"trainings/random-trainings/2020-XIII-Samara-Regional-Intercollegiate-Programming-Contest/#g-nuts-and-bolts","text":"Solved By Hsueh- & ltslts. 3:00(+) \u9898\u610f\uff1a \u6709 n n \u4e2a A \u7269\u54c1\uff0c\u548c n n \u4e2a B \u7269\u54c1\uff0c\u6240\u6709\u7684 A \u7269\u54c1\u7684\u5927\u5c0f\u4e3a [1, n] [1, n] \u4e14\u4e24\u4e24\u4e0d\u540c\uff0c B \u7269\u54c1\u4ea6\u5982\u6b64\u3002 \u4f46\u662f\u5e76\u4e0d\u77e5\u9053\u7b2c i i \u4e2a\u7269\u54c1\u7684\u5927\u5c0f\uff0c\u53ef\u4ee5\u8be2\u95ee 5n \\log n 5n \\log n \u6b21\uff0c\u6bcf\u6b21\u8be2\u95ee\u7ed9\u51fa (i, j) (i, j) \uff0c\u6839\u636e\u7b2c i i \u4e2a A \u7269\u54c1\u548c\u7b2c j j \u4e2a B \u7269\u54c1\u7684\u5927\u5c0f\u5173\u7cfb\u8fd4\u56de < , = , > \u4e09\u79cd\u7ed3\u679c\u3002 \u6700\u540e\u8981\u8f93\u51fa\u4e00\u4e2a\u6392\u5217\uff0c\u8868\u793a\u7b2c i i \u4e2a A \u7269\u54c1\u548c\u7b2c p_i p_i \u4e2a B \u7269\u54c1\u7684\u5927\u5c0f\u76f8\u540c\u3002 \u601d\u8def\uff1a \u7c7b\u4f3c\u4e8e\u5feb\u6392\uff0c\u6bcf\u6b21\u5c06 L,R L,R \u4e24\u4e2a\u96c6\u5408\u5206\u6210\u5c0f\u4e8e pos pos \u548c\u5927\u4e8e pos pos \u7684\u6570\u5b57\uff0c\u7136\u540e\u4e0d\u65ad\u9012\u5f52\u4e0b\u53bb\uff0c\u590d\u6742\u5ea6\u5927\u7ea6\u4e3a O(n \\log n) O(n \\log n) , \u7edf\u8ba1\u6b21\u6570\u5927\u6982\u662f n \\log n n \\log n \u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 1e3 + 10 ; #define dbg(x...) \\ do { \\ cout << #x << \" -> \"; \\ err(x); \\ } while (0) void err () { cout << endl ; } template < class T , class ... Ts > void err ( const T & arg , const Ts & ... args ) { cout << arg << ' ' ; err ( args ...); } mt19937 rnd ( time ( 0 )); // int cnt; int ask ( int x , int y ) { // cnt++; // if (x > y) // return 1; // else if (x < y) // return -1; // else // return 0; printf ( \"? %d %d \\n \" , x , y ); fflush ( stdout ); char c ; scanf ( \" %c\" , & c ); if ( c == '>' ) return 1 ; else if ( c == '<' ) return -1 ; else return 0 ; } int n ; int res [ N ]; void gao ( vector < int > L , vector < int > R ) { // dbg(L.size(), R.size()); if ( L . empty ()) return ; if ( L . size () == 1 ) { res [ L [ 0 ]] = R [ 0 ]; return ; } int pos = rnd () % L . size (); vector < int > rl , rr ; int cur = 0 ; for ( auto it : R ) { int op = ask ( L [ pos ], it ); if ( op == -1 ) { rl . push_back ( it ); } else if ( op == 1 ) { rr . push_back ( it ); } else { cur = it ; } } // dbg(cur, pos); vector < int > ll , lr ; for ( auto it : L ) { if ( it == L [ pos ]) continue ; int op = ask ( it , cur ); if ( op == -1 ) lr . push_back ( it ); else ll . push_back ( it ); } res [ L [ pos ]] = cur ; gao ( ll , rl ); gao ( lr , rr ); } vector < int > a , b ; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { a . push_back ( i ); b . push_back ( i ); } gao ( a , b ); // assert(cnt <= 5 * n * log2(n)); printf ( \"! \" ); for ( int i = 1 ; i <= n ; ++ i ) { printf ( \"%d%c\" , res [ i ], \" \\n \" [ i == n ]); } fflush ( stdout ); return 0 ; }","title":"G. Nuts and Bolts"},{"location":"trainings/random-trainings/2020-XIII-Samara-Regional-Intercollegiate-Programming-Contest/#h-tree-painting","text":"Solved By All. 0:23(+) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u68f5\u6811\uff0c\u6bcf\u6b21\u80fd\u591f\u9009\u62e9\u4e24\u4e2a\u8282\u70b9\uff0c\u5c06\u8fd9\u4e24\u4e2a\u8282\u70b9\u4e4b\u95f4\u7684\u7b80\u5355\u8def\u5f84\u4e0a\u7684\u6240\u6709\u70b9\u548c\u8fb9\u90fd\u6d82\u8272\uff0c\u95ee\u6700\u5c11\u51e0\u6b21\u64cd\u4f5c\u80fd\u591f\u5c06\u8fd9\u68f5\u6811\u7684\u6240\u6709\u70b9\u548c\u8fb9\u90fd\u6d82\u8272\u3002 \u601d\u8def\uff1a \u7b54\u6848\u4e3a \\frac{\\mbox{\u5ea6\u6570\u4e3a1\u7684\u70b9\u7684\u4e2a\u6570} + 1}{2} \\frac{\\mbox{\u5ea6\u6570\u4e3a1\u7684\u70b9\u7684\u4e2a\u6570} + 1}{2} \u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 2e5 + 10 ; int n , d [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 , u , v ; i < n ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); ++ d [ u ], ++ d [ v ]; } int res = 0 ; for ( int i = 1 ; i <= n ; ++ i ) res += ( d [ i ] == 1 ); printf ( \"%d \\n \" , ( res + 1 ) / 2 ); return 0 ; }","title":"H. Tree Painting"},{"location":"trainings/random-trainings/2020-XIII-Samara-Regional-Intercollegiate-Programming-Contest/#i-sorting-colored-array","text":"Solved By Dup4 & ltslts. 0:32(+) \u9898\u610f\uff1a \u6709 n n \u4e2a\u6570\u5b57\uff0c\u6bcf\u4e2a\u6570\u5b57\u6709\u4e00\u79cd\u989c\u8272 c_i c_i \uff0c\u548c\u4e00\u4e2a\u6743\u503c a_i a_i , \u6bcf\u6b21\u53ef\u4ee5\u9009\u62e9\u4efb\u610f\u4e24\u4e2a\u76f8\u90bb\u7684\u5e76\u4e14\u989c\u8272\u4e0d\u540c\u7684\u6570\u5b57\u8fdb\u884c\u4ea4\u6362\uff0c\u95ee\u80fd\u5426\u5728\u6709\u9650\u6b65\u5185\u4f7f\u5f97\u8be5\u5e8f\u5217\u53d8\u6210\u5347\u5e8f\u3002 \u601d\u8def\uff1a \u663e\u7136\u540c\u4e00\u79cd\u989c\u8272\u7684\u6570\u5b57\u7684\u76f8\u5bf9\u4f4d\u7f6e\u4e0d\u4f1a\u6539\u53d8\uff0c\u4e0d\u7528\u989c\u8272\u7684\u53ef\u4ee5\u4efb\u610f\u4ea4\u6362\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u5224\u65ad\u6bcf\u4e00\u79cd\u989c\u8272\u5bf9\u5e94\u7684\u5b50\u5e8f\u5217\u662f\u5426\u4e3a\u5347\u5e8f\u5373\u53ef\u3002 Code #include <bits/stdc++.h> using namespace std ; const int N = 2e5 + 10 ; int n ; int main () { scanf ( \"%d\" , & n ); vector < int > vec [ N ]; for ( int i = 1 , a , c ; i <= n ; ++ i ) { scanf ( \"%d%d\" , & a , & c ); vec [ c ]. push_back ( a ); } int ok = 1 ; for ( auto & it : vec ) if ( ! it . empty ()) { int pre = -2e9 ; for ( auto & v : it ) { if ( pre > v ) { ok = 0 ; break ; } pre = v ; } } puts ( ok ? \"YES\" : \"NO\" ); return 0 ; }","title":"I. Sorting Colored Array"},{"location":"trainings/random-trainings/2020-XIII-Samara-Regional-Intercollegiate-Programming-Contest/#j-the-battle-of-mages","text":"Solved By Hsueh- & ltslts. 2:06(+) \u9898\u610f\uff1a \u6784\u9020\u4e24\u4e2a\u957f\u5ea6\u4e3a n,m(3 \\leq n, m \\leq 10) n,m(3 \\leq n, m \\leq 10) \u7684\u5e8f\u5217\uff0c\u4f7f\u5f97\u5206\u522b\u968f\u610f\u9009\u53d6\u4e00\u4e2a\u6216\u4e09\u4e2a\u5e8f\u5217\u4e2d\u7684\u5143\u7d20\uff0c\u7136\u540e\u5e8f\u5217\u4e00\u7684\u548c\u5927\u4e8e\u5e8f\u5217\u4e8c\u7684\u548c\u7684\u6982\u7387\u9ad8\uff0c\u5206\u522b\u968f\u610f\u9009\u53d6\u4e24\u4e2a\u5e8f\u5217\u4e2d\u7684\u5143\u7d20\uff0c\u7136\u540e\u5e8f\u5217\u4e00\u7684\u548c\u5927\u4e8e\u5e8f\u5217\u4e8c\u7684\u548c\u7684\u6982\u7387\u4f4e \u601d\u8def\uff1a \u5feb\u4e50\u6253\u8868\u9898\u3002 Code #include <bits/stdc++.h> using namespace std ; int main () { printf ( \"5 \\n \" ); printf ( \"1 2 7 8 10 \\n \" ); printf ( \"5 \\n \" ); printf ( \"2 4 6 7 9 \\n \" ); return 0 ; } \u6253\u8868\u4ee3\u7801 #include <bits/stdc++.h> using namespace std ; bool ok1 ( vector < int > v1 , vector < int > v2 ) { int cnt = 0 ; for ( auto it1 : v1 ) { for ( auto it2 : v2 ) { if ( it1 > it2 ) { cnt ++ ; } if ( it1 < it2 ) { cnt -- ; } } } return cnt > 0 ; } bool ok2 ( vector < int > v1 , vector < int > v2 ) { int cnt = 0 ; for ( int i = 0 , len1 = v1 . size (); i < len1 ; ++ i ) { for ( int j = 0 , len2 = v2 . size (); j < len2 ; ++ j ) { for ( int ii = i + 1 ; ii < len1 ; ++ ii ) { for ( int jj = j + 1 ; jj < len2 ; ++ jj ) { if ( v1 [ i ] + v1 [ ii ] > v2 [ j ] + v2 [ jj ]) { cnt ++ ; } if ( v1 [ i ] + v1 [ ii ] < v2 [ j ] + v2 [ jj ]) { cnt -- ; } } } } } return cnt < 0 ; } bool ok3 ( vector < int > v1 , vector < int > v2 ) { int cnt = 0 ; for ( int i = 0 ; i < v1 . size (); ++ i ) { for ( int j = 0 ; j < v2 . size (); ++ j ) { for ( int ii = i + 1 ; ii < v1 . size (); ++ ii ) { for ( int jj = j + 1 ; jj < v2 . size (); ++ jj ) { for ( int iii = ii + 1 ; iii < v1 . size (); ++ iii ) { for ( int jjj = jj + 1 ; jjj < v2 . size (); ++ jjj ) { if ( v1 [ i ] + v1 [ ii ] + v1 [ iii ] > v2 [ j ] + v2 [ jj ] + v2 [ jjj ]) { cnt ++ ; } if ( v1 [ i ] + v1 [ ii ] + v1 [ iii ] < v2 [ j ] + v2 [ jj ] + v2 [ jjj ]) { cnt -- ; } } } } } } } return cnt > 0 ; } mt19937 rnd ( time ( 0 )); int main () { while ( true ) { vector < int > v1 , v2 ; for ( int i = 1 ; i <= 10 ; ++ i ) { if ( rnd () % 2 == 0 ) { v1 . push_back ( i ); } if ( rnd () % 2 == 0 ) { v2 . push_back ( i ); } } if ( v1 . size () < 3 || v2 . size () < 3 ) continue ; if ( ok1 ( v1 , v2 ) && ok2 ( v1 , v2 ) && ok3 ( v1 , v2 )) { cout << \"ok\" << endl ; for ( auto it : v1 ) { cout << it << \" \" ; } cout << endl ; for ( auto it : v2 ) { cout << it << \" \" ; } cout << endl ; system ( \"pause\" ); } } return 0 ; }","title":"J. The Battle of Mages"},{"location":"trainings/random-trainings/2020-XIII-Samara-Regional-Intercollegiate-Programming-Contest/#k-table","text":"Solved By ltslts. 1:14(+) \u9898\u610f\uff1a \u7ed9\u51fa\u4e00\u4e2a\u684c\u5b50\u76844\u6761\u684c\u817f\u957f\u5ea6\uff0c\u8981\u6c42\u684c\u817f\u5b89\u88c5\u5782\u76f4\u4e8e\u684c\u9762\uff0c\u5e76\u4e14\u684c\u817f\u5728\u684c\u9762\u7684\u6295\u5f71\u4e3a\u4e00\u4e2a\u77e9\u5f62\u76844\u4e2a\u9876\u70b9\uff0c\u5224\u65ad\u53ef\u5426\u4f7f\u5f97\u684c\u5b50\u7a33\u5b9a\u7ad9\u7acb\uff08\u684c\u9762\u53ef\u4ee5\u503e\u659c\uff09 \u601d\u8def\uff1a \u4ee5\u684c\u9762\u4e3a\u5e95\u9762\uff0c\u53ea\u8981\u4f7f\u5f97 ABCD ABCD \u56db\u70b9\u5171\u9762\uff0c\u684c\u5b50\u5373\u53ef\u7a33\u5b9a\u3002 \u56e0\u4e3a\u5e95\u9762\u7684\u56db\u8fb9\u5f62\u4e3a\u77e9\u5f62\uff0c\u6240\u4ee5\u53ea\u8981\u8bc1\u660e AB=CD AB=CD \u6216\u8005 AC=BD AC=BD \u5373\u53ef\u8bc1\u660e\u56db\u8fb9\u5f62 ABDC ABDC \u662f\u5e73\u884c\u56db\u8fb9\u5f62\u3002 Code #include <bits/stdc++.h> using namespace std ; int a [ 5 ]; int main () { for ( int i = 1 ; i <= 4 ; ++ i ) { scanf ( \"%d\" , a + i ); } sort ( a + 1 , a + 1 + 4 ); if ( a [ 4 ] - a [ 3 ] == a [ 2 ] - a [ 1 ]) puts ( \"YES\" ); else puts ( \"NO\" ); return 0 ; }","title":"K. Table"},{"location":"trainings/random-trainings/2020-XIII-Samara-Regional-Intercollegiate-Programming-Contest/#l-the-dragon-land","text":"Solved By Hsueh- & ltslts. 0:59(+) \u9898\u610f\uff1a \u6709 n n \u53ea\u6050\u9f99\uff0c\u6253\u8d25\u7b2c i i \u53ea\u6050\u9f99\u53ef\u4ee5\u83b7\u5f97 a_i a_i \u7684\u91d1\u5e01\uff0c\u4f46\u662f\u8981\u6263\u9664\u82b1\u8d39\uff0c\u82b1\u8d39\u4e3a\u4f60\u5df2\u7ecf\u51fb\u8d25\u8fc7\u7684\u6050\u9f99\u4e2a\u6570 +1 +1 \uff0c\u8fd9\u91cc\u662f\u5148\u52a0\u4e0a\u91d1\u5e01\uff0c\u518d\u6263\u9664\u82b1\u8d39\u3002 \u6309\u987a\u5e8f\u6253\u6050\u9f99\uff0c\u6bcf\u6b21\u53ef\u4ee5\u9009\u62e9\u6253\u6216\u8005\u4e0d\u6253\uff0c\u95ee\u6700\u5927\u6536\u76ca\u3002 \u601d\u8def\uff1a \u5f88\u663e\u7136\u987a\u5e8f\u662f\u968f\u610f\u7684\uff0c\u56e0\u4e3a\u6253\u7684\u6050\u9f99\u4e00\u6837\uff0c\u6536\u76ca\u4e00\u6837\uff0c\u4e2a\u6570\u4e00\u6837\uff0c\u6240\u4ee5\u6700\u7ec8\u7ed3\u679c\u4e00\u6837\u3002 \u5bf9\u6050\u9f99\u6392\u5e8f\uff0c\u627e\u6700\u5927\u7684\u51e0\u4e2a\u6253\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 2e5 + 10 ; int n ; ll a [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%lld\" , a + i ); } sort ( a + 1 , a + 1 + n ); ll res = 0 ; for ( int i = n , j = 1 ; i >= 1 ; -- i , ++ j ) { res += max ( 0l l , 1l l * a [ i ] - j ); } printf ( \"%lld \\n \" , res ); return 0 ; }","title":"L. The Dragon Land"},{"location":"trainings/random-trainings/2020-XIII-Samara-Regional-Intercollegiate-Programming-Contest/#m-notifications","text":"Solved By Hsueh-. 0:39(+) \u9898\u610f\uff1a \u6709 n n \u4e2a\u4efb\u52a1\uff0c\u6bcf\u4e2a\u4efb\u52a1\u6709\u5230\u8fbe\u65f6\u95f4\u548c\u6301\u7eed\u65f6\u95f4\uff0c\u4e3a\u9700\u8981\u591a\u4e45\u624d\u80fd\u5b8c\u6210\u6240\u6709\u4efb\u52a1\u3002 \u601d\u8def\uff1a \u6a21\u62df\u3002 Code #include <bits/stdc++.h> using namespace std ; using ll = long long ; const int N = 2e5 + 10 ; int n ; int t [ N ], d [ N ]; int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d %d\" , t + i , d + i ); } ll res = 0 ; int pos = 1 ; priority_queue < int , vector < int > , greater < int >> q ; while ( true ) { if ( pos > n && q . empty ()) break ; while ( pos <= n && t [ pos ] <= res ) { q . push ( d [ pos ]); pos ++ ; } if ( ! q . empty ()) { res += q . top (); q . pop (); } else { res = t [ pos ]; } } printf ( \"%lld \\n \" , res ); return 0 ; }","title":"M. Notifications"}]}